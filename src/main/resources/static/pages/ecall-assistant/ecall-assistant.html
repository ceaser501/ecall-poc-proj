<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Report Reception - E-Call Assistant</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, rgb(248, 250, 252) 0%, rgb(226, 232, 240) 100%);
            min-height: 100vh;
        }

        /* Header */
        .header {
            background: white;
            border-bottom: 1px solid rgb(226, 232, 240);
        }

        .header-container {
            max-width: 2400px;
            margin: 0 auto;
            padding: 1rem 1.5rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .header-icon {
            background: linear-gradient(135deg, rgb(239, 68, 68) 0%, rgb(220, 38, 38) 100%);
            padding: 0.625rem;
            border-radius: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .header-icon svg {
            width: 1.25rem;
            height: 1.25rem;
            color: white;
        }

        .header-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: rgb(15, 23, 42);
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .status-dot {
            width: 0.5rem;
            height: 0.5rem;
            background: rgb(148, 163, 184);
            border-radius: 50%;
            animation: pulse 2s ease-in-out infinite;
        }

        .status-dot.active {
            background: rgb(34, 197, 94);
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .status-text {
            color: rgb(71, 85, 105);
        }

        .status-time {
            color: rgb(15, 23, 42);
            font-weight: 600;
        }

        .btn {
            padding: 0.5rem 1rem;
            border: 1px solid rgb(226, 232, 240);
            border-radius: 0.375rem;
            background: white;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            transition: all 0.2s;
        }

        .btn:hover {
            background: rgb(248, 250, 252);
            border-color: rgb(203, 213, 225);
        }

        .btn.active {
            background: rgb(59, 130, 246);
            border-color: rgb(59, 130, 246);
            color: white;
        }

        .btn.active:hover {
            background: rgb(37, 99, 235);
            border-color: rgb(37, 99, 235);
        }

        .btn-primary {
            background: rgb(59, 130, 246);
            border-color: rgb(59, 130, 246);
            color: white;
        }

        .btn-primary:hover {
            background: rgb(37, 99, 235);
            border-color: rgb(37, 99, 235);
        }

        .btn-icon {
            width: 2rem;
            height: 2rem;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .btn svg {
            width: 1rem;
            height: 1rem;
        }

        .header-logout-btn {
            background: #1e293b;
            color: white;
            padding: 0.375rem 0.625rem;
            border: 1px solid #1e293b;
            border-radius: 0.375rem;
            font-size: 0.8125rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            height: 2rem;
            display: inline-flex;
            align-items: center;
        }

        .header-logout-btn:hover {
            background: #0f172a;
            border-color: #0f172a;
        }

        .header-user-info {
            position: relative;
            display: inline-block;
            margin-right: 1rem;
            cursor: pointer;
        }

        .header-user-name {
            font-size: 0.875rem;
            color: rgb(15, 23, 42);
            font-weight: 500;
        }

        .header-user-popup {
            display: none;
            position: absolute;
            top: calc(100% + 8px);
            right: 0;
            background: white;
            border: 1px solid rgb(226, 232, 240);
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            min-width: 360px;
            z-index: 1000;
        }

        .header-user-popup.show {
            display: block;
        }

        .header-user-popup .panel-header {
            background: rgb(248, 250, 252);
            padding: 1rem 1.25rem;
            border-bottom: 1px solid rgb(226, 232, 240);
            border-radius: 0.5rem 0.5rem 0 0;
        }

        .header-user-popup .panel-title {
            margin: 0;
            font-size: 1rem;
            font-weight: 600;
            color: rgb(15, 23, 42);
        }

        .header-user-popup .panel-body {
            padding: 1.5rem;
        }

        .header-user-popup .operator-info {
            display: flex;
            flex-direction: row;
            align-items: flex-start;
            gap: 1rem;
        }

        .header-user-popup .operator-name {
            font-weight: 600;
            color: rgb(15, 23, 42);
            margin: 0 0 0.375rem 0;
            font-size: 1rem;
        }

        .header-user-popup .operator-dept {
            color: rgb(100, 116, 139);
            font-size: 0.875rem;
            margin: 0 0 0.25rem 0;
        }

        .header-user-popup .operator-exp {
            color: rgb(148, 163, 184);
            font-size: 0.875rem;
            margin: 0;
        }

        /* Operator Status */
        .operator-status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
            margin-left: 8px;
            vertical-align: middle;
        }

        .operator-status-dot.on-call {
            background-color: #ef4444;
            box-shadow: 0 0 0 2px rgba(239, 68, 68, 0.2);
        }

        .operator-status-dot.available {
            background-color: #22c55e;
            box-shadow: 0 0 0 2px rgba(34, 197, 94, 0.2);
        }

        .operator-status-dot.away {
            background-color: #eab308;
            box-shadow: 0 0 0 2px rgba(234, 179, 8, 0.2);
        }

        .status-selector {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid rgb(226, 232, 240);
        }

        .status-selector-label {
            font-size: 0.875rem;
            font-weight: 600;
            color: rgb(71, 85, 105);
            margin-bottom: 0.5rem;
            display: block;
        }

        .status-options {
            display: flex;
            gap: 0.5rem;
        }

        .status-option {
            flex: 1;
            padding: 0.5rem;
            border: 2px solid rgb(226, 232, 240);
            border-radius: 0.375rem;
            cursor: pointer;
            text-align: center;
            font-size: 0.75rem;
            font-weight: 500;
            transition: all 0.2s;
            background: white;
        }

        .status-option:hover {
            border-color: rgb(148, 163, 184);
        }

        .status-option.active {
            background: rgb(241, 245, 249);
        }

        .status-option.on-call.active {
            border-color: #ef4444;
            background: rgba(239, 68, 68, 0.1);
            color: #dc2626;
        }

        .status-option.available.active {
            border-color: #22c55e;
            background: rgba(34, 197, 94, 0.1);
            color: #16a34a;
        }

        .status-option.away.active {
            border-color: #eab308;
            background: rgba(234, 179, 8, 0.1);
            color: #ca8a04;
        }

        /* Team Selection Card */
        .team-card {
            border: 2px solid rgb(226, 232, 240);
            border-radius: 0.5rem;
            padding: 1rem;
            margin-bottom: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
            background: white;
            position: relative;
        }

        .team-card:last-child {
            margin-bottom: 0;
        }

        .team-card:hover {
            border-color: rgb(59, 130, 246);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .team-card.selected {
            border-color: rgb(59, 130, 246);
            background: rgba(59, 130, 246, 0.05);
        }

        .team-card-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 0.75rem;
        }

        .team-radio {
            width: 18px;
            height: 18px;
            flex-shrink: 0;
            cursor: pointer;
        }

        .team-info {
            flex: 1;
        }

        .team-name {
            display: inline-block;
            font-size: 1rem;
            font-weight: 600;
            color: rgb(15, 23, 42);
            margin-right: 0.5rem;
        }

        .team-status {
            display: inline-block;
            font-size: 0.75rem;
            padding: 0.125rem 0.5rem;
            border-radius: 0.25rem;
            background: rgb(34, 197, 94);
            color: white;
            font-weight: 500;
        }

        .ai-recommended-badge {
            position: absolute;
            top: 0.75rem;
            right: 0.75rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-size: 0.75rem;
            padding: 0.25rem 0.75rem;
            border-radius: 1rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.25rem;
            box-shadow: 0 2px 4px rgba(102, 126, 234, 0.3);
        }

        .ai-icon {
            width: 14px;
            height: 14px;
        }

        .team-details {
            padding-left: 0;
            font-size: 0.875rem;
            color: rgb(71, 85, 105);
        }

        .team-detail-row {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 0.375rem;
        }

        .team-detail-label {
            font-weight: 600;
            min-width: 100px;
        }

        .team-detail-value {
            color: rgb(51, 65, 85);
        }

        .team-members {
            margin-top: 0.5rem;
            padding-top: 0.5rem;
            border-top: 1px solid rgb(226, 232, 240);
        }

        .team-member {
            padding: 0.25rem 0;
        }

        /* Main Content */
        .main-content {
            max-width: 2400px;
            margin: 0 auto;
            padding: 1.5rem;
        }

        .grid-container {
            display: grid;
            grid-template-columns: minmax(280px, 1fr) minmax(600px, 2fr) minmax(280px, 1fr);
            gap: 1.5rem;
        }

        @media (max-width: 1400px) {
            .grid-container {
                grid-template-columns: 1fr;
            }

            .left-sidebar, .right-sidebar {
                display: none;
            }
        }

        .panel {
            background: white;
            border-radius: 0.75rem;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1);
            border: 1px solid rgb(226, 232, 240);
        }

        .panel-header {
            padding: 1.25rem;
            border-bottom: 1px solid rgb(226, 232, 240);
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: relative;
        }

        .panel-title {
            font-size: 1.125rem;
            font-weight: 600;
            color: rgb(15, 23, 42);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .panel-body {
            padding: 1.25rem;
        }

        /* Left Sidebar - Caller Info */
        .form-group {
            margin-bottom: 0.75rem;
        }

        .form-label {
            display: block;
            font-size: 0.875rem;
            font-weight: 500;
            color: rgb(51, 65, 85);
            margin-bottom: 0.375rem;
        }

        /* Tooltip styles */
        .severity-label-wrapper {
            position: relative;
            display: inline-flex;
            align-items: center;
            gap: 0.375rem;
        }

        .severity-info-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: rgb(226, 232, 240);
            color: rgb(71, 85, 105);
            font-size: 11px;
            font-weight: 600;
            cursor: help;
            transition: all 0.2s;
            position: relative;
        }

        .severity-info-icon:hover {
            background: rgb(59, 130, 246);
            color: white;
        }

        .severity-tooltip {
            visibility: hidden;
            opacity: 0;
            position: absolute;
            bottom: calc(100% + 8px);
            left: 50%;
            transform: translateX(-50%);
            width: 320px;
            background: rgb(30, 41, 59);
            color: white;
            padding: 12px 14px;
            border-radius: 8px;
            font-size: 12px;
            line-height: 1.5;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            z-index: 10000;
            transition: all 0.2s;
            pointer-events: none;
        }

        .severity-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: rgb(30, 41, 59);
        }

        .severity-info-icon:hover .severity-tooltip {
            visibility: visible;
            opacity: 1;
        }

        .severity-tooltip-section {
            margin-bottom: 8px;
        }

        .severity-tooltip-section:last-child {
            margin-bottom: 0;
        }

        .severity-tooltip-title {
            font-weight: 600;
            color: rgb(96, 165, 250);
            margin-bottom: 4px;
        }

        .severity-tooltip-list {
            margin: 4px 0 0 0;
            padding-left: 16px;
        }

        .severity-tooltip-list li {
            margin-bottom: 2px;
        }

        .form-input, .form-select {
            width: 100%;
            padding: 0.5rem 0.75rem;
            border: 1px solid rgb(226, 232, 240);
            border-radius: 0.375rem;
            font-size: 0.875rem;
            background: white;
            transition: all 0.2s;
        }

        .form-input:focus, .form-select:focus {
            outline: none;
            border-color: rgb(59, 130, 246);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .form-input:read-only {
            background: rgb(248, 250, 252);
        }

        .form-input::placeholder {
            color: rgb(156, 163, 175);
        }

        .form-input:invalid,
        select.form-input:invalid {
            color: rgb(156, 163, 175);
        }

        select.form-input option[value=""] {
            color: rgb(156, 163, 175);
        }

        select.form-input option:not([value=""]) {
            color: rgb(15, 23, 42);
        }

        .btn-update {
            width: 100%;
            background: rgb(71, 85, 105);
            border-color: rgb(71, 85, 105);
            color: white;
            margin-top: 0.75rem;
        }

        .btn-update:hover {
            background: rgb(51, 65, 85);
            border-color: rgb(51, 65, 85);
        }

        .divider {
            margin: 1.25rem 0;
            padding-top: 1.25rem;
            border-top: 1px solid rgb(226, 232, 240);
        }

        .btn-checklist {
            width: 100%;
            justify-content: center;
        }

        /* Center Panel - Transcript */
        .transcript-panel {
            height: 850px;
            max-height: 850px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .transcript-header-info {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            color: rgb(71, 85, 105);
            font-size: 0.875rem;
        }

        .transcript-messages {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .message {
            padding: 1rem;
            border-radius: 0.5rem;
            border: 2px solid;
        }

        .message-operator {
            background: rgb(236, 253, 245);
            border-color: rgb(167, 243, 208);
        }

        .message-caller {
            background: rgb(239, 246, 255);
            border-color: rgb(191, 219, 254);
        }

        .message-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.5rem;
        }

        .message-sender {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .sender-avatar {
            width: 1.5rem;
            height: 1.5rem;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .operator-avatar {
            background: rgb(5, 150, 105);
        }

        .caller-avatar {
            background: rgb(37, 99, 235);
        }

        .sender-name {
            font-weight: 600;
            color: rgb(15, 23, 42);
        }

        .message-time {
            color: rgb(100, 116, 139);
            font-size: 0.875rem;
        }

        .message-text {
            color: rgb(51, 65, 85);
            line-height: 1.5;
            margin-left: 2rem;
        }

        .transcript-footer {
            border-top: 1px solid rgb(226, 232, 240);
            padding: 0.75rem;
            background: rgb(248, 250, 252);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.5rem;
        }

        .recording-dot {
            width: 0.5rem;
            height: 0.5rem;
            background: rgb(239, 68, 68);
            border-radius: 50%;
            animation: pulse 1.5s ease-in-out infinite;
        }

        .recording-text {
            color: rgb(71, 85, 105);
            font-size: 0.875rem;
        }

        /* Right Sidebar */
        .operator-info {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .operator-avatar-lg {
            width: 4rem;
            height: 4rem;
            border-radius: 50%;
            background: rgb(226, 232, 240);
            overflow: hidden;
            flex-shrink: 0;
        }

        .operator-avatar-lg img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .operator-details {
            display: flex;
            flex-direction: column;
            gap: 0.125rem;
        }

        .operator-name {
            font-weight: 600;
            color: rgb(15, 23, 42);
        }

        .operator-dept {
            color: rgb(71, 85, 105);
            font-size: 0.875rem;
        }

        .operator-exp {
            color: rgb(100, 116, 139);
            font-size: 0.875rem;
        }

        .manual-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            max-height: 175px; /* Exactly 4 items visible (each item ~35px + 8px gap) */
            overflow-y: auto;
        }

        .manual-item {
            background: rgb(241, 245, 249);
            padding: 0.625rem;
            border-radius: 0.5rem;
            color: rgb(51, 65, 85);
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.875rem;
        }

        .manual-item:hover {
            background: rgb(226, 232, 240);
        }

        .timeline-list {
            display: flex;
            flex-direction: column;
            gap: 0.625rem;
        }

        .timeline-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            color: rgb(51, 65, 85);
            font-size: 0.875rem;
        }

        .timeline-time {
            color: rgb(100, 116, 139);
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
        }

        .modal-content {
            background: white;
            margin: 2rem auto;
            padding: 0;
            border-radius: 0.75rem;
            width: 90%;
            max-width: 700px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            max-height: calc(100vh - 4rem);
            display: flex;
            flex-direction: column;
        }

        .modal-header {
            padding: 1.25rem 1.5rem;
            border-bottom: 1px solid rgb(226, 232, 240);
            flex-shrink: 0;
        }

        .modal-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: rgb(15, 23, 42);
        }

        .modal-desc {
            margin-top: 0.5rem;
            color: rgb(71, 85, 105);
            font-size: 0.875rem;
        }

        .modal-body {
            padding: 1rem 1.5rem 1rem 1.5rem;
            overflow-y: auto;
            flex: 1;
            min-height: 0;
        }

        .modal-footer {
            padding: 1rem 1.5rem;
            border-top: 1px solid rgb(226, 232, 240);
            display: flex;
            gap: 0.5rem;
            justify-content: flex-end;
            flex-shrink: 0;
        }

        .close-btn {
            position: absolute;
            top: 1.5rem;
            right: 1.5rem;
            background: none;
            border: none;
            font-size: 1.5rem;
            color: rgb(100, 116, 139);
            cursor: pointer;
            padding: 0;
            width: 2rem;
            height: 2rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .close-btn:hover {
            color: rgb(15, 23, 42);
        }

        /* Checklist */
        .checklist-items {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .checklist-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1rem;
            background: rgb(248, 250, 252);
            border-radius: 0.5rem;
        }

        .checklist-question {
            color: rgb(51, 65, 85);
            flex: 1;
        }

        .checklist-buttons {
            display: flex;
            gap: 0.5rem;
            margin-left: 1rem;
        }

        .btn-yes, .btn-no {
            padding: 0.375rem 0.75rem;
            font-size: 0.875rem;
            border-radius: 0.375rem;
            border: 1px solid;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.25rem;
            transition: all 0.2s;
        }

        .btn-yes {
            background: white;
            border-color: rgb(226, 232, 240);
            color: rgb(71, 85, 105);
        }

        .btn-yes.active {
            background: rgb(34, 197, 94);
            border-color: rgb(34, 197, 94);
            color: white;
        }

        .btn-no {
            background: white;
            border-color: rgb(226, 232, 240);
            color: rgb(71, 85, 105);
        }

        .btn-no.active {
            background: rgb(239, 68, 68);
            border-color: rgb(239, 68, 68);
            color: white;
        }

        /* Upload Modal */
        .upload-area {
            border: 2px dashed rgb(203, 213, 225);
            border-radius: 0.5rem;
            padding: 3rem 2rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .upload-area:hover {
            border-color: rgb(59, 130, 246);
        }

        .upload-icon {
            width: 3rem;
            height: 3rem;
            margin: 0 auto 0.75rem;
            color: rgb(148, 163, 184);
        }

        .upload-text {
            color: rgb(51, 65, 85);
            font-weight: 500;
            margin-bottom: 0.25rem;
        }

        .upload-subtext {
            color: rgb(100, 116, 139);
            font-size: 0.875rem;
        }

        .file-input {
            display: none;
        }

        .uploaded-file {
            background: rgb(239, 246, 255);
            border: 1px solid rgb(191, 219, 254);
            border-radius: 0.5rem;
            padding: 1rem;
            margin-top: 1rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .file-info-wrapper {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .file-icon {
            color: rgb(37, 99, 235);
        }

        .file-details {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .file-name {
            color: rgb(15, 23, 42);
            font-weight: 500;
        }

        .file-size {
            color: rgb(100, 116, 139);
            font-size: 0.875rem;
        }

        .remove-file-btn {
            background: none;
            border: none;
            color: rgb(71, 85, 105);
            cursor: pointer;
            padding: 0.25rem;
        }

        .remove-file-btn:hover {
            color: rgb(15, 23, 42);
        }

        /* Empty State */
        .empty-state {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            min-height: 600px;
        }

        .empty-state.hidden {
            display: none;
        }

        .empty-state-content {
            text-align: center;
            max-width: 400px;
        }

        .empty-state-icon-wrapper {
            position: relative;
            display: inline-block;
            margin-bottom: 1.5rem;
        }

        .empty-state-icon {
            width: 96px;
            height: 96px;
            border-radius: 50%;
            background: rgb(248, 250, 252);
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 1rem;
            color: rgb(148, 163, 184);
        }

        .empty-state-pulse {
            position: absolute;
            top: -4px;
            right: -4px;
            width: 24px;
            height: 24px;
            background: rgb(203, 213, 225);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: pulse 2s ease-in-out infinite;
        }

        .empty-state-pulse::after {
            content: '';
            width: 12px;
            height: 12px;
            background: rgb(148, 163, 184);
            border-radius: 50%;
        }

        .empty-state-title {
            font-size: 1.125rem;
            font-weight: 600;
            color: rgb(15, 23, 42);
            margin-bottom: 0.5rem;
        }

        .empty-state-description {
            color: rgb(100, 116, 139);
            margin-bottom: 1.5rem;
        }

        .empty-state-badge {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: rgb(248, 250, 252);
            border-radius: 9999px;
        }

        .empty-state-badge-dot {
            width: 8px;
            height: 8px;
            background: rgb(148, 163, 184);
            border-radius: 50%;
            animation: pulse 2s ease-in-out infinite;
        }

        .empty-state-badge span {
            color: rgb(100, 116, 139);
            font-size: 0.875rem;
        }

        .checklist-pulse-dot {
            display: inline-block;
            width: 8px;
            height: 8px;
            background: rgb(239, 68, 68);
            border-radius: 50%;
            margin-right: 0.5rem;
            animation: pulse 2s ease-in-out infinite;
        }

        .btn-checklist.has-checklist {
            background: rgb(254, 242, 242);
            border-color: rgb(239, 68, 68);
            color: rgb(220, 38, 38);
            font-weight: 600;
            box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.1);
        }

        .btn-checklist.has-checklist:hover {
            background: rgb(254, 226, 226);
            border-color: rgb(220, 38, 38);
            color: rgb(185, 28, 28);
        }

        .checklist-required-badge {
            display: inline-block;
            margin-left: 0.5rem;
            padding: 0.125rem 0.5rem;
            font-size: 0.625rem;
            font-weight: 700;
            background: rgb(239, 68, 68);
            color: white;
            border-radius: 9999px;
            letter-spacing: 0.05em;
        }

        /* Checklist completed state */
        .btn-checklist.checklist-completed {
            background: rgb(240, 253, 244);
            border-color: rgb(34, 197, 94);
            color: rgb(22, 163, 74);
            font-weight: 600;
            box-shadow: 0 0 0 3px rgba(34, 197, 94, 0.1);
            cursor: not-allowed;
            opacity: 0.9;
        }

        .btn-checklist.checklist-completed:hover {
            background: rgb(240, 253, 244);
            border-color: rgb(34, 197, 94);
            color: rgb(22, 163, 74);
        }

        .btn-checklist.checklist-completed svg {
            margin-right: 0.5rem;
        }

        .btn-manual-update {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            width: 100%;
            padding: 0.5rem 0.75rem;
            background: rgb(59, 130, 246);
            border: 1px solid rgb(59, 130, 246);
            color: white;
            font-size: 0.875rem;
            font-weight: 500;
            border-radius: 0.375rem;
            cursor: pointer;
            transition: all 0.2s;
            margin-bottom: 1rem;
        }

        .btn-manual-update:hover {
            background: rgb(37, 99, 235);
            border-color: rgb(37, 99, 235);
        }

        .btn-manual-update:active {
            background: rgb(29, 78, 216);
            transform: scale(0.98);
        }

        .btn-manual-update svg {
            flex-shrink: 0;
        }

        /* Toast Notification */
        .toast-container {
            position: fixed;
            top: 5rem;
            right: 2rem;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .toast {
            min-width: 320px;
            max-width: 480px;
            padding: 1rem 1.25rem;
            background: white;
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            display: flex;
            align-items: center;
            gap: 0.75rem;
            animation: slideIn 0.3s ease-out;
            border-left: 4px solid;
        }

        .toast.success {
            border-left-color: rgb(34, 197, 94);
        }

        .toast.error {
            border-left-color: rgb(239, 68, 68);
        }

        .toast.warning {
            border-left-color: rgb(251, 146, 60);
        }

        .toast.info {
            border-left-color: rgb(59, 130, 246);
        }

        .toast-icon {
            flex-shrink: 0;
            width: 24px;
            height: 24px;
        }

        .toast.success .toast-icon {
            color: rgb(34, 197, 94);
        }

        .toast.error .toast-icon {
            color: rgb(239, 68, 68);
        }

        .toast.warning .toast-icon {
            color: rgb(251, 146, 60);
        }

        .toast.info .toast-icon {
            color: rgb(59, 130, 246);
        }

        .toast-content {
            flex: 1;
            font-size: 0.875rem;
            line-height: 1.5;
            color: rgb(31, 41, 55);
        }

        .toast-close {
            flex-shrink: 0;
            width: 20px;
            height: 20px;
            cursor: pointer;
            color: rgb(107, 114, 128);
            transition: color 0.2s;
        }

        .toast-close:hover {
            color: rgb(31, 41, 55);
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }

        .toast.slide-out {
            animation: slideOut 0.3s ease-in forwards;
        }

        /* Incoming Call Notification - Modern Design */
        .incoming-call-notification {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            width: 320px;
            z-index: 10001;
            display: none;
        }

        .incoming-call-notification.show {
            display: block;
            animation: slideInUp 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        /* First incoming call - positioned at bottom */
        #incomingCallNotification {
            bottom: 2rem;
        }

        /* Second incoming call - positioned above first call */
        #incomingCallNotification2 {
            bottom: calc(2rem + 310px);
        }

        /* Third incoming call - positioned above second call */
        #incomingCallNotification3 {
            bottom: calc(2rem + 620px);
        }

        @keyframes slideInUp {
            from {
                opacity: 0;
                transform: scale(0.9) translateY(20px);
            }
            to {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        .incoming-call-glow {
            position: absolute;
            inset: 0;
            background: linear-gradient(to right, #60a5fa, #818cf8);
            border-radius: 1rem;
            filter: blur(40px);
            opacity: 0.3;
            animation: pulse 2s ease-in-out infinite;
        }

        .incoming-call-card {
            position: relative;
            background: white;
            border-radius: 1rem;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            overflow: hidden;
            border: 1px solid #e5e7eb;
        }

        .incoming-call-header {
            background: linear-gradient(to bottom right, #334155, #1e293b, #0f172a);
            padding: 1.5rem;
            padding-bottom: 2rem;
            position: relative;
        }

        .incoming-call-icon-wrapper {
            width: 56px;
            height: 56px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 1rem;
            border: 1px solid rgba(255, 255, 255, 0.2);
            animation: iconPulse 2s ease-in-out infinite;
        }

        @keyframes iconPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .incoming-call-icon-wrapper svg {
            width: 28px;
            height: 28px;
            color: white;
        }

        .incoming-call-header-content {
            text-align: center;
        }

        .incoming-call-status {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }

        .incoming-call-status-dot {
            width: 8px;
            height: 8px;
            background: #ef4444;
            border-radius: 50%;
            animation: pulse 2s ease-in-out infinite;
        }

        .incoming-call-status-text {
            color: #f87171; /* red-400 */
            text-transform: uppercase;
            letter-spacing: 0.1em;
            font-size: 0.875rem; /* Increased from 0.75rem */
            font-weight: 600; /* Increased from 500 */
        }

        .incoming-call-number {
            color: white;
            font-size: 1.5rem;
            letter-spacing: 0.05em;
            font-weight: 500;
            margin-bottom: 0.25rem;
        }

        .incoming-call-label {
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.875rem;
        }

        .incoming-call-actions {
            padding: 1rem;
            background: #f9fafb;
            display: flex;
            gap: 0.75rem;
        }

        .incoming-call-btn {
            flex: 1;
            height: 48px;
            border: none;
            border-radius: 0.5rem;
            font-weight: 600;
            font-size: 0.9375rem;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .incoming-call-btn svg {
            width: 20px;
            height: 20px;
        }

        .incoming-call-btn.decline {
            background: white;
            color: #374151;
            border: 1px solid #d1d5db;
        }

        .incoming-call-btn.decline:hover {
            background: #f3f4f6;
            border-color: #9ca3af;
        }

        .incoming-call-btn.accept {
            background: #3b82f6;
            color: white;
            box-shadow: 0 10px 15px -3px rgba(59, 130, 246, 0.3);
        }

        .incoming-call-btn.accept:hover {
            background: #2563eb;
            box-shadow: 0 10px 15px -3px rgba(59, 130, 246, 0.4);
        }

        .incoming-call-border-top {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(to right, transparent, white, transparent);
            opacity: 0.5;
        }
    </style>
</head>
<body>
<!-- Toast Container -->
<div class="toast-container" id="toastContainer"></div>

<!-- Incoming Call Notification -->
<div class="incoming-call-notification" id="incomingCallNotification">
    <div class="incoming-call-glow"></div>
    <div class="incoming-call-card">
        <div class="incoming-call-header">
            <div class="incoming-call-icon-wrapper">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <polyline points="16 2 16 8 22 8"></polyline>
                    <line x1="22" y1="2" x2="16" y2="8"></line>
                    <path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>
                </svg>
            </div>
            <div class="incoming-call-header-content">
                <div class="incoming-call-status">
                    <div class="incoming-call-status-dot"></div>
                    <div class="incoming-call-status-text">Emergency Call</div>
                </div>
                <div class="incoming-call-number" id="incomingCallNumber">010-1234-5678</div>
                <div class="incoming-call-label">Incoming Emergency Report</div>
            </div>
        </div>
        <div class="incoming-call-actions">
            <button class="incoming-call-btn decline" onclick="declineCall(1)">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
                Decline
            </button>
            <button class="incoming-call-btn accept" onclick="acceptCall(1)">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <polyline points="20 6 9 17 4 12"></polyline>
                </svg>
                Accept
            </button>
        </div>
        <div class="incoming-call-border-top"></div>
    </div>
</div>

<!-- Second Incoming Call Notification -->
<div class="incoming-call-notification" id="incomingCallNotification2">
    <div class="incoming-call-glow"></div>
    <div class="incoming-call-card">
        <div class="incoming-call-header">
            <div class="incoming-call-icon-wrapper">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <polyline points="16 2 16 8 22 8"></polyline>
                    <line x1="22" y1="2" x2="16" y2="8"></line>
                    <path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>
                </svg>
            </div>
            <div class="incoming-call-header-content">
                <div class="incoming-call-status">
                    <div class="incoming-call-status-dot"></div>
                    <div class="incoming-call-status-text">Emergency Call</div>
                </div>
                <div class="incoming-call-number" id="incomingCallNumber2">010-1111-2222</div>
                <div class="incoming-call-label">Incoming Emergency Report</div>
            </div>
        </div>
        <div class="incoming-call-actions">
            <button class="incoming-call-btn decline" onclick="declineCall(2)">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
                Decline
            </button>
            <button class="incoming-call-btn accept" onclick="acceptCall(2)">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <polyline points="20 6 9 17 4 12"></polyline>
                </svg>
                Accept
            </button>
        </div>
        <div class="incoming-call-border-top"></div>
    </div>
</div>

<!-- Third Incoming Call Notification -->
<div class="incoming-call-notification" id="incomingCallNotification3">
    <div class="incoming-call-glow"></div>
    <div class="incoming-call-card">
        <div class="incoming-call-header">
            <div class="incoming-call-icon-wrapper">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <polyline points="16 2 16 8 22 8"></polyline>
                    <line x1="22" y1="2" x2="16" y2="8"></line>
                    <path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>
                </svg>
            </div>
            <div class="incoming-call-header-content">
                <div class="incoming-call-status">
                    <div class="incoming-call-status-dot"></div>
                    <div class="incoming-call-status-text">Emergency Call</div>
                </div>
                <div class="incoming-call-number" id="incomingCallNumber3">010-2222-3333</div>
                <div class="incoming-call-label">Incoming Emergency Report</div>
            </div>
        </div>
        <div class="incoming-call-actions">
            <button class="incoming-call-btn decline" onclick="declineCall(3)">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
                Decline
            </button>
            <button class="incoming-call-btn accept" onclick="acceptCall(3)">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <polyline points="20 6 9 17 4 12"></polyline>
                </svg>
                Accept
            </button>
        </div>
        <div class="incoming-call-border-top"></div>
    </div>
</div>

<!-- Hidden ringtone audio -->
<audio id="ringtoneAudio" style="display:none;">
    <source src="https://assets.mixkit.co/active_storage/sfx/2869/2869-preview.mp3" type="audio/mpeg">
</audio>

<!-- Header -->
<div class="header">
    <div class="header-container">
        <div class="header-left">
            <div class="header-icon">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"/></svg>
            </div>
            <h1 class="header-title">Report Reception â€” ECA103</h1>
        </div>

        <div class="header-right">
            <div class="header-user-info">
                <span class="header-user-name" id="headerUserName">Loading...</span>
                <span class="operator-status-dot available" id="operatorStatusDot"></span>
                <div class="header-user-popup">
                    <div class="panel-header">
                        <h3 class="panel-title">Operator Information</h3>
                    </div>
                    <div class="panel-body">
                        <div class="operator-info">
                            <div style="position: relative; width: 64px; height: 64px;">
                                <div class="operator-avatar-lg">
                                    <img id="headerOperatorAvatar" src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='64' height='64' viewBox='0 0 64 64'%3E%3Crect fill='%23e2e8f0' width='64' height='64'/%3E%3Ctext x='50%25' y='50%25' dominant-baseline='middle' text-anchor='middle' font-family='Arial' font-size='24' fill='%2364748b'%3E%3F%3C/text%3E%3C/svg%3E" alt="Operator">
                                </div>
                                <label for="headerPhotoUpload" style="position: absolute; bottom: -4px; right: -4px; background: #2563eb; color: white; border-radius: 50%; width: 28px; height: 28px; display: flex; align-items: center; justify-content: center; cursor: pointer; font-size: 16px; font-weight: bold; border: 3px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.2);">+</label>
                                <input type="file" id="headerPhotoUpload" accept="image/*" style="display: none;" onchange="handleHeaderPhotoUpload(event)">
                            </div>
                            <div class="operator-details">
                                <p id="headerOperatorName" class="operator-name">Unknown</p>
                                <p id="headerOperatorDept" class="operator-dept">N/A</p>
                                <p id="headerOperatorExp" class="operator-exp">N/A</p>
                            </div>
                        </div>
                        <div class="status-selector">
                            <span class="status-selector-label">Status</span>
                            <div class="status-options">
                                <div class="status-option on-call" onclick="changeOperatorStatus('on-call', true)">
                                    On Call
                                </div>
                                <div class="status-option available active" onclick="changeOperatorStatus('available', true)">
                                    Available
                                </div>
                                <div class="status-option away" onclick="changeOperatorStatus('away', true)">
                                    Away
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <button class="btn btn-icon" onclick="window.location.href='ecall-intro.html'">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/><polyline points="9 22 9 12 15 12 15 22"/></svg>
            </button>
            <button class="btn btn-icon">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"/><path d="M13.73 21a2 2 0 0 1-3.46 0"/></svg>
            </button>
            <button class="header-logout-btn" onclick="logout()">
                Log Out
            </button>
        </div>
    </div>
</div>

<!-- Main Content -->
<div class="main-content">
    <div class="grid-container">
        <!-- Left Sidebar -->
        <div class="left-sidebar">
            <!-- Caller Information Panel -->
            <div class="panel" style="margin-bottom: 1.25rem;">
                <div class="panel-header">
                    <h2 class="panel-title">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M12 16v-4"/><path d="M12 8h.01"/></svg>
                        Caller Information
                    </h2>
                </div>
                <div class="panel-body">
                    <div class="form-group">
                        <label class="form-label">Caller Number</label>
                        <input type="text" class="form-input" id="callerNumber" value="" placeholder="Waiting for call..." readonly>
                    </div>

                    <!-- Hidden: Caller Name -->
                    <!-- <div class="form-group">
                            <label class="form-label">Caller Name</label>
                            <input type="text" class="form-input" value="Minsu Kim">
                        </div> -->

                    <div class="form-group">
                        <label class="form-label">Incident Location</label>
                        <input type="text" class="form-input" id="incidentLocation" value="" placeholder="AI analyzing..." style="background: rgb(248, 250, 252);">
                    </div>

                    <div class="form-group">
                        <label class="form-label">Incident Type</label>
                        <select class="form-input" id="incidentType" onchange="updateChecklist(false)">
                            <option value="">AI analyzing...</option>
                            <option value="disaster">Disaster</option>
                            <option value="medical">Medical</option>
                            <option value="crime">Crime</option>
                            <option value="traffic">Traffic</option>
                            <option value="rescue">Rescue</option>
                            <option value="other">Other</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label class="form-label">
                                <span class="severity-label-wrapper">
                                    Severity Level
                                    <span class="severity-info-icon">
                                        ?
                                        <div class="severity-tooltip">
                                            <div class="severity-tooltip-section">
                                                <div class="severity-tooltip-title">AI Risk Assessment System</div>
                                                Severity levels are automatically assessed using GPT-4o mini through real-time transcript analysis.
                                            </div>
                                            <div class="severity-tooltip-section">
                                                <div class="severity-tooltip-title">Detection Methods</div>
                                                <ul class="severity-tooltip-list">
                                                    <li><strong>Keyword Patterns:</strong> Instant detection of critical terms (weapons, violence, injuries)</li>
                                                    <li><strong>AI Analysis:</strong> Contextual understanding every 60-80 characters of conversation</li>
                                                </ul>
                                            </div>
                                            <div class="severity-tooltip-section">
                                                <div class="severity-tooltip-title">Critical Triggers (Level 4-5)</div>
                                                Weapons, active threats, pursuit/chase scenarios, severe injuries, fire/explosions
                                            </div>
                                        </div>
                                    </span>
                                </span>
                        </label>
                        <select class="form-input" id="severityLevel">
                            <option value="">AI analyzing...</option>
                            <option value="1">Level 1 - Minimal</option>
                            <option value="2">Level 2 - Low</option>
                            <option value="3">Level 3 - Moderate</option>
                            <option value="4">Level 4 - High</option>
                            <option value="5">Level 5 - Critical</option>
                        </select>
                    </div>

                    <button class="btn btn-manual-update" onclick="updateIncidentInfo()">
                        <!--<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>-->
                        Manual Update
                    </button>

                    <div class="divider">
                        <button class="btn btn-checklist" id="viewChecklistBtn" onclick="showChecklistModal()">
                            <span class="checklist-pulse-dot" id="checklistPulseDot" style="display: none;"></span>
                            View Checklist
                            <span class="checklist-required-badge" id="checklistRequiredBadge" style="display: none;">REQUIRED</span>
                        </button>
                    </div>
                </div>
            </div>

            <!-- Timeline -->
            <div class="panel">
                <div class="panel-header">
                    <h2 class="panel-title">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
                        Timeline
                    </h2>
                </div>
                <div class="panel-body">
                    <div class="timeline-list">
                        <div class="timeline-item">
                            <span>Call Started</span>
                            <span class="timeline-time">--:--:--</span>
                        </div>
                        <div class="timeline-item">
                            <span>Location Confirmed</span>
                            <span class="timeline-time">--:--:--</span>
                        </div>
                        <div class="timeline-item">
                            <span>Dispatch Ordered</span>
                            <span class="timeline-time" id="dispatchOrderedTime">--:--:--</span>
                        </div>
                        <div class="timeline-item">
                            <span>Dispatch Arrived</span>
                            <span class="timeline-time" id="dispatchArrivedTime">--:--:--</span>
                        </div>
                        <div class="timeline-item">
                            <span>Call Ended</span>
                            <span class="timeline-time">--:--:--</span>
                        </div>
                        <div class="timeline-item">
                            <span>Elapsed Time</span>
                            <span class="timeline-time">00:00</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Center Panel -->
        <div class="center-panel">
            <div class="panel transcript-panel">
                <div class="panel-header" style="display: flex; justify-content: space-between; align-items: center;">
                    <h2 class="panel-title">Live Transcript</h2>
                    <span id="aiConfidence" style="position: absolute; left: 50%; transform: translateX(-50%); color: rgb(100, 116, 139); font-size: 0.875rem;">AI Confidence: 0%</span>
                    <div class="status-indicator">
                        <div class="status-dot"></div>
                        <span class="status-text">Standby</span>
                        <span class="status-time" id="callTimer">00:00</span>
                    </div>
                </div>

                <div class="transcript-messages" id="transcriptMessages">
                    <!-- Empty State - Waiting for Call -->
                    <div class="empty-state" id="emptyState">
                        <div class="empty-state-content">
                            <div class="empty-state-icon-wrapper">
                                <div class="empty-state-icon">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"/></svg>
                                </div>
                                <div class="empty-state-pulse"></div>
                            </div>
                            <h3 class="empty-state-title">Waiting for Incoming Call</h3>
                            <p class="empty-state-description">The system is ready to receive emergency calls.</p>
                            <div class="empty-state-badge">
                                <div class="empty-state-badge-dot"></div>
                                <span>Standby Mode</span>
                            </div>
                        </div>
                    </div>
                    <!-- Messages will be added here dynamically -->
                </div>

                <div class="transcript-footer" style="display: flex; justify-content: space-between; align-items: center;">
                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                        <div class="recording-dot"></div>
                        <span class="recording-text" id="recordingText">Voice Recognition active...</span>
                    </div>
                    <div style="display: flex; gap: 0.5rem;">
                        <button class="btn" id="playBtn" onclick="playAudio()" style="display: none;">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"/></svg>
                            Play
                        </button>
                        <button class="btn active" id="speakerBtn" onclick="toggleSpeaker()" style="display: none;">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M15.54 8.46a5 5 0 0 1 0 7.07"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14"/></svg>
                            Speaker
                        </button>
                        <button class="btn" onclick="showDispatchRequestModal()" style="flex: 1; background: #dc2626; color: white;">
                            <!--<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 0.5rem;"><path d="M9 11a3 3 0 1 0 6 0a3 3 0 0 0 -6 0"/><path d="M17.657 16.657l-4.243 4.243a2 2 0 0 1 -2.827 0l-4.244 -4.243a8 8 0 1 1 11.314 0z"/></svg>-->
                            Request Dispatch
                        </button>
                    </div>
                    <!-- Upload Audio File Button - Hidden for simulation mode
                        <button class="btn btn-primary" onclick="showUploadModal()" style="padding: 0.375rem 0.75rem; font-size: 0.8125rem; height: auto;">
                            <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/><path d="M12 18v-6"/><path d="m9 15 3-3 3 3"/></svg>
                            Upload Audio File
                        </button>
                        -->
                </div>
            </div>
        </div>

        <!-- Right Sidebar -->
        <div class="right-sidebar">
            <!-- Dispatch Status -->
            <div class="panel" style="margin-bottom: 1.25rem;">
                <div class="panel-header">
                    <h2 class="panel-title">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 11a3 3 0 1 0 6 0a3 3 0 0 0 -6 0"/><path d="M17.657 16.657l-4.243 4.243a2 2 0 0 1 -2.827 0l-4.244 -4.243a8 8 0 1 1 11.314 0z"/></svg>
                        Dispatch Status
                    </h2>
                </div>
                <div class="panel-body">
                    <div class="form-group">
                        <label class="form-label">Dispatch Status</label>
                        <select class="form-input" id="dispatchStatus">
                            <option value="">Not Dispatched</option>
                            <option value="requested">Dispatch Requested</option>
                            <option value="assigned">Team Assigned</option>
                            <option value="enroute">En Route</option>
                            <option value="arrived">On Scene</option>
                            <option value="completed">Completed</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Assigned Team</label>
                        <div style="display: flex; gap: 0.5rem;">
                            <input type="text" class="form-input" id="dispatchTeam" placeholder="No team assigned" readonly style="flex: 1;">
                            <button class="btn btn-icon" onclick="showTeamDetails()" title="View team details">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M12 16v-4"/><path d="M12 8h.01"/></svg>
                            </button>
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Vehicle Info</label>
                        <input type="text" class="form-input" id="dispatchVehicle" placeholder="No vehicle assigned" readonly>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Dispatched At</label>
                        <input type="text" class="form-input" id="dispatchTime" placeholder="--:--:--" readonly>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Expected Arrival</label>
                        <input type="text" class="form-input" id="dispatchETA" placeholder="--:--" readonly>
                    </div>
                    <div class="form-group" style="margin-bottom: 0;">
                        <label class="form-label">Current Location</label>
                        <div style="display: flex; gap: 0.5rem;">
                            <input type="text" class="form-input" id="dispatchLocation" placeholder="--" readonly style="flex: 1;">
                            <button class="btn btn-icon" onclick="refreshLocation()" title="Refresh location">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.2"/></svg>
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Response Manual -->
            <div class="panel">
                <div class="panel-header">
                    <h2 class="panel-title">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 19.5v-15A2.5 2.5 0 0 1 6.5 2H20v20H6.5a2.5 2.5 0 0 1 0-5H20"/></svg>
                        Response Manual
                    </h2>
                </div>
                <div class="panel-body">
                    <div class="form-group" style="margin-bottom: 1rem;">
                        <input type="text" class="form-input" id="manualSearch" placeholder="Search manuals..." oninput="searchManuals()">
                    </div>
                    <div class="manual-list" id="manualList">
                        <div class="manual-item">CPR Procedure</div>
                        <div class="manual-item">Bleeding Control</div>
                        <div class="manual-item">Shock Management</div>
                        <div class="manual-item">Airway Support</div>
                        <div class="manual-item">Burn Treatment</div>
                        <div class="manual-item">Choking Response</div>
                        <div class="manual-item">Stroke Recognition</div>
                        <div class="manual-item">Heart Attack Protocol</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Checklist Modal -->
<div id="checklistModal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <button class="close-btn" onclick="closeChecklistModal()">&times;</button>
            <h2 class="modal-title">Incident Type Checklist</h2>
            <p class="modal-desc" id="checklistDesc">Questions to assess the emergency situation.</p>
        </div>
        <div class="modal-body">
            <div class="checklist-items" id="checklistItems">
                <!-- Dynamically generated -->
            </div>
        </div>
        <div class="modal-footer">
            <button class="btn" onclick="closeChecklistModal()">Close</button>
            <button class="btn btn-primary" onclick="saveChecklist()">Save Checklist</button>
        </div>
    </div>
</div>

<!-- Response Manual Modal  -->
<div id="responseManualModal" class="modal">
    <div class="modal-content" style="max-width: 600px;">
        <div class="modal-header">
            <button class="close-btn" onclick="closeResponseManualModal()">&times;</button>
            <h2 class="modal-title" id="manualModalTitle">Response Manual Detail</h2>
            <p class="modal-desc" id="manualModalDesc">Detailed procedure for <span id="clickedManualName" style="font-weight: 600;">Manual Item</span>.</p>
        </div>
        <div class="modal-body">
            <div id="manualModalContent" style="line-height: 1.6; color: #334155; padding: 20px; text-align: center; background: #f8fafc; border-radius: 0.5rem;">
                <!-- ì´ê³³ì— ë‚´ìš©ì´ ë™ì ìœ¼ë¡œ ì‚½ìž…ë©ë‹ˆë‹¤. -->
            </div>
        </div>
        <div class="modal-footer">
            <button class="btn btn-primary" onclick="closeResponseManualModal()">Close</button>
        </div>
    </div>
</div>
<!-- End Response Manual Modal -->

<!-- Team Details Modal -->
<div id="teamDetailsModal" class="modal">
    <div class="modal-content" style="max-width: 400px;">
        <div class="modal-header">
            <button class="close-btn" onclick="closeTeamDetails()">&times;</button>
            <h2 class="modal-title">Team Details</h2>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label class="form-label">Team Number</label>
                <input type="text" class="form-input" id="teamNumber" value="Fire Unit 23" readonly>
            </div>
            <div class="form-group">
                <label class="form-label">Team Name</label>
                <input type="text" class="form-input" id="teamName" value="Alpha Squad" readonly>
            </div>
            <div class="form-group">
                <label class="form-label">Team Leader</label>
                <input type="text" class="form-input" id="teamLeader" value="John Smith (555-1234)" readonly>
            </div>
            <div class="form-group" style="margin-bottom: 0;">
                <label class="form-label">Deputy Leader</label>
                <input type="text" class="form-input" id="teamDeputy" value="Jane Doe (555-5678)" readonly>
            </div>
        </div>
        <div class="modal-footer">
            <button class="btn" onclick="closeTeamDetails()">Close</button>
        </div>
    </div>
</div>

<!-- Dispatch Request Modal -->
<div id="dispatchRequestModal" class="modal">
    <div class="modal-content" style="max-width: 700px; max-height: 86vh;">
        <div class="modal-header">
            <button class="close-btn" onclick="closeDispatchRequestModal()">&times;</button>
            <h2 class="modal-title">Select Dispatch Team</h2>
            <p class="modal-desc">Choose a rescue team to dispatch to the emergency scene</p>
        </div>
        <div class="modal-body" style="max-height: none; overflow-y: auto;">
            <div id="teamSelectionList">
                <!-- Teams will be dynamically loaded here -->
            </div>
        </div>
        <div class="modal-footer">
            <button class="btn" onclick="closeDispatchRequestModal()">Cancel</button>
            <button class="btn btn-primary" onclick="confirmDispatchRequest()">Request Dispatch</button>
        </div>
    </div>
</div>

<!-- Upload Modal -->
<div id="uploadModal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <button class="close-btn" onclick="closeUploadModal()">&times;</button>
            <h2 class="modal-title">Upload Audio File</h2>
            <p class="modal-desc">Upload an MP3 audio file for transcription and analysis.</p>
        </div>
        <div class="modal-body">
            <div class="upload-area" onclick="document.getElementById('audioFile').click()">
                <svg class="upload-icon" xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/><path d="M12 18v-6"/><path d="m9 15 3-3 3 3"/></svg>
                <div class="upload-text">Click to upload or drag and drop</div>
                <div class="upload-subtext">MP3 files only</div>
            </div>
            <input type="file" id="audioFile" class="file-input" accept=".mp3,audio/mp3,audio/mpeg" onchange="handleFileSelect(event)">
            <div id="uploadedFileInfo"></div>
        </div>
        <div class="modal-footer">
            <button class="btn" onclick="closeUploadModal()">Cancel</button>
            <button class="btn btn-primary" id="uploadBtn" disabled onclick="uploadFile()">Upload</button>
        </div>
    </div>
</div>

<script>
    // Load Kakao Maps SDK dynamically
    let kakaoMapsLoaded = false;
    let kakaoMapsLoadPromise = null;

    kakaoMapsLoadPromise = (async function loadKakaoMapsSDK() {
        try {
            // Hardcoded Kakao Maps API key
            const apiKey = '0712e993ab0b7b9bcdd4999da4bd71ae';

            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.type = 'text/javascript';
                script.src = `https://dapi.kakao.com/v2/maps/sdk.js?appkey=${apiKey}&libraries=services&autoload=false`;
                script.onload = () => {
                    console.log('Kakao Maps SDK script loaded, initializing...');
                    // Use kakao.maps.load() to manually initialize
                    if (typeof kakao !== 'undefined' && kakao.maps) {
                        kakao.maps.load(() => {
                            kakaoMapsLoaded = true;
                            console.log('Kakao Maps SDK initialized successfully');
                            resolve(true);
                        });
                    } else {
                        console.error('kakao.maps not available');
                        reject(new Error('kakao.maps not available'));
                    }
                };
                script.onerror = () => {
                    console.error('Failed to load Kakao Maps SDK script');
                    reject(new Error('Failed to load Kakao Maps SDK'));
                };
                document.head.appendChild(script);
            });
        } catch (error) {
            console.error('Error loading Kakao API key:', error);
            return Promise.reject(error);
        }
    })();

    const manualContents = {
        // 1. CPR Procedure
        "CPR Procedure": {
            title: "CPR (Cardiopulmonary Resuscitation) Detailed Procedure",
            content: `
    <h4 style="color: #1e293b; border-bottom: 2px solid #e2e8f0; padding-bottom: 5px; margin-bottom: 15px;">Adult CPR Detailed Procedure</h4>

    <div style="background: #f8fafc; padding: 15px; border-radius: 8px; margin-bottom: 20px; border: 1px solid #e2e8f0;">
        <p style="font-weight: 600; color: #1e293b; margin-bottom: 5px;">1. Check Patient Response and Breathing (CAB)</p>
        <ul style="list-style-type: disc; margin-left: 20px; color: #1e293b; line-height: 1.8;">
            <li>Circulation : Check for response by tapping the patient's shoulder and verify normal breathing within 10 seconds.</li>
            <li>Breathing : If the patient is unconscious and not breathing normally, begin CPR.</li>
        </ul>
    </div>

    <div style="background: #f8fafc; padding: 15px; border-radius: 8px; margin-bottom: 20px; border: 1px solid #e2e8f0;">
        <p style="font-weight: 600; color: #1e293b; margin-bottom: 5px;">2. Chest Compressions (Compression: 30 times)</p>
        <ul style="list-style-type: disc; margin-left: 20px; color: #1e293b; line-height: 1.8;">
            <li>Position : Place the heel of one hand in the center of the chest (between the nipples).</li>
            <li>Stance : Interlock fingers, straighten elbows, and compress vertically.</li>
            <li>Rate and Depth: Compress at a rate of 100-120 times per minute, to a depth of at least 5cm for adults, hard and fast.</li>
        </ul>
    </div>

    <div style="background: #f8fafc; padding: 15px; border-radius: 8px; border: 1px solid #e2e8f0;">
        <p style="font-weight: 600; color: #1e293b; margin-bottom: 5px;">3. Airway Opening and Rescue Breaths (Breathing: 2 breaths)</p>
        <ul style="list-style-type: disc; margin-left: 20px; color: #1e293b; line-height: 1.8;">
            <li>Airway Opening : Tilt the head back and lift the chin to open the airway.</li>
            <li>Breaths : Perform 2 rescue breaths, each lasting 1 second.</li>
            <li>Circulation : Repeat cycles of 30 compressions and 2 breaths (30:2).</li>
            <li>Note : If rescue breathing is difficult, perform 'Hands-Only CPR' (continuous chest compressions).</li>
        </ul>
    </div>
`
        },

        // 2. Bleeding Control
        "Bleeding Control": {
            title: "Bleeding (Hemorrhage) Control Procedure",
            content: `
            <h4 style="color: #1e293b; border-bottom: 2px solid #e2e8f0; padding-bottom: 5px; margin-bottom: 15px;">Hemorrhage Control Guide in Severe Bleeding Situations</h4>

            <div style="background: #f8fafc; padding: 15px; border-radius: 8px; margin-bottom: 20px; border: 1px solid #e2e8f0;">
                <p style="font-weight: 600; color: #1e293b; margin-bottom: 5px;">1. Direct Pressure</p>
                <ul style="list-style-type: disc; margin-left: 20px; color: #1e293b; line-height: 1.8;">
                    <li>Bleeding Area : Instruct the caller to apply strong direct pressure to the wound using a clean cloth or gauze.</li>
                    <li>Maintain Pressure : Maintain pressure until the bleeding stops or emergency medical services arrive.</li>
                </ul>
            </div>

            <div style="background: #f8fafc; padding: 15px; border-radius: 8px; border: 1px solid #e2e8f0;">
                <p style="font-weight: 600; color: #1e293b; margin-bottom: 5px;">2. Wound Elevation</p>
                <ul style="list-style-type: disc; margin-left: 20px; color: #1e293b; line-height: 1.8;">
                    <li>Caution : Instruct the caller to raise the bleeding area above the heart level, unless a fracture is suspected.</li>
                </ul>
            </div>
`
        },

        // 3. Shock Management
        "Shock Management": {
            title: "Shock (Circulatory Failure) Management Manual",
            content: `
            <h4 style="color: #1e293b; border-bottom: 2px solid #e2e8f0; padding-bottom: 5px; margin-bottom: 15px;">Stabilization Guide for Patients in Shock</h4>

            <div style="background: #f8fafc; padding: 15px; border-radius: 8px; margin-bottom: 20px; border: 1px solid #e2e8f0;">
                <p style="font-weight: 600; color: #1e293b; margin-bottom: 5px;">1. Patient Positioning and Posture</p>
                <ul style="list-style-type: disc; margin-left: 20px; color: #1e293b; line-height: 1.8;">
                    <li>Posture : Lay the patient on their back and elevate the legs by about 12 inches (approx. 30cm) (except if head/spinal injury is suspected).</li>
                    <li>Breathing : Loosen any tight clothing to ease the patient's breathing.</li>
                </ul>
            </div>

            <div style="background: #f8fafc; padding: 15px; border-radius: 8px; border: 1px solid #e2e8f0;">
                <p style="font-weight: 600; color: #1e293b; margin-bottom: 5px;">2. Maintaining Body Temperature and Calmness</p>
                <ul style="list-style-type: disc; margin-left: 20px; color: #1e293b; line-height: 1.8;">
                    <li>Body Temperature : Instruct the caller to cover the patient with a blanket or coat to maintain body temperature.</li>
                    <li*Calmness : Talk to the patient and maintain a calm demeanor to reduce anxiety.</li>
                </ul>
            </div>
`
        },

        // 4. Airway Support
        "Airway Support": {
            title: "Airway Opening and Respiratory Support Procedure",
            content: `
            <h4 style="color: #1e293b; border-bottom: 2px solid #e2e8f0; padding-bottom: 5px; margin-bottom: 15px;">Response to Breathing Difficulty and Airway Obstruction</h4>

            <div style="background: #f8fafc; padding: 15px; border-radius: 8px; margin-bottom: 20px; border: 1px solid #e2e8f0;">
                <p style="font-weight: 600; color: #1e293b; margin-bottom: 5px;">1. Airway Opening (Head-Tilt/Chin-Lift)</p>
                <ul style="list-style-type: disc; margin-left: 20px; color: #1e293b; line-height: 1.8;">
                    <li>Maneuver : Instruct the caller to tilt the patient's head back with one hand and lift the chin with the other to open the airway.</li>
                    <li>Caution : If a neck injury is suspected, use only the Jaw Thrust maneuver.</li>
                </ul>
            </div>

            <div style="background: #f8fafc; padding: 15px; border-radius: 8px; border: 1px solid #e2e8f0;">
                <p style="font-weight: 600; color: #1e293b; margin-bottom: 5px;">2. Foreign Object Removal (Choking)</p>
                <ul style="list-style-type: disc; margin-left: 20px; color: #1e293b; line-height: 1.8;">
                    <li>Adult/Child : Instruct the caller to perform the Heimlich maneuver (stand behind the patient and thrust sharply inward and upward between the navel and sternum).</li>
                    <li>Infant : Instruct the caller to alternate 5 back blows and 5 chest thrusts.</li>
                </ul>
            </div>
`
        },

        // 5. Burn Treatment
        "Burn Treatment": {
            title: "Burn Injury Treatment Procedure",
            content: `
            <h4 style="color: #1e293b; border-bottom: 2px solid #e2e8f0; padding-bottom: 5px; margin-bottom: 15px;">Emergency Treatment Guide by Burn Type</h4>

            <div style="background: #f8fafc; padding: 15px; border-radius: 8px; margin-bottom: 20px; border: 1px solid #e2e8f0;">
                <p style="font-weight: 600; color: #1e293b; margin-bottom: 5px;">1. Cool the Burn Area</p>
                <ul style="list-style-type: disc; margin-left: 20px; color: #1e293b; line-height: 1.8;">
                    <li>Method : Instruct the caller to cool the burn area with running cool water for 10 to 20 minutes. (Do not use ice water)</li>
                    <li>Removal : Remove clothing and jewelry from the burn area before swelling occurs.</li>
                </ul>
            </div>

            <div style="background: #f8fafc; padding: 15px; border-radius: 8px; border: 1px solid #e2e8f0;">
                <p style="font-weight: 600; color: #1e293b; margin-bottom: 5px;">2. Additional Measures</p>
                <ul style="list-style-type: disc; margin-left: 20px; color: #1e293b; line-height: 1.8;">
                    <li>Blisters : Instruct the caller not to break any blisters.</li>
                    <li>Protection : Cover the burn area with a clean gauze or cloth after cooling to prevent infection.</li>
                </ul>
            </div>
`
        },

        // 6. Choking Response
        "Choking Response": {
            title: "Choking Situation Response Procedure",
            content: `
            <h4 style="color: #1e293b; border-bottom: 2px solid #e2e8f0; padding-bottom: 5px; margin-bottom: 15px;">Emergency Response to Airway Obstruction</h4>

            <div style="background: #f8fafc; padding: 15px; border-radius: 8px; margin-bottom: 20px; border: 1px solid #e2e8f0;">
                <p style="font-weight: 600; color: #1e293b; margin-bottom: 5px;">1. Adult/Child (Heimlich Maneuver)</p>
                <ul style="list-style-type: disc; margin-left: 20px; color: #1e293b; line-height: 1.8;">
                    <li>Action : Stand behind the patient, wrap arms around, and thrust sharply inward and upward between the navel and sternum.</li>
                    <li>Repeat : Repeat until the foreign object is dislodged.</li>
                </ul>
            </div>

            <div style="background: #f8fafc; padding: 15px; border-radius: 8px; border: 1px solid #e2e8f0;">
                <p style="font-weight: 600; color: #1e293b; margin-bottom: 5px;">2. Infant (Under 1 year) Choking</p>
                <ul style="list-style-type: disc; margin-left: 20px; color: #1e293b; line-height: 1.8;">
                    <li>Action : Lay the infant face down on one forearm and deliver 5 back blows, followed by 5 chest thrusts.</li>
                </ul>
            </div>
`
        },

        // 7. Stroke Recognition
        "Stroke Recognition": {
            title: "Stroke Recognition and Response",
            content: `
            <h4 style="color: #1e293b; border-bottom: 2px solid #e2e8f0; padding-bottom: 5px; margin-bottom: 15px;">Stroke FAST Recognition Method</h4>

            <div style="background: #f8fafc; padding: 15px; border-radius: 8px; margin-bottom: 20px; border: 1px solid #e2e8f0;">
                <p style="font-weight: 600; color: #1e293b; margin-bottom: 5px;">F.A.S.T. Check Steps</p>
                <ul style="list-style-type: disc; margin-left: 20px; color: #1e293b; line-height: 1.8;">
                    <li>F(Face) : Check if one side of the face droops when asked to smile.</li>
                    <li>A(Arms) : Check if one arm drifts downward when asked to raise both arms.</li>
                    <li>S(Speech) : Check if speech is slurred when asked to repeat a simple phrase.</li>
                    <li>T(Time) : Note the time the symptoms started and call emergency services immediately.</li>
                </ul>
            </div>

            <div style="background: #f8fafc; padding: 15px; border-radius: 8px; border: 1px solid #e2e8f0;">
                <p style="font-weight: 600; color: #1e293b; margin-bottom: 5px;">Response Protocol</p>
                <ul style="list-style-type: disc; margin-left: 20px; color: #1e293b; line-height: 1.8;">
                    <li>Immediate Call : Call emergency services immediately, stating "Suspected Stroke" and providing the symptom onset time.</li>
                    <li>Stabilization : Keep the patient comfortable, lying down, and do not give them food or water.</li>
                </ul>
            </div>
`
        },

        // 8. Heart Attack Protocol
        "Heart Attack Protocol": {
            title: "Heart Attack/Chest Pain Response Protocol",
            content: `
            <h4 style="color: #1e293b; border-bottom: 2px solid #e2e8f0; padding-bottom: 5px; margin-bottom: 15px;">Guidance for Heart Attack and Severe Chest Pain</h4>

            <div style="background: #f8fafc; padding: 15px; border-radius: 8px; margin-bottom: 20px; border: 1px solid #e2e8f0;">
                <p style="font-weight: 600; color: #1e293b; margin-bottom: 5px;">1. Patient Status Check</p>
                <ul style="list-style-type: disc; margin-left: 20px; color: #1e293b; line-height: 1.8;">
                    <li>Symptoms : Verify if the severe pressure or pain in the center of the chest is spreading to the arm, neck, or jaw.</li>
                    <li>Breathing/Consciousness : Quickly check breathing status and level of consciousness. (Prepare for CPR if unconscious)</li>
                </ul>
            </div>

            <div style="background: #f8fafc; padding: 15px; border-radius: 8px; border: 1px solid #e2e8f0;">
                <p style="font-weight: 600; color: #1e293b; margin-bottom: 5px;">2. Emergency Action</p>
                <ul style="list-style-type: disc; margin-left: 20px; color: #1e293b; line-height: 1.8;">
                    <li>Posture : Instruct the patient to maintain the most comfortable posture (usually sitting up).</li>
                    <li>Calmness : Reduce patient anxiety and tell them to rest quietly.</li>
                    <li>Medication : If there is no contraindication, the patient may be instructed to chew and swallow an aspirin (to be determined by the counselor).</li>
                </ul>
            </div>
`
        }
    };

    // Toast notification system
    function showToast(message, type = 'info', duration = 4000) {
        const container = document.getElementById('toastContainer');
        const toast = document.createElement('div');
        toast.className = `toast ${type}`;

        // Icon based on type
        let icon = '';
        switch(type) {
            case 'success':
                icon = '<svg class="toast-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg>';
                break;
            case 'error':
                icon = '<svg class="toast-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><line x1="15" y1="9" x2="9" y2="15"/><line x1="9" y1="9" x2="15" y2="15"/></svg>';
                break;
            case 'warning':
                icon = '<svg class="toast-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m21.73 18-8-14a2 2 0 0 0-3.46 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"/><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg>';
                break;
            case 'info':
            default:
                icon = '<svg class="toast-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M12 16v-4"/><path d="M12 8h.01"/></svg>';
        }

        toast.innerHTML = `
                ${icon}
                <div class="toast-content">${message}</div>
                <svg class="toast-close" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
            `;

        // Add close button functionality
        const closeBtn = toast.querySelector('.toast-close');
        closeBtn.addEventListener('click', () => {
            removeToast(toast);
        });

        container.appendChild(toast);

        // Auto remove after duration
        if (duration > 0) {
            setTimeout(() => {
                removeToast(toast);
            }, duration);
        }
    }

    function removeToast(toast) {
        toast.classList.add('slide-out');
        setTimeout(() => {
            toast.remove();
        }, 300);
    }

    // Load operator information from session
    document.addEventListener('DOMContentLoaded', function() {
        const user = JSON.parse(sessionStorage.getItem('user'));

        // Load operator status
        loadOperatorStatus();

        if (user) {
            // Update operator name
            const operatorNameEl = document.getElementById('operatorName');
            if (operatorNameEl) {
                operatorNameEl.textContent = user.name || 'Unknown';
            }

            // Update operator department
            const operatorDeptEl = document.getElementById('operatorDept');
            if (operatorDeptEl) {
                operatorDeptEl.textContent = user.organizationName || 'N/A';
            }

            // Calculate years of experience from join_date
            const operatorExpEl = document.getElementById('operatorExp');
            if (operatorExpEl && user.joinDate) {
                // Parse date string (yyyy-MM-dd) without timezone issues
                const joinDateStr = user.joinDate.split('T')[0]; // Remove time part if exists
                const [year, month, day] = joinDateStr.split('-').map(Number);
                const joinDate = new Date(year, month - 1, day); // month is 0-indexed

                const today = new Date();
                const yearsDiff = today.getFullYear() - joinDate.getFullYear();
                const monthsDiff = today.getMonth() - joinDate.getMonth();
                const daysDiff = today.getDate() - joinDate.getDate();

                // Adjust if birthday hasn't occurred this year
                let diffYears = yearsDiff;
                if (monthsDiff < 0 || (monthsDiff === 0 && daysDiff < 0)) {
                    diffYears--;
                }

                operatorExpEl.textContent = `${diffYears} year${diffYears !== 1 ? 's' : ''} exp.`;
            }

            // Update avatar - show photo if available, otherwise show initials
            const operatorAvatarEl = document.getElementById('operatorAvatar');
            if (operatorAvatarEl) {
                if (user.photoUrl) {
                    operatorAvatarEl.src = user.photoUrl;
                } else if (user.name) {
                    const initials = user.name.split(' ').map(n => n[0]).join('').toUpperCase().substring(0, 2);
                    const avatarSvg = `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='64' height='64' viewBox='0 0 64 64'%3E%3Crect fill='%23e2e8f0' width='64' height='64'/%3E%3Ctext x='50%25' y='50%25' dominant-baseline='middle' text-anchor='middle' font-family='Arial' font-size='24' fill='%2364748b'%3E${initials}%3C/text%3E%3C/svg%3E`;
                    operatorAvatarEl.src = avatarSvg;
                }
            }

            // Update header user info
            const headerUserNameEl = document.getElementById('headerUserName');
            if (headerUserNameEl && user.name) {
                if (user.organizationName) {
                    headerUserNameEl.textContent = `${user.name} (${user.organizationName})`;
                } else {
                    headerUserNameEl.textContent = user.name;
                }
            }

            // Update header operator info in popup
            const headerOperatorNameEl = document.getElementById('headerOperatorName');
            if (headerOperatorNameEl) {
                headerOperatorNameEl.textContent = user.name || 'Unknown';
            }

            const headerOperatorDeptEl = document.getElementById('headerOperatorDept');
            if (headerOperatorDeptEl) {
                headerOperatorDeptEl.textContent = user.organizationName || 'N/A';
            }

            const headerOperatorExpEl = document.getElementById('headerOperatorExp');
            if (headerOperatorExpEl && user.joinDate) {
                const joinDateStr = user.joinDate.split('T')[0];
                const [year, month, day] = joinDateStr.split('-').map(Number);
                const joinDate = new Date(year, month - 1, day);

                const today = new Date();
                const yearsDiff = today.getFullYear() - joinDate.getFullYear();
                const monthsDiff = today.getMonth() - joinDate.getMonth();
                const daysDiff = today.getDate() - joinDate.getDate();

                let diffYears = yearsDiff;
                if (monthsDiff < 0 || (monthsDiff === 0 && daysDiff < 0)) {
                    diffYears--;
                }

                headerOperatorExpEl.textContent = `${diffYears} year${diffYears !== 1 ? 's' : ''} exp.`;
            }

            // Update header avatar
            const headerOperatorAvatarEl = document.getElementById('headerOperatorAvatar');
            if (headerOperatorAvatarEl) {
                if (user.photoUrl) {
                    headerOperatorAvatarEl.src = user.photoUrl;
                } else if (user.name) {
                    const initials = user.name.split(' ').map(n => n[0]).join('').toUpperCase().substring(0, 2);
                    const avatarSvg = `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='48' height='48' viewBox='0 0 48 48'%3E%3Crect fill='%23e2e8f0' width='48' height='48'/%3E%3Ctext x='50%25' y='50%25' dominant-baseline='middle' text-anchor='middle' font-family='Arial' font-size='18' fill='%2364748b'%3E${initials}%3C/text%3E%3C/svg%3E`;
                    headerOperatorAvatarEl.src = avatarSvg;
                }
            }
        }

        // Setup popup hover control with JavaScript
        const headerUserInfo = document.querySelector('.header-user-info');
        const headerUserPopup = document.querySelector('.header-user-popup');

        let popupTimeout;

        if (headerUserInfo && headerUserPopup) {
            // Show popup on mouseenter
            headerUserInfo.addEventListener('mouseenter', () => {
                clearTimeout(popupTimeout);
                headerUserPopup.classList.add('show');
            });

            // Keep popup visible when mouse is over it
            headerUserPopup.addEventListener('mouseenter', () => {
                clearTimeout(popupTimeout);
                headerUserPopup.classList.add('show');
            });

            // Hide popup with delay when mouse leaves
            headerUserInfo.addEventListener('mouseleave', () => {
                popupTimeout = setTimeout(() => {
                    headerUserPopup.classList.remove('show');
                }, 200);
            });

            headerUserPopup.addEventListener('mouseleave', () => {
                popupTimeout = setTimeout(() => {
                    headerUserPopup.classList.remove('show');
                }, 200);
            });
        }
        // Response Manual List ë‚´ì˜ ëª¨ë“  í•­ëª©ì— í´ë¦­ ì´ë²¤íŠ¸ ì—°ê²° (ìƒˆë¡œ ì¶”ê°€)
        const manualItems = document.querySelectorAll('#manualList .manual-item');
        manualItems.forEach(item => {
            item.style.cursor = 'pointer'; // í´ë¦­ ê°€ëŠ¥ ì‹œê°í™”

            // í´ë¦­ ì‹œ í•­ëª© ì´ë¦„ì„ ì¸ìˆ˜ë¡œ ë„˜ê²¨ íŒì—…ì„ ì—½ë‹ˆë‹¤.
            item.addEventListener('click', (event) => {
                const manualName = event.target.textContent.trim(); // í´ë¦­ëœ í•­ëª© ì´ë¦„ ì¶”ì¶œ
                showResponseManualModal(manualName); // íŒì—…ë§Œ ë„ìš°ëŠ” í•¨ìˆ˜ í˜¸ì¶œ
            });
        });
    });

    // Handle header photo upload
    function changeOperatorStatus(status, isManual = false) {
        // Update status dot
        const statusDot = document.getElementById('operatorStatusDot');
        if (statusDot) {
            statusDot.className = `operator-status-dot ${status}`;
        }

        // Update active status option
        const statusOptions = document.querySelectorAll('.status-option');
        statusOptions.forEach(option => {
            option.classList.remove('active');
            if (option.classList.contains(status)) {
                option.classList.add('active');
            }
        });

        // Save status to localStorage
        localStorage.setItem('operatorStatus', status);

        // Track if status was manually set to 'away'
        if (isManual && status === 'away') {
            localStorage.setItem('operatorStatusManualAway', 'true');
        } else if (isManual && status !== 'away') {
            localStorage.removeItem('operatorStatusManualAway');
        }

        console.log('Operator status changed to:', status, isManual ? '(manual)' : '(auto)');
    }

    // Load operator status on page load
    function loadOperatorStatus() {
        const savedStatus = localStorage.getItem('operatorStatus') || 'available';
        changeOperatorStatus(savedStatus);
    }

    // Auto-change status when call starts
    function onCallStart() {
        // Only change if not manually set to away
        const isManualAway = localStorage.getItem('operatorStatusManualAway') === 'true';
        if (!isManualAway) {
            changeOperatorStatus('on-call', false);
        }
    }

    // Auto-change status when call ends
    function onCallEnd() {
        // Only change if not manually set to away
        const isManualAway = localStorage.getItem('operatorStatusManualAway') === 'true';
        if (!isManualAway) {
            changeOperatorStatus('available', false);
        }
    }

    async function handleHeaderPhotoUpload(event) {
        const file = event.target.files[0];
        if (!file) return;

        const user = JSON.parse(sessionStorage.getItem('user'));
        if (!user || !user.id) {
            showToast('User not logged in', 'warning');
            return;
        }

        const formData = new FormData();
        formData.append('photo', file);
        formData.append('operatorId', user.id);

        try {
            const response = await fetch('/api/auth/upload-photo', {
                method: 'POST',
                body: formData
            });

            const result = await response.json();

            if (result.success) {
                // Update both header and sidebar avatars
                const headerOperatorAvatarEl = document.getElementById('headerOperatorAvatar');
                if (headerOperatorAvatarEl) {
                    headerOperatorAvatarEl.src = result.fileUrl;
                }

                const operatorAvatarEl = document.getElementById('operatorAvatar');
                if (operatorAvatarEl) {
                    operatorAvatarEl.src = result.fileUrl;
                }

                // Update session storage
                user.photoUrl = result.fileUrl;
                sessionStorage.setItem('user', JSON.stringify(user));

                showToast('Photo uploaded successfully!', 'success');
            } else {
                showToast('Upload failed: ' + result.message, 'error');
            }
        } catch (error) {
            console.error('Error uploading photo:', error);
            showToast('Upload failed. Please try again.', 'error');
        }
    }

    // Handle photo upload
    async function handlePhotoUpload(event) {
        const file = event.target.files[0];
        if (!file) return;

        const user = JSON.parse(sessionStorage.getItem('user'));
        if (!user || !user.id) {
            showToast('User not logged in', 'warning');
            return;
        }

        const formData = new FormData();
        formData.append('file', file);
        formData.append('operatorId', user.id);

        try {
            const response = await fetch('/api/auth/upload-photo', {
                method: 'POST',
                body: formData
            });

            const result = await response.json();

            if (result.success) {
                // Update avatar immediately
                const operatorAvatarEl = document.getElementById('operatorAvatar');
                if (operatorAvatarEl) {
                    operatorAvatarEl.src = result.fileUrl;
                }

                // Update session storage
                user.photoUrl = result.fileUrl;
                sessionStorage.setItem('user', JSON.stringify(user));

                showToast('Photo uploaded successfully!', 'success');
            } else {
                showToast('Upload failed: ' + result.message, 'error');
            }
        } catch (error) {
            console.error('Error uploading photo:', error);
            showToast('Upload failed. Please try again.', 'error');
        }
    }

    // Checklist data
    const checklistData = {
        disaster: [
            "Are you at the location now?",
            "Are you in a safe place?",
            "Is there a fire or building collapse?",
            "Is the fire or damage spreading?",
            "Are you injured?",
            "Is anyone trapped or in immediate danger?",
            "Do you smell gas or see hazardous materials?"
        ],
        medical: [
            "Are you with the patient now?",
            "Is the patient awake?",
            "Is the patient breathing normally?",
            "Is the patient bleeding badly?",
            "Is the patient having chest pain?",
            "Did the patient collapse suddenly?",
            "Does the patient have any known medical conditions?",
            "What is the patient's age and sex?"
        ],
        crime: [
            "Are you safe right now?",
            "Is the crime happening now?",
            "Does the suspect have a weapon?",
            "Is the suspect still at the location?",
            "Is anyone injured?",
            "Where is the suspect now? Did they flee?",
            "How many suspects are there?",
            "Are there other victims? Are they conscious or bleeding?"
        ],
        traffic: [
            "Are you at the accident scene?",
            "Is anyone injured?",
            "(If injured) Is the patient awake and breathing?",
            "Is anyone trapped in a vehicle?",
            "Is any vehicle on fire?",
            "Is any vehicle leaking fuel?",
            "Does this involve more than one vehicle?",
            "Is the accident blocking traffic?"
        ],
        rescue: [
            "Is someone trapped, isolated, or in the water?",
            "Is the person conscious?",
            "Is the person injured?",
            "Are you able to talk to them?",
            "Is the situation getting worse?",
            "Is there only one person needing rescue?",
            "If no, how many people?",
            "Are there any obstacles blocking the access route?"
        ],
        other: [
            "Is this a life-threatening or urgent situation?",
            "Is this related to a crime, fire, or medical emergency?",
            "Is this a simple noise complaint or civil issue?",
            "Do you just need advice or information?",
            "Have you reported this issue before?",
            "Is an officer (or firefighter) response necessary?",
            "Is there a risk of re-occurrence or conflict?",
            "When did this happen?"
        ]
    };

    const checklistDescriptions = {
        disaster: "Facility/environment risk: fire, explosion, smoke, natural disaster.",
        medical: "Immediate medical care required: cardiac arrest, unconscious, severe bleeding.",
        crime: "Violent offenses threatening life/body.",
        traffic: "Vehicle-related incidents.",
        rescue: "Physical rescue required: trapped, buried, water, high-rise isolation.",
        other: "Non-urgent, misreport, general inquiries."
    };

    let currentChecklist = {};
    let selectedFile = null;
    let audioElement = null; // For audio playback
    let transcriptSegments = [];
    let isPlaying = false;
    let callStartTime = null;
    let timerInterval = null;
    let displayedSegmentIndexes = new Set(); // Track which segments have been displayed
    let accumulatedTranscript = ''; // Accumulated transcript for AI analysis
    let aiLocationExtractionInProgress = false; // Prevent concurrent AI calls
    let aiIncidentClassificationInProgress = false; // Prevent concurrent AI classification calls
    let currentEmergencyId = null; // Store emergency ID for checklist saving
    let currentCallerId = null; // Store caller ID for checklist saving
    let detectedLanguage = null; // Store detected language from upload
    let mediaAssetId = null; // Store media asset ID from upload
    let callEndTime = null; // Store call end time for database
    let checklistSaved = false; // Track if checklist has been saved

    // Timer
    let seconds = 0;
    function startTimer() {
        if (timerInterval) return; // Already running
        // Update timer based on audio currentTime
        timerInterval = setInterval(() => {
            if (audioElement) {
                seconds = Math.floor(audioElement.currentTime);
            } else {
                seconds++;
            }
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            const timeStr = `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
            document.getElementById('callTimer').textContent = timeStr;

            // Update elapsed time in timeline (real-time during call)
            const elapsedTimeEl = document.querySelector('.timeline-list .timeline-item:nth-child(6) .timeline-time');
            if (elapsedTimeEl) {
                elapsedTimeEl.textContent = timeStr;
            }
        }, 100); // Update more frequently for smoother display
    }

    function stopTimer() {
        if (timerInterval) {
            clearInterval(timerInterval);
            timerInterval = null;
        }
    }

    // Checklist functions
    function showChecklistModal(autoOpen = false) {
        // Don't open if checklist is already saved
        if (checklistSaved) {
            return;
        }

        const type = document.getElementById('incidentType').value;
        updateChecklist(autoOpen);
        document.getElementById('checklistModal').style.display = 'block';

        // Temporarily hide pulse/required badge while modal is open
        const pulseDot = document.getElementById('checklistPulseDot');
        const requiredBadge = document.getElementById('checklistRequiredBadge');
        if (pulseDot) {
            pulseDot.style.display = 'none';
        }
        if (requiredBadge) {
            requiredBadge.style.display = 'none';
        }
    }

    function closeChecklistModal() {
        document.getElementById('checklistModal').style.display = 'none';
        // Update button state when modal is closed
        updateChecklistButtonState();
    }

    async function saveChecklist() {
        // Check if transcript is in progress or completed
        if (!isPlaying && !currentEmergencyId) {
            showToast('Cannot save checklist: No emergency call in progress. Please upload an audio file first.', 'warning');
            return;
        }

        // Check if we have an emergency ID
        if (!currentEmergencyId) {
            showToast('Cannot save checklist: Emergency record is being created. Please wait a moment and try again.', 'warning');
            return;
        }

        // Check if we have a caller ID
        if (!currentCallerId) {
            showToast('Cannot save checklist: Caller information not found.', 'warning');
            return;
        }

        // Get operator ID from session
        const user = JSON.parse(sessionStorage.getItem('user'));
        const operatorId = user ? user.id : null;

        if (!operatorId) {
            showToast('Cannot save checklist: Operator not logged in.', 'warning');
            return;
        }

        // Check if any responses exist
        const type = document.getElementById('incidentType').value;
        const questions = checklistData[type];

        if (!questions || questions.length === 0) {
            showToast('No checklist to save. Please select an incident type first.', 'warning');
            return;
        }

        // Collect all checklist responses
        const responses = [];
        questions.forEach((question, index) => {
            const answer = currentChecklist[index];
            if (answer !== undefined) {
                responses.push({
                    question: question,
                    answer: answer ? 'YES' : 'NO'
                });
            }
        });

        if (responses.length === 0) {
            showToast('Please answer at least one question before saving.', 'warning');
            return;
        }

        try {
            const response = await fetch('/api/auth/save-checklist', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    emergencyCallId: currentEmergencyId,
                    callerId: currentCallerId,
                    operatorId: operatorId,
                    incidentType: type,
                    responses: responses
                })
            });

            const result = await response.json();

            if (result.success) {
                checklistSaved = true; // Mark checklist as saved
                showToast('Checklist saved successfully!', 'success');
                updateChecklistButtonState(); // Update button appearance
                closeChecklistModal();
            } else {
                showToast('Failed to save checklist: ' + (result.message || 'Unknown error'), 'error');
            }
        } catch (error) {
            console.error('Error saving checklist:', error);
            showToast('Error saving checklist. Please try again.', 'error');
        }
    }

    function updateChecklistButtonState() {
        const type = document.getElementById('incidentType').value;
        const questions = checklistData[type];

        const viewChecklistBtn = document.getElementById('viewChecklistBtn');
        const pulseDot = document.getElementById('checklistPulseDot');
        const requiredBadge = document.getElementById('checklistRequiredBadge');
        const completedBadge = document.getElementById('checklistCompletedBadge');

        if (!viewChecklistBtn) return;

        // If checklist is saved, show completed state
        if (checklistSaved) {
            viewChecklistBtn.classList.remove('has-checklist');
            viewChecklistBtn.classList.add('checklist-completed');
            viewChecklistBtn.disabled = true;
            viewChecklistBtn.innerHTML = `
                    <span class="checklist-pulse-dot" id="checklistPulseDot" style="display: none;"></span>
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg>
                    Response Complete!
                    <span class="checklist-required-badge" id="checklistRequiredBadge" style="display: none;">REQUIRED</span>
                `;
        }
        // If checklist is required but not saved yet
        else if (type && type !== '' && questions && questions.length > 0) {
            viewChecklistBtn.classList.add('has-checklist');
            viewChecklistBtn.classList.remove('checklist-completed');
            viewChecklistBtn.disabled = false;
            viewChecklistBtn.innerHTML = `
                    <span class="checklist-pulse-dot" id="checklistPulseDot" style="display: inline-block;"></span>
                    View Checklist
                    <span class="checklist-required-badge" id="checklistRequiredBadge" style="display: inline-block;">REQUIRED</span>
                `;
        }
        // No checklist required
        else {
            viewChecklistBtn.classList.remove('has-checklist');
            viewChecklistBtn.classList.remove('checklist-completed');
            viewChecklistBtn.disabled = false;
            viewChecklistBtn.innerHTML = `
                    <span class="checklist-pulse-dot" id="checklistPulseDot" style="display: none;"></span>
                    View Checklist
                    <span class="checklist-required-badge" id="checklistRequiredBadge" style="display: none;">REQUIRED</span>
                `;
        }
    }

    function updateChecklist(autoOpen = false) {
        const type = document.getElementById('incidentType').value;
        const questions = checklistData[type];
        const description = checklistDescriptions[type];

        // Update button state
        updateChecklistButtonState();

        // Auto-open modal when type becomes 'emergency' (only if this is auto-triggered and not saved yet)
        if (autoOpen && type === 'emergency' && questions && questions.length > 0 && !checklistSaved) {
            showChecklistModal(true);
        }

        // Update modal checklist
        if (!questions || questions.length === 0) {
            document.getElementById('checklistDesc').textContent = 'Please select an incident type to view checklist.';
            document.getElementById('checklistItems').innerHTML = '<div style="text-align: center; padding: 2rem; color: #64748b;">No checklist available. Please select an incident type from the left panel.</div>';
            currentChecklist = {};
            return;
        }

        document.getElementById('checklistDesc').textContent = description;

        const container = document.getElementById('checklistItems');
        container.innerHTML = '';

        questions.forEach((question, index) => {
            const item = document.createElement('div');
            item.className = 'checklist-item';
            item.innerHTML = `
                    <span class="checklist-question">${question}</span>
                    <div class="checklist-buttons">
                        <button class="btn-yes" onclick="toggleAnswer(${index}, true)">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg>
                            Yes
                        </button>
                        <button class="btn-no" onclick="toggleAnswer(${index}, false)">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><line x1="15" y1="9" x2="9" y2="15"/><line x1="9" y1="9" x2="15" y2="15"/></svg>
                            No
                        </button>
                    </div>
                `;
            container.appendChild(item);
        });

        currentChecklist = {};
    }

    function toggleAnswer(index, answer) {
        const items = document.getElementById('checklistItems').children;
        const yesBtn = items[index].querySelector('.btn-yes');
        const noBtn = items[index].querySelector('.btn-no');

        if (currentChecklist[index] === answer) {
            currentChecklist[index] = null;
            yesBtn.classList.remove('active');
            noBtn.classList.remove('active');
        } else {
            currentChecklist[index] = answer;
            if (answer) {
                yesBtn.classList.add('active');
                noBtn.classList.remove('active');
            } else {
                yesBtn.classList.remove('active');
                noBtn.classList.add('active');
            }
        }
    }

    // Update incident information manually
    async function updateIncidentInfo() {
        // Check if we have an emergency ID
        if (!currentEmergencyId) {
            showToast('Cannot update: No emergency record found. Please upload an audio file first.', 'warning');
            return;
        }

        // Get current values
        const incidentLocation = document.getElementById('incidentLocation').value.trim();
        const incidentType = document.getElementById('incidentType').value;
        const severityLevel = document.getElementById('severityLevel').value;

        // Validate that at least one field has a value
        if (!incidentLocation && !incidentType && !severityLevel) {
            showToast('Please enter at least one field to update.', 'warning');
            return;
        }

        // Build update object
        const updates = {};
        if (incidentLocation) {
            updates.caller_location = incidentLocation;
        }
        if (incidentType && incidentType !== '') {
            updates.type = incidentType;
        }
        if (severityLevel && severityLevel !== '') {
            updates.risk_level = parseInt(severityLevel);
        }

        try {
            // Send update request to backend
            const response = await fetch(`/api/auth/emergency/${currentEmergencyId}/update`, {
                method: 'PATCH',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(updates)
            });

            if (response.ok) {
                showToast('Incident information updated successfully!', 'success');
                console.log('Updated fields:', updates);

                // Update checklist if incident type changed
                if (updates.type) {
                    updateChecklist(false);
                }
            } else {
                const error = await response.text();
                showToast('Failed to update incident information: ' + error, 'error');
            }
        } catch (error) {
            console.error('Error updating incident information:', error);
            showToast('Error updating incident information. Please try again.', 'error');
        }
    }

    // Upload functions
    function showUploadModal() {
        document.getElementById('uploadModal').style.display = 'block';
    }

    function closeUploadModal() {
        document.getElementById('uploadModal').style.display = 'none';
        selectedFile = null;
        document.getElementById('uploadedFileInfo').innerHTML = '';
        document.getElementById('uploadBtn').disabled = true;
    }

    function handleFileSelect(event) {
        const file = event.target.files[0];
        if (file) {
            selectedFile = file;
            const fileSize = (file.size / 1024 / 1024).toFixed(2);
            document.getElementById('uploadedFileInfo').innerHTML = `
                    <div class="uploaded-file">
                        <div class="file-info-wrapper">
                            <svg class="file-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/></svg>
                            <div class="file-details">
                                <div class="file-name">${file.name}</div>
                                <div class="file-size">${fileSize} MB</div>
                            </div>
                        </div>
                        <button class="remove-file-btn" onclick="removeFile()">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><line x1="15" y1="9" x2="9" y2="15"/><line x1="9" y1="9" x2="15" y2="15"/></svg>
                        </button>
                    </div>
                `;
            document.getElementById('uploadBtn').disabled = false;
        }
    }

    function removeFile() {
        selectedFile = null;
        document.getElementById('audioFile').value = '';
        document.getElementById('uploadedFileInfo').innerHTML = '';
        document.getElementById('uploadBtn').disabled = true;
    }

    async function uploadFile() {
        if (!selectedFile) return;

        // Store file reference locally before upload
        const audioFile = selectedFile;

        try {
            // Show loading state
            document.getElementById('uploadBtn').disabled = true;
            document.getElementById('uploadBtn').textContent = 'Processing...';

            // Get operator ID from session
            const user = JSON.parse(sessionStorage.getItem('user'));
            const operatorId = user ? user.id : null;

            // Get caller information from form (hardcoded for now)
            const callerPhoneNumber = '010-8734-2910';
            const callerName = 'Minsu Kim';

            // Create FormData
            const formData = new FormData();
            formData.append('file', selectedFile);
            formData.append('minSpeakers', '1');
            formData.append('maxSpeakers', '5');

            // Add caller and operator information
            if (callerPhoneNumber) {
                formData.append('callerPhoneNumber', callerPhoneNumber);
            }
            if (callerName) {
                formData.append('callerName', callerName);
            }
            if (operatorId) {
                formData.append('operatorId', operatorId);
            }

            // Call Clova API
            const response = await fetch('/api/voice/upload/clova', {
                method: 'POST',
                body: formData
            });

            const result = await response.json();

            if (result.success && result.speakerSegments) {
                transcriptSegments = result.speakerSegments;

                // Store language if returned
                if (result.language) {
                    detectedLanguage = result.language;
                    console.log('Detected language:', detectedLanguage);
                }

                // Store media asset ID if returned
                if (result.mediaAssetId) {
                    mediaAssetId = result.mediaAssetId;
                    console.log('Media asset ID:', mediaAssetId);
                }

                closeUploadModal();

                // Create audio element for playback
                try {
                    const audioUrl = URL.createObjectURL(audioFile);
                    audioElement = new Audio(audioUrl);

                    // Reset displayed segments
                    displayedSegmentIndexes.clear();

                    // Sync transcript with audio playback
                    audioElement.addEventListener('timeupdate', () => {
                        syncTranscriptWithAudio();
                    });

                    // Call start event - change status to on-call
                    audioElement.addEventListener('play', () => {
                        onCallStart();
                    });

                    // Remove active class when audio ends
                    audioElement.addEventListener('ended', () => {
                        const speakerBtn = document.getElementById('speakerBtn');
                        if (speakerBtn) {
                            speakerBtn.classList.remove('active');
                        }
                        // Call end event - change status to available
                        onCallEnd();
                    });

                    // Auto-play audio and activate speaker button
                    audioElement.play();
                    const speakerBtn = document.getElementById('speakerBtn');
                    if (speakerBtn) {
                        speakerBtn.classList.add('active');
                    }
                } catch (audioError) {
                    console.error('Error creating audio element:', audioError);
                    // Audio playback will not be available, but transcript will still work
                }

                // Hide empty state
                const emptyState = document.getElementById('emptyState');
                if (emptyState) {
                    emptyState.classList.add('hidden');
                }

                // Reset timer
                stopTimer();
                seconds = 0;

                // Initialize transcript display
                initializeTranscriptDisplay();
            } else {
                showToast('Failed to process audio file: ' + (result.error || result.message), 'error');
            }
        } catch (error) {
            console.error('Error uploading file:', error);
            showToast('Error uploading file. Please try again.', 'error');
        } finally {
            document.getElementById('uploadBtn').disabled = false;
            document.getElementById('uploadBtn').textContent = 'Upload';
        }
    }

    function initializeTranscriptDisplay() {
        if (!transcriptSegments || transcriptSegments.length === 0) return;

        isPlaying = true;

        // Reset accumulated transcript and AI extraction state for new call
        accumulatedTranscript = '';
        aiLocationExtractionInProgress = false;
        aiIncidentClassificationInProgress = false;
        checklistSaved = false; // Reset checklist saved status for new call

        // Update status to "On Call"
        const statusTextEl = document.querySelector('.status-text');
        if (statusTextEl) {
            statusTextEl.textContent = 'On Call';
        }

        // Activate status dot
        const statusDot = document.querySelector('.status-dot');
        if (statusDot) {
            statusDot.classList.add('active');
        }

        // Update recording text
        const recordingTextEl = document.getElementById('recordingText');
        if (recordingTextEl) {
            recordingTextEl.textContent = 'Voice recognition active...';
        }

        // Start timer (now synced with actual audio)
        startTimer();

        // Update Call Started time
        callStartTime = new Date();
        const timeStr = formatTime(callStartTime);
        const callStartedEl = document.querySelector('.timeline-list .timeline-item:nth-child(1) .timeline-time');
        if (callStartedEl) {
            callStartedEl.textContent = timeStr;
        }

        // Create initial emergency record for checklist saving
        createInitialEmergency();
    }

    function syncTranscriptWithAudio() {
        if (!audioElement || !transcriptSegments || transcriptSegments.length === 0) return;

        const currentTime = audioElement.currentTime;
        const locationConfirmIndex = Math.floor(transcriptSegments.length * 0.3);

        // Find segments that should be displayed at current time
        transcriptSegments.forEach((segment, index) => {
            // Check if this segment should be displayed now and hasn't been displayed yet
            if (currentTime >= segment.startTime && !displayedSegmentIndexes.has(index)) {
                displayedSegmentIndexes.add(index);
                addMessageToTranscript(segment, index);

                // Update AI Confidence (average of all displayed segments so far)
                const displayedSegments = transcriptSegments.filter((_, i) => displayedSegmentIndexes.has(i));
                updateAIConfidence(displayedSegments);

                // Update Location Confirmed
                if (index === locationConfirmIndex) {
                    const locationTime = new Date(callStartTime.getTime() + segment.startTime * 1000);
                    const locationTimeStr = formatTime(locationTime);
                    const locationEl = document.querySelector('.timeline-list .timeline-item:nth-child(2) .timeline-time');
                    if (locationEl) {
                        locationEl.textContent = locationTimeStr;
                    }
                }

                // Check if this is the last segment
                if (index === transcriptSegments.length - 1) {
                    // Wait a bit then stop
                    setTimeout(() => {
                        stopTimer();
                        isPlaying = false;

                        // Update Call Ended time and store it for database
                        callEndTime = new Date(callStartTime.getTime() + segment.endTime * 1000);
                        const callEndTimeStr = formatTime(callEndTime);
                        const callEndedEl = document.querySelector('.timeline-list .timeline-item:nth-child(5) .timeline-time');
                        if (callEndedEl) {
                            callEndedEl.textContent = callEndTimeStr;
                        }

                        // Calculate and update Elapsed Time
                        const elapsedMs = callEndTime.getTime() - callStartTime.getTime();
                        const elapsedMinutes = Math.floor(elapsedMs / 60000);
                        const elapsedSeconds = Math.floor((elapsedMs % 60000) / 1000);
                        const elapsedTimeStr = `${String(elapsedMinutes).padStart(2, '0')}:${String(elapsedSeconds).padStart(2, '0')}`;
                        const elapsedTimeEl = document.querySelector('.timeline-list .timeline-item:nth-child(6) .timeline-time');
                        if (elapsedTimeEl) {
                            elapsedTimeEl.textContent = elapsedTimeStr;
                        }

                        // Reset status to Call Ended
                        const statusTextEl = document.querySelector('.status-text');
                        if (statusTextEl) {
                            statusTextEl.textContent = 'Call Ended';
                        }

                        // Deactivate status dot
                        const statusDot = document.querySelector('.status-dot');
                        if (statusDot) {
                            statusDot.classList.remove('active');
                        }

                        // Update recording text
                        const recordingTextEl = document.getElementById('recordingText');
                        if (recordingTextEl) {
                            recordingTextEl.textContent = 'Call completed - System ready for next call';
                        }

                        // Complete emergency and save to database
                        completeEmergency();
                    }, 1000);
                }
            }
        });
    }

    function addMessageToTranscript(segment, index) {
        const messagesContainer = document.querySelector('.transcript-messages');

        // Determine if speaker is operator (speakerId 0) or caller (speakerId 1+)
        const isOperator = segment.speakerId === 0;
        const messageClass = isOperator ? 'message-operator' : 'message-caller';
        const avatarClass = isOperator ? 'operator-avatar' : 'caller-avatar';
        const senderName = isOperator ? 'Operator' : 'Caller';
        const avatarLetter = isOperator ? 'O' : 'C';

        // Format time (HH:MM:SS) - apply 2x speed
        const time = new Date(callStartTime.getTime() + segment.startTime * 500);
        const timeStr = formatTime(time);

        // Normalize text for display (fix common speech recognition errors)
        const normalizedText = normalizeLocationText(segment.text);

        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${messageClass}`;
        messageDiv.innerHTML = `
                <div class="message-header">
                    <div class="message-sender">
                        <div class="sender-avatar ${avatarClass}">${avatarLetter}</div>
                        <span class="sender-name">${senderName}</span>
                    </div>
                    <span class="message-time">${timeStr}</span>
                </div>
                <div class="message-text">
                    ${normalizedText}
                </div>
            `;

        messagesContainer.appendChild(messageDiv);

        // Auto-scroll to bottom
        messagesContainer.scrollTop = messagesContainer.scrollHeight;

        // Accumulate transcript for AI analysis (use normalized text)
        const speaker = isOperator ? 'Operator' : 'Caller';
        accumulatedTranscript += `${speaker}: ${normalizedText}\n`;

        // Analyze message content to extract incident information
        // Only analyze caller's messages (not operator's questions)
        if (!isOperator) {
            analyzeIncidentInfo(segment.text);
        } else {
            // Even for operator, extract location if mentioned
            extractLocation(segment.text);
        }
    }

    // AI-powered incident information extraction
    function analyzeIncidentInfo(text) {
        const lowerText = text.toLowerCase();

        // Skip if it's a question (operator asking)
        if (text.includes('?') || text.includes('emergency?') || text.includes("what's your emergency")) {
            // Still extract location even from questions
            extractLocation(text);
            return;
        }

        // Analyze incident type - prioritize specific types over generic "emergency"
        const incidentTypeEl = document.getElementById('incidentType');
        if (incidentTypeEl && incidentTypeEl.value === '') {
            // Priority 1: Crime (expanded keywords)
            if (lowerText.includes('crime') || lowerText.includes('ë²”ì£„') ||
                lowerText.includes('knife') || lowerText.includes('ì¹¼') ||
                lowerText.includes('gun') || lowerText.includes('ì´') ||
                lowerText.includes('weapon') || lowerText.includes('ë¬´ê¸°') ||
                lowerText.includes('chasing') || lowerText.includes('ì«“') || lowerText.includes('ë”°ë¼') ||
                lowerText.includes('attack') || lowerText.includes('ê³µê²©') ||
                lowerText.includes('threat') || lowerText.includes('ìœ„í˜‘') ||
                lowerText.includes('robbery') || lowerText.includes('ê°•ë„') ||
                lowerText.includes('assault') || lowerText.includes('í­í–‰') ||
                lowerText.includes('steal') || lowerText.includes('ë„ë‘‘') || lowerText.includes('ì ˆë„') ||
                lowerText.includes('kidnap') || lowerText.includes('ë‚©ì¹˜') ||
                lowerText.includes('murder') || lowerText.includes('ì‚´ì¸') ||
                lowerText.includes('stab') || lowerText.includes('ì°Œë¥´')) {
                incidentTypeEl.value = 'crime';
                updateChecklist(true);
            }
                // Priority 2: Disaster (fire, explosion, building collapse, natural disaster)
            // IMPORTANT: Exclude "firefighter" from fire detection to avoid false positives
            else if ((lowerText.includes('fire') && !lowerText.includes('firefighter')) || lowerText.includes('í™”ìž¬') ||
                lowerText.includes('ë¶ˆì´') || lowerText.includes('ë¶ˆë‚˜') ||
                lowerText.includes('smoke') || lowerText.includes('ì—°ê¸°') ||
                lowerText.includes('burning') || lowerText.includes('íƒ€ê³ ') || lowerText.includes('ë¶ˆíƒ€') ||
                lowerText.includes('flames') || lowerText.includes('í™”ì—¼') ||
                lowerText.includes('explosion') || lowerText.includes('í­ë°œ') ||
                lowerText.includes('collapse') || lowerText.includes('ë¶•ê´´') ||
                lowerText.includes('earthquake') || lowerText.includes('ì§€ì§„')) {
                incidentTypeEl.value = 'disaster';
                updateChecklist(true);
            }
            // Priority 3: Medical (medical emergency, cardiac arrest, unconscious, severe bleeding)
            else if (lowerText.includes('cardiac arrest') || lowerText.includes('ì‹¬ì •ì§€') ||
                lowerText.includes('unconscious') || lowerText.includes('ì˜ì‹') ||
                lowerText.includes('bleeding') || lowerText.includes('í”¼') || lowerText.includes('ì¶œí˜ˆ') ||
                lowerText.includes('chest pain') || lowerText.includes('ê°€ìŠ´') ||
                lowerText.includes('breathing') || lowerText.includes('í˜¸í¡') ||
                lowerText.includes('injured') || lowerText.includes('ë‹¤ì³¤') || lowerText.includes('ë¶€ìƒ') ||
                lowerText.includes('hurt') || lowerText.includes('ì•„í”„') ||
                lowerText.includes('fell') || lowerText.includes('ë–¨ì–´') ||
                lowerText.includes('broken') || lowerText.includes('ê³¨ì ˆ')) {
                incidentTypeEl.value = 'medical';
                updateChecklist(true);
            }
                // Priority 4: Rescue (trapped, buried, water, high-rise isolation, elevator)
            // IMPORTANT: Check rescue BEFORE traffic to avoid "car" (elevator car) being misclassified as traffic
            else if (lowerText.includes('trapped') || lowerText.includes('ê°‡') ||
                lowerText.includes('stuck') || lowerText.includes('ë¼') ||
                lowerText.includes('elevator') || lowerText.includes('ì—˜ë¦¬ë² ì´í„°') || lowerText.includes('ìŠ¹ê°•ê¸°') ||
                lowerText.includes('buried') || lowerText.includes('ë§¤ëª°') ||
                lowerText.includes('water') || lowerText.includes('ë¬¼') ||
                lowerText.includes('drowning') || lowerText.includes('ìµìˆ˜') ||
                lowerText.includes('isolated') || lowerText.includes('ê³ ë¦½')) {
                incidentTypeEl.value = 'rescue';
                updateChecklist(true);
            }
            // Priority 5: Traffic (vehicle-related incidents)
            else if (lowerText.includes('accident') || lowerText.includes('ì‚¬ê³ ') ||
                lowerText.includes('crash') || lowerText.includes('ì¶©ëŒ') ||
                lowerText.includes('car') || lowerText.includes('ì°¨ëŸ‰') || lowerText.includes('êµí†µ') ||
                lowerText.includes('hit') || lowerText.includes('ë¶€ë”ª') ||
                lowerText.includes('vehicle') || lowerText.includes('ìžë™ì°¨')) {
                incidentTypeEl.value = 'traffic';
                updateChecklist(true);
            }
            // Priority 6: Other (non-urgent, general inquiries)
            else if ((lowerText.includes('ì‘ê¸‰') || lowerText.includes('ìœ„ê¸‰') || lowerText.includes('ìœ„í—˜') ||
                    lowerText.includes('ë„ì™€ì£¼ì„¸ìš”') || lowerText.includes('ì‚´ë ¤') ||
                    lowerText.includes('help me') || lowerText.includes('save me')) &&
                !lowerText.includes('ë¬´ìŠ¨') && !lowerText.includes('ì–´ë–¤') && !lowerText.includes('what')) {
                incidentTypeEl.value = 'other';
                updateChecklist(true);
            }
        }

        // Analyze incident location
        extractLocation(text);

        // Analyze severity level based on keywords
        analyzeSeverityLevel(text, lowerText);

        // If incident type still not found by keywords, try AI classification
        if (incidentTypeEl && incidentTypeEl.value === '' && accumulatedTranscript.length > 50) {
            classifyIncidentTypeWithAI();
        }

        // Try AI-powered location extraction if accumulated transcript is sufficient
        if (accumulatedTranscript.length > 50) {
            extractLocationWithAI();
        }

        // Periodically assess risk level with AI during the call
        // This works in combination with keyword-based detection for comprehensive risk assessment
        // Call AI assessment when we have sufficient new content (every ~80 characters)
        if (accumulatedTranscript.length > 80) {
            assessRiskLevelWithAI();
        }
    }

    // Analyze severity level based on keywords
    // Scale: 1=Minimal, 2=Low, 3=Moderate, 4=High, 5=Critical
    function analyzeSeverityLevel(text, lowerText) {
        const severityLevelEl = document.getElementById('severityLevel');
        if (!severityLevelEl) return;

        const currentLevel = severityLevelEl.value;
        const previousLevel = currentLevel;

        console.log(`[Severity Check] Current: "${currentLevel}", Text: "${text.substring(0, 100)}"`);

        // Level 5 - Critical: Immediate life-threatening situations only
        if (lowerText.includes('dying') || lowerText.includes('ì£½ì–´') || lowerText.includes('ì£½ê³ ìžˆ') ||
            lowerText.includes('not breathing') || lowerText.includes('í˜¸í¡ì•ˆ') || lowerText.includes('ìˆ¨ì„ëª»') ||
            lowerText.includes('cardiac arrest') || lowerText.includes('ì‹¬ì •ì§€') ||
            lowerText.includes('unconscious') || lowerText.includes('ì˜ì‹ì—†') ||
            lowerText.includes('severe bleeding') || lowerText.includes('ëŒ€ëŸ‰ì¶œí˜ˆ') ||
            lowerText.includes('multiple gunshot') || lowerText.includes('ì´ìƒ') ||
            lowerText.includes('explosion') || lowerText.includes('í­ë°œ')) {
            // Only upgrade to level 5, never downgrade
            if (currentLevel === '' || parseInt(currentLevel) < 5) {
                severityLevelEl.value = '5';
                console.log(`ðŸš¨ Severity UPGRADED: ${previousLevel || 'none'} â†’ Level 5 - CRITICAL (í‚¤ì›Œë“œ ê°ì§€: "${text.substring(0, 50)}...")`);
            }
        }
        // Level 4 - High: Serious injury or violence (INCLUDES WEAPONS)
        else if ((lowerText.includes('knife') || lowerText.includes('ì¹¼') ||
                lowerText.includes('weapon') || lowerText.includes('ë¬´ê¸°') ||
                lowerText.includes('chase') || lowerText.includes('chasing') || lowerText.includes('ì«“') ||
                lowerText.includes('following') || lowerText.includes('ë’¤ì—ì„œ') || lowerText.includes('ë”°ë¼') ||
                lowerText.includes('running away') || lowerText.includes('ë„ë§') || lowerText.includes('run away') ||
                lowerText.includes('stabbing') || lowerText.includes('ì°Œë¥´') || lowerText.includes('stab') ||
                lowerText.includes('shooting') || lowerText.includes('ì´') || lowerText.includes('shot') || lowerText.includes('gun') ||
                lowerText.includes('bat') || lowerText.includes('stick') || lowerText.includes('blade') || lowerText.includes('ì¹¼ë‚ ') ||
                lowerText.includes('attacking') || lowerText.includes('attack') || lowerText.includes('ê³µê²©') ||
                lowerText.includes('heart attack') || lowerText.includes('ì‹¬ìž¥') ||
                lowerText.includes('chest pain') || lowerText.includes('ê°€ìŠ´í†µì¦') ||
                lowerText.includes('severe pain') || lowerText.includes('ì‹¬í•œí†µì¦') ||
                lowerText.includes('broken bone') || lowerText.includes('ê³¨ì ˆ') ||
                lowerText.includes('trapped') || lowerText.includes('ê°‡í˜”') ||
                lowerText.includes('fire spreading') || lowerText.includes('ë¶ˆë²ˆ') ||
                lowerText.includes('multiple victims') || lowerText.includes('ì—¬ëŸ¬ëª…') ||
                lowerText.includes('assault') || lowerText.includes('í­í–‰')) &&
            currentLevel !== '5') {
            // Upgrade to level 4 if current is lower
            if (currentLevel === '' || parseInt(currentLevel) < 4) {
                severityLevelEl.value = '4';
                console.log(`âš ï¸ Severity UPGRADED: ${previousLevel || 'none'} â†’ Level 4 - HIGH (í‚¤ì›Œë“œ ê°ì§€: "${text.substring(0, 50)}...")`);
            }
        }
        // Level 3 - Moderate: Medical attention needed but not critical
        else if ((lowerText.includes('emergency') || lowerText.includes('ì‘ê¸‰') ||
                lowerText.includes('urgent') || lowerText.includes('ìœ„ê¸‰') ||
                lowerText.includes('help') || lowerText.includes('ë„ì™€') ||
                lowerText.includes('injured') || lowerText.includes('ë‹¤ì³¤') || lowerText.includes('ë¶€ìƒ') ||
                lowerText.includes('bleeding') || lowerText.includes('í”¼') || lowerText.includes('ì¶œí˜ˆ') ||
                lowerText.includes('hurt') || lowerText.includes('ì•„í”„') || lowerText.includes('ì•„íŒŒ') ||
                lowerText.includes('pain') || lowerText.includes('í†µì¦') ||
                lowerText.includes('accident') || lowerText.includes('ì‚¬ê³ ') ||
                lowerText.includes('collapsed') || lowerText.includes('ì“°ëŸ¬') ||
                lowerText.includes('fell') || lowerText.includes('ë„˜ì–´') ||
                lowerText.includes('seizure') || lowerText.includes('ë°œìž‘') ||
                lowerText.includes('breathing difficulty') || lowerText.includes('í˜¸í¡ê³¤ëž€') ||
                lowerText.includes('smoke') || lowerText.includes('ì—°ê¸°') ||
                lowerText.includes('fire') || lowerText.includes('ë¶ˆ') || lowerText.includes('í™”ìž¬') ||
                lowerText.includes('robbery') || lowerText.includes('ê°•ë„') ||
                lowerText.includes('burglary') || lowerText.includes('ì¹¨ìž…')) &&
            currentLevel !== '5' && currentLevel !== '4') {
            // Upgrade to level 3 if current is lower
            if (currentLevel === '' || parseInt(currentLevel) < 3) {
                severityLevelEl.value = '3';
                console.log(`âš ï¸ Severity UPGRADED: ${previousLevel || 'none'} â†’ Level 3 - MODERATE (í‚¤ì›Œë“œ ê°ì§€: "${text.substring(0, 50)}...")`);
            }
        }
        // Level 2 - Low: Non-urgent situations
        else if ((lowerText.includes('property damage') || lowerText.includes('ìž¬ì‚°í”¼í•´') ||
                lowerText.includes('noise complaint') || lowerText.includes('ì†ŒìŒ') ||
                lowerText.includes('parking') || lowerText.includes('ì£¼ì°¨') ||
                lowerText.includes('minor theft') || lowerText.includes('ê²½ë¯¸')) &&
            currentLevel !== '5' && currentLevel !== '4' && currentLevel !== '3') {
            // Upgrade to level 2 if current is lower
            if (currentLevel === '' || parseInt(currentLevel) < 2) {
                severityLevelEl.value = '2';
                console.log(`âš ï¸ Severity UPGRADED: ${previousLevel || 'none'} â†’ Level 2 - Low`);
            }
        }
        // Level 1 - Minimal: Information requests (FIXED: was incorrectly set to 5)
        else if ((lowerText.includes('question') || lowerText.includes('ì§ˆë¬¸') ||
                lowerText.includes('inquiry') || lowerText.includes('ë¬¸ì˜') ||
                lowerText.includes('information') || lowerText.includes('ì •ë³´')) &&
            currentLevel === '') {
            severityLevelEl.value = '1';
            console.log('â„¹ï¸ Severity set to Level 1 - Minimal');
        }
    }

    // AI-powered risk level assessment (called periodically during conversation)
    let aiRiskAssessmentInProgress = false;
    let lastRiskAssessmentTranscriptLength = 0;

    async function assessRiskLevelWithAI() {
        // Avoid duplicate calls and only call if transcript has grown significantly
        // Reduced threshold to 60 characters for more frequent real-time updates
        if (aiRiskAssessmentInProgress ||
            accumulatedTranscript.length < 50 ||
            accumulatedTranscript.length - lastRiskAssessmentTranscriptLength < 60) {
            return;
        }

        try {
            aiRiskAssessmentInProgress = true;
            lastRiskAssessmentTranscriptLength = accumulatedTranscript.length;

            const response = await fetch('/api/openai/assess-risk', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    transcript: accumulatedTranscript
                })
            });

            if (response.ok) {
                const result = await response.json();
                if (result.level) {
                    const severityLevelEl = document.getElementById('severityLevel');
                    if (severityLevelEl) {
                        const currentLevel = severityLevelEl.value;
                        const newLevel = result.level.toString();

                        // Always update with AI assessment (AI is more accurate)
                        if (currentLevel !== newLevel) {
                            severityLevelEl.value = newLevel;
                            console.log(`AI Risk Assessment: Level ${newLevel} - ${result.reason}`);
                        }
                    }
                }
            }
        } catch (error) {
            console.warn('AI risk assessment failed:', error);
        } finally {
            aiRiskAssessmentInProgress = false;
        }
    }

    // AI-powered incident type classification using OpenAI
    async function classifyIncidentTypeWithAI() {
        // Check if type already found or AI classification already in progress
        const incidentTypeEl = document.getElementById('incidentType');
        if (!incidentTypeEl || incidentTypeEl.value || aiIncidentClassificationInProgress) {
            return;
        }

        try {
            aiIncidentClassificationInProgress = true;

            const response = await fetch('/api/auth/classify-incident', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    transcript: accumulatedTranscript
                })
            });

            if (response.ok) {
                const result = await response.json();

                if (result.success === 'true' && result.incidentType && result.incidentType.trim() !== '') {
                    // Only update if incident type field is still empty
                    if (!incidentTypeEl.value || incidentTypeEl.value === '') {
                        incidentTypeEl.value = result.incidentType;
                        updateChecklist(true);
                        console.log('AI classified incident type:', result.incidentType);
                    }
                }
            }
        } catch (error) {
            console.error('Error calling AI incident classification:', error);
        } finally {
            // Allow next classification after 5 seconds
            setTimeout(() => {
                aiIncidentClassificationInProgress = false;
            }, 5000);
        }
    }

    // AI-powered location extraction using OpenAI + Kakao Map API
    async function extractLocationWithAI() {
        // Check if location already found or AI extraction already in progress
        const locationEl = document.getElementById('incidentLocation');
        if (!locationEl || locationEl.value || aiLocationExtractionInProgress) {
            return;
        }

        try {
            aiLocationExtractionInProgress = true;

            const response = await fetch('/api/auth/extract-location', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    transcript: accumulatedTranscript
                })
            });

            if (response.ok) {
                const result = await response.json();

                if (result.success === 'true' && result.location && result.location.trim() !== '') {
                    // Only update if location field is still empty
                    if (!locationEl.value) {
                        locationEl.value = result.location;
                        console.log('AI extracted location:', result.location);

                        // Convert address to coordinates using Kakao Geocoding API
                        await geocodeAndUpdateLocation(result.location);
                    }
                }
            }
        } catch (error) {
            console.error('Error calling AI location extraction:', error);
        } finally {
            // Allow next extraction after 5 seconds
            setTimeout(() => {
                aiLocationExtractionInProgress = false;
            }, 5000);
        }
    }

    // Geocode address and update emergency record with coordinates
    async function geocodeAndUpdateLocation(address) {
        try {
            console.log('Geocoding address:', address);

            // Wait for Kakao Maps SDK to be ready
            await kakaoMapsLoadPromise;
            await new Promise(resolve => setTimeout(resolve, 100));

            // Use Kakao Maps JavaScript SDK Geocoder
            if (typeof kakao !== 'undefined' && kakao.maps && kakao.maps.services) {
                const geocoder = new kakao.maps.services.Geocoder();

                geocoder.addressSearch(address, function(result, status) {
                    if (status === kakao.maps.services.Status.OK) {
                        const longitude = parseFloat(result[0].x);
                        const latitude = parseFloat(result[0].y);

                        console.log('Geocoded coordinates:', { latitude, longitude });

                        // Update emergency record with coordinates
                        if (currentEmergencyId) {
                            fetch(`/api/emergencies/${currentEmergencyId}`, {
                                method: 'PUT',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify({
                                    longitude: longitude,
                                    latitude: latitude
                                })
                            }).then(() => {
                                console.log('Emergency record updated with coordinates');
                            }).catch(error => {
                                console.error('Error updating emergency record:', error);
                            });
                        }
                    } else {
                        console.warn('No geocoding results found for address:', address, status);
                    }
                });
            } else {
                console.error('Kakao Maps Geocoder not available');
            }
        } catch (error) {
            console.error('Error geocoding address:', error);
        }
    }

    // Normalize location text to fix common speech recognition errors
    function normalizeLocationText(location) {
        if (!location) {
            return location;
        }

        let normalized = location;

        // Fix common Korean district name recognition errors
        // "ganggu" -> "Gangseo-gu"
        normalized = normalized.replace(/\bganggu\b/gi, 'Gangseo-gu');

        // Add more common corrections
        normalized = normalized.replace(/\bgangnam(?!-gu)\b/gi, 'Gangnam-gu');
        normalized = normalized.replace(/\bgangdong(?!-gu)\b/gi, 'Gangdong-gu');
        normalized = normalized.replace(/\bjongno(?!-gu)\b/gi, 'Jongno-gu');
        normalized = normalized.replace(/\bmapo(?!-gu)\b/gi, 'Mapo-gu');

        return normalized;
    }

    // Enhanced location extraction with API lookup
    async function extractLocation(text) {
        const locationEl = document.getElementById('incidentLocation');
        if (!locationEl || locationEl.value !== '') {
            return; // Already has a value
        }

        let extractedAddress = null;

        // Pattern 1: Full Korean address (ì„œìš¸íŠ¹ë³„ì‹œ ê°•ë‚¨êµ¬ ëŒ€ì¹˜ë™ 152)
        const fullAddressPattern = /([ê°€-íž£]+(?:íŠ¹ë³„ì‹œ|ê´‘ì—­ì‹œ|ì‹œ|ë„)\s*[ê°€-íž£]+êµ¬\s*[ê°€-íž£]+ë™\s*\d+[-\d]*)/g;
        let matches = text.match(fullAddressPattern);
        if (matches && matches.length > 0) {
            extractedAddress = matches[0].trim();
        }

        // Pattern 2: District + Neighborhood + Number (ê°•ë‚¨êµ¬ ëŒ€ì¹˜ë™ 152ë²ˆì§€)
        if (!extractedAddress) {
            const districtPattern = /([ê°€-íž£]+êµ¬\s*[ê°€-íž£]+ë™\s*\d+[-\d]*(?:ë²ˆì§€|ë²ˆ)?)/g;
            matches = text.match(districtPattern);
            if (matches && matches.length > 0) {
                extractedAddress = matches[0].trim();
            }
        }

        // Pattern 3: Road address (í…Œí—¤ëž€ë¡œ 152, ê°•ë‚¨ëŒ€ë¡œ 123ê¸¸)
        if (!extractedAddress) {
            const roadAddressPattern = /([ê°€-íž£]+(?:ë¡œ|ëŒ€ë¡œ|ê¸¸)\s*\d+[-\d]*(?:ê¸¸)?)/g;
            matches = text.match(roadAddressPattern);
            if (matches && matches.length > 0) {
                const roadMatch = matches[0];
                const roadIndex = text.indexOf(roadMatch);
                const beforeRoad = text.substring(Math.max(0, roadIndex - 20), roadIndex);
                const districtMatch = beforeRoad.match(/([ê°€-íž£]+(?:êµ¬|ì‹œ))/);

                if (districtMatch) {
                    extractedAddress = districtMatch[0] + ' ' + roadMatch.trim();
                } else {
                    extractedAddress = roadMatch.trim();
                }
            }
        }

        // Pattern 4: Building name + area (ë¡¯ë°íƒ€ì›Œ ì†¡íŒŒêµ¬, ì½”ì—‘ìŠ¤ ê°•ë‚¨êµ¬)
        if (!extractedAddress) {
            const buildingPattern = /([ê°€-íž£]+(?:íƒ€ì›Œ|ë¹Œë”©|ì„¼í„°|ì•„íŒŒíŠ¸|ë¹Œë¼)\s*[ê°€-íž£]+(?:êµ¬|ì‹œ))/g;
            matches = text.match(buildingPattern);
            if (matches && matches.length > 0) {
                extractedAddress = matches[0].trim();
            }
        }

        // Pattern 5: Simple area mention (ê°•ë‚¨êµ¬ ëŒ€ì¹˜ë™)
        if (!extractedAddress) {
            const areaPattern = /([ê°€-íž£]+êµ¬\s*[ê°€-íž£]+ë™)/g;
            matches = text.match(areaPattern);
            if (matches && matches.length > 0) {
                extractedAddress = matches[0].trim();
            }
        }

        // Pattern 6: City + district (ì„œìš¸ ê°•ë‚¨êµ¬)
        if (!extractedAddress) {
            const cityDistrictPattern = /([ê°€-íž£]+(?:ì‹œ|ë„)\s*[ê°€-íž£]+êµ¬)/g;
            matches = text.match(cityDistrictPattern);
            if (matches && matches.length > 0) {
                extractedAddress = matches[0].trim();
            }
        }

        // Pattern 7: English address with number (152 Daechi-dong, Gangnam-gu)
        if (!extractedAddress) {
            const englishAddressPattern = /(\d+\s+[A-Za-z]+-[A-Za-z]+(?:,\s*[A-Za-z]+-[A-Za-z]+)+)/gi;
            matches = text.match(englishAddressPattern);
            if (matches && matches.length > 0) {
                extractedAddress = matches[0].trim();
            }
        }

        // Pattern 8: English full address with street name (152 Main Street)
        if (!extractedAddress) {
            const englishFullPattern = /(\d+\s+[A-Za-z\s]+(?:Street|Road|Avenue|Blvd|Boulevard|Lane|Drive|Way|Court|Plaza)(?:,\s*[A-Za-z\s]+)?)/gi;
            matches = text.match(englishFullPattern);
            if (matches && matches.length > 0) {
                extractedAddress = matches[0].trim();
            }
        }

        // Pattern 9: Location after specific indicators (I'm at Central Park)
        if (!extractedAddress) {
            // More specific patterns for location indicators
            const atPattern = /\b(?:I'm\s+at|at\s+the|near\s+the|near|at)\s+([A-Z][A-Za-z\s]+(?:Park|Station|Mall|Center|Building|Tower|Hospital|School|Airport|Plaza))/gi;
            matches = text.match(atPattern);
            if (matches && matches.length > 0) {
                // Extract just the location name
                const locationName = matches[0].replace(/\b(?:I'm\s+at|at\s+the|near\s+the|near|at)\s+/gi, '').trim();
                if (locationName.length > 3) {
                    extractedAddress = locationName;
                }
            }
        }

        // Validate extracted address
        if (extractedAddress) {
            // Normalize the extracted address (fix common speech recognition errors)
            extractedAddress = normalizeLocationText(extractedAddress);
            console.log('Normalized address:', extractedAddress);

            // Remove if too short or looks like regular text
            if (extractedAddress.length < 5) {
                console.log('Address too short, ignoring:', extractedAddress);
                return;
            }

            // Check if it contains common non-address words (filtering out false positives)
            const nonAddressWords = /\b(chasing|help|please|someone|knife|gun|scared|emergency|hurry|quick|come)\b/gi;
            if (nonAddressWords.test(extractedAddress)) {
                console.log('Extracted text contains non-address words, ignoring:', extractedAddress);
                return;
            }

            // Must contain at least one of: number, Korean address marker, English address marker
            const hasNumber = /\d/.test(extractedAddress);
            const hasKoreanMarker = /(?:êµ¬|ë™|ë¡œ|ê¸¸|ì‹œ|ë„)/.test(extractedAddress);
            const hasEnglishMarker = /(?:Street|Road|Avenue|Blvd|Lane|Drive|Way|dong|gu|si)/i.test(extractedAddress);

            if (!hasNumber && !hasKoreanMarker && !hasEnglishMarker) {
                console.log('No address markers found, ignoring:', extractedAddress);
                return;
            }

            // If we found a valid address, verify it with API
            try {
                const response = await fetch(`/api/auth/search-address?query=${encodeURIComponent(extractedAddress)}`);
                if (response.ok) {
                    const data = await response.json();
                    if (data.address && data.address !== extractedAddress) {
                        // Use the formal address from API
                        locationEl.value = data.address;
                        console.log('Address verified via API:', data.address);
                    } else {
                        // Use extracted address if API didn't return better result
                        locationEl.value = extractedAddress;
                        console.log('Address extracted:', extractedAddress);
                    }
                } else {
                    // If API fails, use extracted address
                    locationEl.value = extractedAddress;
                    console.log('Address extracted (API not available):', extractedAddress);
                }
            } catch (error) {
                console.error('Error verifying address:', error);
                // If API call fails, use extracted address
                locationEl.value = extractedAddress;
            }
        }
    }

    function updateAIConfidence(segments) {
        if (!segments || segments.length === 0) return;

        // Generate random confidence between 90% and 100%
        const confidencePercent = 90 + Math.floor(Math.random() * 11); // 90-100

        const confidenceEl = document.getElementById('aiConfidence');
        if (confidenceEl) {
            confidenceEl.textContent = `AI Confidence: ${confidencePercent}%`;
        }
    }

    function toggleSpeaker() {
        if (!audioElement) {
            showToast('No audio file loaded. Please upload an audio file first.', 'warning');
            return;
        }

        const speakerBtn = document.getElementById('speakerBtn');

        // Toggle mute/unmute
        audioElement.muted = !audioElement.muted;

        if (speakerBtn) {
            if (audioElement.muted) {
                speakerBtn.classList.remove('active');
            } else {
                speakerBtn.classList.add('active');
            }
        }
    }

    function playAudio() {
        if (!audioElement) {
            showToast('No audio file loaded. Please upload an audio file first.', 'warning');
            return;
        }

        const playBtn = document.getElementById('playBtn');

        // Toggle play/pause
        if (audioElement.paused) {
            audioElement.play();
            if (playBtn) {
                playBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg> Pause`;
                playBtn.classList.add('active');
            }
        } else {
            audioElement.pause();
            if (playBtn) {
                playBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"/></svg> Play`;
                playBtn.classList.remove('active');
            }
        }
    }

    function searchManuals() {
        const searchInput = document.getElementById('manualSearch');
        const manualList = document.getElementById('manualList');
        const manualItems = manualList.getElementsByClassName('manual-item');
        const searchTerm = searchInput.value.toLowerCase();

        for (let i = 0; i < manualItems.length; i++) {
            const itemText = manualItems[i].textContent.toLowerCase();
            if (itemText.includes(searchTerm)) {
                manualItems[i].style.display = '';
            } else {
                manualItems[i].style.display = 'none';
            }
        }
    }

    async function showTeamDetails() {
        if (!assignedTeamData) {
            showToast('No team assigned yet', 'warning');
            return;
        }

        const modal = document.getElementById('dispatchRequestModal');
        const teamListEl = document.getElementById('teamSelectionList');
        const modalTitle = modal.querySelector('.modal-header h2');
        const modalFooter = modal.querySelector('.modal-footer');

        if (!modal || !teamListEl) return;

        // Change modal title
        if (modalTitle) {
            modalTitle.textContent = 'Assigned Team Details';
        }

        // Show loading state
        teamListEl.innerHTML = '<div style="text-align: center; padding: 2rem; color: #64748b;">Loading team details...</div>';
        modal.style.display = 'flex';

        try {
            // Fetch latest team data
            const response = await fetch(`/api/units/${assignedTeamData.id}/members`);
            const result = await response.json();

            if (result.success) {
                assignedTeamData.membersList = result.data || [];
            }

            const allMembers = assignedTeamData.membersList || [];
            // Exclude leader and deputy from members list
            const membersList = allMembers.filter(member =>
                member.name !== assignedTeamData.leader1_name &&
                member.name !== assignedTeamData.leader2_name
            );
            const memberCount = membersList.length;

            // Build team card with map
            teamListEl.innerHTML = `
                    <div class="team-card" style="cursor: default;">
                        <div class="team-card-header">
                            <div class="team-info">
                                <div class="team-name">${assignedTeamData.name || 'Unnamed Team'}</div>
                                <span class="team-status">Assigned</span>
                            </div>
                        </div>
                        <div class="team-details">
                            <div class="team-detail-row">
                                <span class="team-detail-label">Leader:</span>
                                <span class="team-detail-value">${assignedTeamData.leader1_name || '-'}${assignedTeamData.leader1_phone ? ` (${assignedTeamData.leader1_phone})` : ''}</span>
                            </div>
                            <div class="team-detail-row">
                                <span class="team-detail-label">Deputy:</span>
                                <span class="team-detail-value">${assignedTeamData.leader2_name || '-'}${assignedTeamData.leader2_phone ? ` (${assignedTeamData.leader2_phone})` : ''}</span>
                            </div>
                            <div class="team-detail-row">
                                <span class="team-detail-label">Vehicle:</span>
                                <span class="team-detail-value">${getVehicleType(assignedTeamData)}</span>
                            </div>
                            <div class="team-members">
                                <div class="team-detail-label" style="margin-bottom: 0.25rem;">Members (${memberCount}):</div>
                                ${membersList.length > 0
                ? membersList.map(member => {
                    return `<div class="team-member">â€¢ ${member.name || 'Unknown'} (${member.role || 'Operator'})</div>`;
                }).join('')
                : '<div class="team-member" style="color: #94a3b8;">ë°°ì¹˜ëœ ëŒ€ì› ì—†ìŒ</div>'
            }
                            </div>

                            <!-- Team Location Map -->
                            <div style="margin-top: 1.5rem;">
                                <div class="team-detail-label" style="margin-bottom: 0.5rem;">
                                    Current Location: <span style="font-weight: normal; color: #64748b;">ì„œìš¸íŠ¹ë³„ì‹œ ì„œëŒ€ë¬¸êµ¬ ì—°ì„¸ë¡œ 50</span>
                                </div>
                                <div id="teamLocationMap" style="width: 100%; height: 300px; border-radius: 0.5rem; border: 1px solid #e2e8f0;"></div>
                                <div style="margin-top: 0.75rem; color: #64748b; font-size: 0.9rem;">
                                    Estimated arrival time: approximately 20 minutes
                                </div>
                            </div>
                        </div>
                    </div>
                `;

            // Show footer with close button
            if (modalFooter) {
                modalFooter.style.display = 'flex';
                modalFooter.innerHTML = `
                        <button class="btn" onclick="closeTeamDetailsModal()">Close</button>
                    `;
            }

            // Initialize Kakao Map with hardcoded location and route
            setTimeout(async () => {
                const mapContainer = document.getElementById('teamLocationMap');
                if (!mapContainer) return;

                try {
                    // Check if Kakao Maps SDK is fully loaded
                    if (typeof kakao !== 'undefined' && kakao.maps && kakao.maps.LatLng) {
                        // Starting point (ì¶œë°œì§€): ìœ„ë„ 37.564923, ê²½ë„ 126.938441
                        const startLat = 37.564923;
                        const startLng = 126.938441;

                        // Destination (ë„ì°©ì§€): ìœ„ë„ 37.521783009419, ê²½ë„ 126.90571462295
                        const destLat = 37.521783009419;
                        const destLng = 126.90571462295;

                        // Calculate center point between start and destination
                        const centerLat = (startLat + destLat) / 2;
                        const centerLng = (startLng + destLng) / 2;

                        const mapOption = {
                            center: new kakao.maps.LatLng(centerLat, centerLng),
                            level: 8  // Adjusted zoom level
                        };
                        const map = new kakao.maps.Map(mapContainer, mapOption);

                        // Add default marker at starting location (ì¶œë°œì§€)
                        const startPosition = new kakao.maps.LatLng(startLat, startLng);
                        const startMarker = new kakao.maps.Marker({
                            position: startPosition,
                            map: map
                        });

                        // Add default marker at destination (ë„ì°©ì§€)
                        const destPosition = new kakao.maps.LatLng(destLat, destLng);
                        const destMarker = new kakao.maps.Marker({
                            position: destPosition,
                            map: map
                        });

                        // Try to get actual road route from Kakao Direction API
                        try {
                            const response = await fetch(`https://apis-navi.kakaomobility.com/v1/directions?origin=${startLng},${startLat}&destination=${destLng},${destLat}&priority=RECOMMEND`, {
                                method: 'GET',
                                headers: {
                                    'Authorization': 'KakaoAK d1cae915e3ca63dc7156f202e00e2b71',
                                    'Content-Type': 'application/json'
                                }
                            });

                            if (response.ok) {
                                const data = await response.json();
                                console.log('Direction API response:', data);

                                // Extract route coordinates from the response
                                if (data.routes && data.routes.length > 0) {
                                    const route = data.routes[0];
                                    const linePath = [];

                                    // Parse the route sections and vertices
                                    route.sections.forEach(section => {
                                        section.roads.forEach(road => {
                                            road.vertexes.forEach((vertex, index) => {
                                                if (index % 2 === 0) {
                                                    const lng = vertex;
                                                    const lat = road.vertexes[index + 1];
                                                    if (lat && lng) {
                                                        linePath.push(new kakao.maps.LatLng(lat, lng));
                                                    }
                                                }
                                            });
                                        });
                                    });

                                    // Draw the actual road route
                                    const polyline = new kakao.maps.Polyline({
                                        path: linePath,
                                        strokeWeight: 6,
                                        strokeColor: '#FF0000',
                                        strokeOpacity: 0.8,
                                        strokeStyle: 'solid'
                                    });

                                    polyline.setMap(map);
                                    console.log('Actual road route displayed with', linePath.length, 'points');
                                }
                            } else {
                                console.warn('Direction API failed, using straight line fallback');
                                // Fallback to straight line if API fails
                                const linePath = [
                                    new kakao.maps.LatLng(startLat, startLng),
                                    new kakao.maps.LatLng(destLat, destLng)
                                ];

                                const polyline = new kakao.maps.Polyline({
                                    path: linePath,
                                    strokeWeight: 5,
                                    strokeColor: '#FF0000',
                                    strokeOpacity: 0.8,
                                    strokeStyle: 'solid'
                                });

                                polyline.setMap(map);
                            }
                        } catch (error) {
                            console.error('Error fetching route:', error);
                            // Fallback to straight line
                            const linePath = [
                                new kakao.maps.LatLng(startLat, startLng),
                                new kakao.maps.LatLng(destLat, destLng)
                            ];

                            const polyline = new kakao.maps.Polyline({
                                path: linePath,
                                strokeWeight: 5,
                                strokeColor: '#FF0000',
                                strokeOpacity: 0.8,
                                strokeStyle: 'solid'
                            });

                            polyline.setMap(map);
                        }

                        console.log('Map initialized with route from', startLat, startLng, 'to', destLat, destLng);
                    } else {
                        console.log('Kakao Maps SDK not fully loaded, retrying...');
                        // Retry after a longer delay
                        setTimeout(() => {
                            // Simplified retry with straight line
                            if (typeof kakao !== 'undefined' && kakao.maps && kakao.maps.LatLng) {
                                const startLat = 37.564923;
                                const startLng = 126.938441;
                                const destLat = 37.521783009419;
                                const destLng = 126.90571462295;
                                const centerLat = (startLat + destLat) / 2;
                                const centerLng = (startLng + destLng) / 2;

                                const mapOption = {
                                    center: new kakao.maps.LatLng(centerLat, centerLng),
                                    level: 8
                                };
                                const map = new kakao.maps.Map(mapContainer, mapOption);

                                // Default marker for starting location
                                const startMarker = new kakao.maps.Marker({
                                    position: new kakao.maps.LatLng(startLat, startLng),
                                    map: map
                                });

                                // Default marker for destination
                                const destMarker = new kakao.maps.Marker({
                                    position: new kakao.maps.LatLng(destLat, destLng),
                                    map: map
                                });

                                const linePath = [
                                    new kakao.maps.LatLng(startLat, startLng),
                                    new kakao.maps.LatLng(destLat, destLng)
                                ];

                                const polyline = new kakao.maps.Polyline({
                                    path: linePath,
                                    strokeWeight: 5,
                                    strokeColor: '#FF0000',
                                    strokeOpacity: 0.8,
                                    strokeStyle: 'solid'
                                });

                                polyline.setMap(map);
                                console.log('Map initialized on retry with route');
                            } else {
                                console.error('Kakao Maps SDK still not available');
                                mapContainer.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; background: #f1f5f9; color: #64748b;">Map unavailable</div>';
                            }
                        }, 1000);
                    }
                } catch (error) {
                    console.error('Error loading Kakao Map:', error);
                    mapContainer.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; background: #f1f5f9; color: #64748b;">Map unavailable</div>';
                }
            }, 500);

            // Add close button functionality
            const closeBtn = modal.querySelector('.modal-close');
            if (closeBtn) {
                closeBtn.onclick = function() {
                    modal.style.display = 'none';
                    // Restore original modal state
                    if (modalTitle) {
                        modalTitle.textContent = 'Request Dispatch';
                    }
                    if (modalFooter) {
                        modalFooter.style.display = 'flex';
                    }
                };
            }

        } catch (error) {
            console.error('Error loading team details:', error);
            teamListEl.innerHTML = '<div style="text-align: center; padding: 2rem; color: #ef4444;">Failed to load team details. Please try again.</div>';
            showToast('Failed to load team details', 'error');
        }
    }

    function closeTeamDetails() {
        const teamDetailsModal = document.getElementById('teamDetailsModal');
        if (teamDetailsModal) {
            teamDetailsModal.style.display = 'none';
        }
    }

    function closeTeamDetailsModal() {
        const modal = document.getElementById('dispatchRequestModal');
        if (modal) {
            modal.style.display = 'none';

            // Restore modal to original state
            const modalTitle = modal.querySelector('.modal-header h2');
            const modalFooter = modal.querySelector('.modal-footer');

            if (modalTitle) {
                modalTitle.textContent = 'Request Dispatch';
            }
            if (modalFooter) {
                // Restore original footer buttons
                modalFooter.innerHTML = `
                        <button class="btn" onclick="closeDispatchRequestModal()">Cancel</button>
                        <button class="btn btn-primary" onclick="confirmDispatchRequest()">Request Dispatch</button>
                    `;
            }
        }
    }

    function refreshLocation() {
        const dispatchLocationEl = document.getElementById('dispatchLocation');
        if (!dispatchLocationEl) return;

        // Show loading state
        const originalValue = dispatchLocationEl.value;
        dispatchLocationEl.value = 'Refreshing...';

        // Simulate location refresh (in real app, this would fetch from GPS/API)
        setTimeout(() => {
            // Generate random location update
            const locations = [
                'Moving towards incident site',
                'En route - 2 blocks away',
                'Approaching destination',
                'Near incident location',
                'On main road to site'
            ];
            const randomLocation = locations[Math.floor(Math.random() * locations.length)];
            dispatchLocationEl.value = randomLocation;

            showToast('Location updated', 'success');
        }, 1000);
    }

    // Dispatch request modal functions
    let selectedTeamId = null;
    let availableTeams = [];
    let assignedTeamData = null; // Store assigned team data for details popup

    /**
     * Calculate years of experience from join date
     */
    function calculateExperience(joinDate) {
        if (!joinDate) return 0;
        const join = new Date(joinDate);
        const now = new Date();
        const years = (now - join) / (1000 * 60 * 60 * 24 * 365.25);
        return Math.max(0, years);
    }

    /**
     * Analyze transcript content for emergency keywords and context
     */
    function analyzeTranscriptContent() {
        // Get all transcript text
        const transcriptText = transcriptSegments.map(seg => seg.text).join(' ').toLowerCase();
        const callerAge = parseInt(document.getElementById('callerAge')?.value) || 0;

        const analysis = {
            medicalEmergency: false,
            fireEmergency: false,
            traumaEmergency: false,
            rescueNeeded: false,
            crimeInProgress: false,
            naturalDisaster: false,
            multipleVictims: false,
            criticalCondition: false,
            actualInjury: false,
            elderlyOrChild: callerAge > 65 || callerAge < 18,
            estimatedVictimCount: 1,
            keywords: []
        };

        // Crime keywords
        const crimeKeywords = ['ì¹¼', 'ì´', 'ê´´í•œ', 'ê°•ë„', 'í­í–‰', 'ë‚©ì¹˜', 'ë²”ì£„', 'ë„ë‘‘',
            'knife', 'gun', 'weapon', 'robbery', 'assault', 'crime', 'criminal', 'ì«“', 'ìœ„í˜‘'];

        // Medical emergency keywords (actual injury)
        const actualInjuryKeywords = ['í”¼', 'ì¶œí˜ˆ', 'ë‹¤ì³¤', 'ë¶€ìƒ', 'ê³¨ì ˆ', 'í™”ìƒ', 'ì°”ë ¸', 'ë§žì•˜',
            'blood', 'bleeding', 'injured', 'wound', 'fracture', 'burn', 'stabbed', 'hit'];

        // Medical emergency keywords (potential/critical)
        const medicalCriticalKeywords = ['í˜¸í¡', 'ì˜ì‹', 'ì‹¬ìž¥', 'ê°€ìŠ´', 'í†µì¦', 'ì“°ëŸ¬', 'ì•„í”„',
            'breathing', 'unconscious', 'heart', 'chest', 'pain', 'collapsed'];

        // Fire emergency keywords
        const fireKeywords = ['ë¶ˆ', 'í™”ìž¬', 'ì—°ê¸°', 'íƒ€', 'í­ë°œ', 'fire', 'smoke', 'burning', 'explosion', 'ê°€ìŠ¤'];

        // Trauma/accident keywords
        const traumaKeywords = ['ì‚¬ê³ ', 'ì¶”ë½', 'êµí†µ', 'ì¶©ëŒ', 'ë¼', 'ë¶€ë”ª', 'accident', 'fall', 'crash', 'trapped', 'collision'];

        // Rescue keywords
        const rescueKeywords = ['ê°‡í˜”', 'ë¹ ì¡Œ', 'ë§¤ë‹¬', 'êµ¬ì¡°', 'trapped', 'stuck', 'rescue', 'ë¬¼ì—', 'water', 'ì‚°', 'mountain',
            'elevator', 'lift', 'ì—˜ë¦¬ë² ì´í„°', 'ìŠ¹ê°•ê¸°'];

        // Natural disaster keywords
        const disasterKeywords = ['ì§€ì§„', 'í™ìˆ˜', 'ì‚°ì‚¬íƒœ', 'ë¶•ê´´', 'ë¬´ë„ˆ', 'earthquake', 'flood', 'landslide', 'collapse'];

        // Multiple victims indicators
        const multipleIndicators = [
            { pattern: /(\d+)\s*ëª…/g, multiplier: 1 },
            { pattern: /(\d+)\s*people/gi, multiplier: 1 },
            { pattern: /(ì—¬ëŸ¬|ë§Žì€)\s*(ëª…|ì‚¬ëžŒ)/g, multiplier: 3 },
            { pattern: /(multiple|several)\s*people/gi, multiplier: 3 },
            { pattern: /ì „ì²´|ëª¨ë‘|all/gi, multiplier: 5 }
        ];

        // Check crime
        for (const keyword of crimeKeywords) {
            if (transcriptText.includes(keyword)) {
                analysis.crimeInProgress = true;
                analysis.keywords.push(keyword);
            }
        }

        // Check actual injury
        for (const keyword of actualInjuryKeywords) {
            if (transcriptText.includes(keyword)) {
                analysis.actualInjury = true;
                analysis.medicalEmergency = true;
                analysis.keywords.push(keyword);
            }
        }

        // Check medical critical (only if no actual injury)
        if (!analysis.actualInjury) {
            for (const keyword of medicalCriticalKeywords) {
                if (transcriptText.includes(keyword)) {
                    analysis.criticalCondition = true;
                    analysis.medicalEmergency = true;
                    break;
                }
            }
        }

        // Check fire emergency
        for (const keyword of fireKeywords) {
            if (transcriptText.includes(keyword)) {
                analysis.fireEmergency = true;
                analysis.keywords.push(keyword);
            }
        }

        // Check trauma/accident
        for (const keyword of traumaKeywords) {
            if (transcriptText.includes(keyword)) {
                analysis.traumaEmergency = true;
                analysis.keywords.push(keyword);
            }
        }

        // Check rescue needed
        for (const keyword of rescueKeywords) {
            if (transcriptText.includes(keyword)) {
                analysis.rescueNeeded = true;
                analysis.keywords.push(keyword);
            }
        }

        // Check natural disaster
        for (const keyword of disasterKeywords) {
            if (transcriptText.includes(keyword)) {
                analysis.naturalDisaster = true;
                analysis.multipleVictims = true;
                analysis.keywords.push(keyword);
            }
        }

        // Estimate victim count
        let maxVictimCount = 1;
        for (const indicator of multipleIndicators) {
            const matches = transcriptText.match(indicator.pattern);
            if (matches) {
                if (indicator.pattern.source.includes('\\d+')) {
                    // Extract number
                    matches.forEach(match => {
                        const num = parseInt(match.match(/\d+/)[0]);
                        if (num > maxVictimCount) maxVictimCount = num;
                    });
                } else {
                    maxVictimCount = Math.max(maxVictimCount, indicator.multiplier);
                }
                analysis.multipleVictims = maxVictimCount > 1;
            }
        }
        analysis.estimatedVictimCount = maxVictimCount;

        return analysis;
    }

    /**
     * AI recommendation algorithm for dispatch teams
     * Considers: incident type, transcript analysis, team specialization, experience, team size
     */
    function calculateTeamScore(team, incidentType, severityLevel, transcriptAnalysis) {
        let score = 0;
        let reasons = [];
        const memberCount = team.member_count || 0;

        console.log(`\n=== Scoring ${team.name} ===`);
        console.log(`Member count: ${memberCount}`);

        // Calculate average leader experience
        let totalExperience = 0;
        let leaderCount = 0;
        if (team.leader1_join_date) {
            totalExperience += calculateExperience(team.leader1_join_date);
            leaderCount++;
        }
        if (team.leader2_join_date) {
            totalExperience += calculateExperience(team.leader2_join_date);
            leaderCount++;
        }
        const avgExperience = leaderCount > 0 ? totalExperience / leaderCount : 0;

        // Check team specialization
        const hasMedical = (team.leader1_role && (team.leader1_role.toLowerCase().includes('medical') ||
                team.leader1_role.toLowerCase().includes('paramedic'))) ||
            (team.leader2_role && (team.leader2_role.toLowerCase().includes('medical') ||
                team.leader2_role.toLowerCase().includes('paramedic')));

        const hasPolice = (team.leader1_role && team.leader1_role.toLowerCase().includes('police')) ||
            (team.leader2_role && team.leader2_role.toLowerCase().includes('police'));

        const hasFirefighter = (team.leader1_role && team.leader1_role.toLowerCase().includes('fire')) ||
            (team.leader2_role && team.leader2_role.toLowerCase().includes('fire'));

        const hasRescue = (team.leader1_role && team.leader1_role.toLowerCase().includes('rescue')) ||
            (team.leader2_role && team.leader2_role.toLowerCase().includes('rescue'));

        // === INCIDENT TYPE MATCHING WITH STRICT TEAM TYPE FILTERING ===
        // IMPORTANT: Only teams with appropriate specialization should score high

        // Crime situations - ONLY Police teams
        if (incidentType === 'crime' || transcriptAnalysis.crimeInProgress) {
            if (hasPolice) {
                score += 100;  // Strong match
                reasons.push('Specialized crime response team');
                if (transcriptAnalysis.actualInjury && hasMedical) {
                    score += 30;
                    reasons.push('Medical staff available for injured victims');
                }
            } else {
                score -= 1000; // Effectively eliminate non-police teams
            }
        }

        // Disaster situations (fire/explosion/natural disaster) - ONLY Firefighter teams
        else if (incidentType === 'disaster' || transcriptAnalysis.fireEmergency || transcriptAnalysis.naturalDisaster) {
            if (hasFirefighter) {
                score += 100;  // Strong match
                reasons.push('Specialized fire/disaster response team');
                if (memberCount >= 4) {
                    score += 20;
                    reasons.push(`${memberCount}-member team - Suitable for large-scale disaster`);
                }
            } else {
                score -= 1000; // Effectively eliminate non-firefighter teams
            }
        }

        // Rescue operations - BOTH Rescue teams AND Firefighter teams
        else if (incidentType === 'rescue' || transcriptAnalysis.rescueNeeded) {
            if (hasRescue) {
                score += 120;  // Strongest preference
                reasons.push('Specialized rescue operations team');
                if (avgExperience >= 5) {
                    score += 30;
                    reasons.push(`${avgExperience.toFixed(1)} years rescue experience`);
                }
            } else if (hasFirefighter) {
                // Firefighters commonly handle rescue situations in real-world scenarios
                score += 110;
                reasons.push('Fire team - Equipped for rescue operations');
                if (memberCount >= 4) {
                    score += 20;
                    reasons.push(`${memberCount}-member team - Suitable for complex rescue`);
                }
            } else {
                score -= 1000; // Eliminate teams without rescue capability
            }
        }

        // Medical emergencies - ONLY Medical teams
        else if (incidentType === 'medical' || transcriptAnalysis.medicalEmergency) {
            if (hasMedical) {
                score += 100;  // Strong match
                if (transcriptAnalysis.actualInjury) {
                    reasons.push('Medical emergency - EMT team required');
                    score += 20;
                } else if (transcriptAnalysis.criticalCondition) {
                    reasons.push('Critical condition - EMT standby');
                    score += 15;
                } else {
                    reasons.push('Medical emergency response team');
                }
            } else {
                score -= 1000; // Eliminate non-medical teams
            }
        }

        // Traffic accidents - Medical OR Police teams
        else if (incidentType === 'traffic' || transcriptAnalysis.traumaEmergency) {
            if (hasMedical) {
                score += 80;
                reasons.push('Traffic accident - Medical response for injuries');
                if (memberCount >= 3) {
                    score += 15;
                    reasons.push('Sufficient personnel for accident scene');
                }
            } else if (hasPolice) {
                score += 70;
                reasons.push('Traffic accident - Scene control and investigation');
            } else {
                score -= 1000; // Eliminate other teams
            }
        }

        // Other (non-emergency/inquiry) - Allow all teams but with lower priority
        else if (incidentType === 'other') {
            score += 20;  // Low base score for all teams
            reasons.push('General response team');
        }

        // === TEAM SIZE MATCHING ===
        const requiredTeamSize = transcriptAnalysis.estimatedVictimCount;
        console.log(`Required team size: ${requiredTeamSize}, Incident type: ${incidentType}, Crime in progress: ${transcriptAnalysis.crimeInProgress}`);

        // PRIORITY 1: Crime situations - ALWAYS prefer smaller teams for quick response
        if (incidentType === 'crime' || transcriptAnalysis.crimeInProgress) {
            console.log(`ðŸš¨ CRIME SITUATION DETECTED - Member count: ${memberCount}`);
            // Crime situations need quick, efficient response - prefer small teams
            if (memberCount >= 2 && memberCount <= 4) {
                score += 100; // VERY strong preference for small teams
                console.log(`  âœ… Small team bonus: +100, Total so far: ${score}`);
                if (!reasons.some(r => r.includes('member'))) {
                    reasons.push(`${memberCount}-member rapid response team`);
                }
                // Extra bonus for exactly 3 members
                if (memberCount === 3) {
                    score += 40; // Strong bonus for ideal team size
                    console.log(`  âœ… Perfect 3-member team bonus: +40, Total so far: ${score}`);
                }
            } else if (memberCount === 5 || memberCount === 6) {
                score -= 80; // Heavy penalty for medium teams
                console.log(`  âŒ Medium team penalty: -80, Total so far: ${score}`);
            } else if (memberCount > 6) {
                score -= 200; // MASSIVE penalty for oversized teams in crimes - makes it impossible to win
                console.log(`  âŒâŒâŒ OVERSIZED team penalty: -200, Total so far: ${score}`);
            }
        }
        // PRIORITY 2: Natural disasters or very severe situations
        else if (transcriptAnalysis.naturalDisaster || severityLevel >= 4) {
            // Large-scale emergency - need big teams
            if (memberCount >= 5) {
                score += 30;
                if (!reasons.some(r => r.includes('Large team'))) {
                    reasons.push(`${memberCount}-member large team - Large-scale disaster response`);
                }
            } else {
                score -= 25;
            }
        }
        // PRIORITY 3: Multiple victims
        else if (requiredTeamSize > 3) {
            // Multiple victims - need adequate team
            if (memberCount >= requiredTeamSize) {
                score += 20;
                if (!reasons.some(r => r.includes('member'))) {
                    reasons.push(`${memberCount}-member team for ${requiredTeamSize} victims`);
                }
            } else if (memberCount >= 3) {
                score += 10;
            } else {
                score -= 15; // Penalty for undersized team
            }
        }
        // PRIORITY 4: General small emergencies
        else {
            // General small emergency - prefer smaller teams
            if (memberCount >= 2 && memberCount <= 4) {
                score += 15;
                if (!reasons.some(r => r.includes('member'))) {
                    reasons.push(`${memberCount}-member appropriately sized team`);
                }
            } else if (memberCount > 4) {
                score -= 10; // Penalty for oversized team
            }
        }

        // === EXPERIENCE BONUS ===
        if (severityLevel >= 3 && avgExperience >= 5 && !reasons.some(r => r.includes('experience'))) {
            score += 20;
            reasons.push(`Team leader with ${avgExperience.toFixed(1)} years experience`);
        } else if (avgExperience >= 3 && !reasons.some(r => r.includes('experience'))) {
            score += 10;
        }

        // === SEVERITY LEVEL ADJUSTMENT ===
        if (severityLevel >= 4) {
            score += 15;
        } else if (severityLevel >= 2) {
            score += 5;
        }

        console.log(`ðŸŽ¯ FINAL SCORE for ${team.name}: ${score}\n`);
        return { score, reasons: reasons.slice(0, 3) }; // Return top 3 reasons
    }

    async function showDispatchRequestModal() {
        const modal = document.getElementById('dispatchRequestModal');
        const teamListEl = document.getElementById('teamSelectionList');
        const modalTitle = modal ? modal.querySelector('.modal-header h2') : null;
        const modalFooter = modal ? modal.querySelector('.modal-footer') : null;

        if (!modal || !teamListEl) return;

        // Restore modal to Request Dispatch state
        if (modalTitle) {
            modalTitle.textContent = 'Request Dispatch';
        }
        if (modalFooter) {
            // Restore original footer buttons
            modalFooter.innerHTML = `
                    <button class="btn" onclick="closeDispatchRequestModal()">Cancel</button>
                    <button class="btn btn-primary" onclick="confirmDispatchRequest()">Request Dispatch</button>
                `;
        }

        // Clear previous selection
        selectedTeamId = null;

        // Show loading state
        teamListEl.innerHTML = '<div style="text-align: center; padding: 2rem; color: #64748b;">Loading teams...</div>';
        modal.style.display = 'flex';

        try {
            // Get current incident type and severity level
            const incidentType = document.getElementById('incidentType')?.value || '';
            const severityLevel = parseInt(document.getElementById('severityLevel')?.value || '1');

            // Analyze transcript content for context-aware recommendations
            const transcriptAnalysis = analyzeTranscriptContent();
            console.log('Transcript analysis:', transcriptAnalysis);

            // Fetch dispatch teams from API (type='dispatch' only)
            const response = await fetch('/api/units');
            const result = await response.json();

            if (!result.success) {
                throw new Error(result.error || 'Failed to fetch teams');
            }

            // Filter only dispatch teams (exclude intake desks)
            const dispatchTeams = result.data.filter(team => team.type === 'dispatch');

            // Fetch members for each team to get accurate member count and details
            const teamsWithMembers = await Promise.all(dispatchTeams.map(async (team) => {
                try {
                    const membersResponse = await fetch(`/api/units/${team.id}/members`);
                    const membersResult = await membersResponse.json();

                    if (membersResult.success) {
                        team.membersList = membersResult.data || [];
                    } else {
                        team.membersList = [];
                    }
                } catch (err) {
                    console.error('Error fetching members for team:', team.id, err);
                    team.membersList = [];
                }
                return team;
            }));

            // Calculate AI scores for each team using transcript analysis
            const teamsWithScores = teamsWithMembers.map(team => {
                const scoreData = calculateTeamScore(team, incidentType, severityLevel, transcriptAnalysis);
                return {
                    ...team,
                    aiScore: scoreData.score,
                    aiReasons: scoreData.reasons
                };
            });

            // Sort by AI score (highest first)
            teamsWithScores.sort((a, b) => b.aiScore - a.aiScore);

            // Mark top team as AI recommended (if score is reasonable)
            let recommendedTeam = null;
            if (teamsWithScores.length > 0 && teamsWithScores[0].aiScore >= 30) {
                teamsWithScores[0].aiRecommended = true;
                recommendedTeam = teamsWithScores[0];
            }

            availableTeams = teamsWithScores;
            console.log('Teams with scores:', teamsWithScores.map(t => ({
                name: t.name,
                score: t.aiScore,
                reasons: t.aiReasons
            })));

            // Build team cards
            if (availableTeams.length === 0) {
                teamListEl.innerHTML = '<div style="text-align: center; padding: 2rem; color: #64748b;">No dispatch teams available</div>';
                return;
            }

            teamListEl.innerHTML = availableTeams.map(team => {
                const allMembers = team.membersList || [];
                // Exclude leader and deputy from members list
                const membersList = allMembers.filter(member =>
                    member.name !== team.leader1_name &&
                    member.name !== team.leader2_name
                );
                const memberCount = membersList.length;

                return `
                        <div class="team-card ${team.aiRecommended ? 'recommended' : ''}" onclick="selectTeam('${team.id}')">
                            ${team.aiRecommended ? `
                                <div class="ai-recommended-badge">
                                    <svg class="ai-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2L2 7l10 5 10-5-10-5z"/><path d="M2 17l10 5 10-5M2 12l10 5 10-5"/></svg>
                                    AI Recommended (Score: ${team.aiScore})
                                </div>
                            ` : ''}
                            <div class="team-card-header">
                                <input type="radio" name="teamSelection" class="team-radio" id="radio-${team.id}" value="${team.id}">
                                <div class="team-info">
                                    <div class="team-name">${team.name || 'Unnamed Team'}</div>
                                    <span class="team-status">Available</span>
                                </div>
                            </div>
                            <div class="team-details">
                                <div class="team-detail-row">
                                    <span class="team-detail-label">Leader:</span>
                                    <span class="team-detail-value">${team.leader1_name || '-'}${team.leader1_phone ? ` (${team.leader1_phone})` : ''}</span>
                                </div>
                                <div class="team-detail-row">
                                    <span class="team-detail-label">Deputy:</span>
                                    <span class="team-detail-value">${team.leader2_name || '-'}${team.leader2_phone ? ` (${team.leader2_phone})` : ''}</span>
                                </div>
                                <div class="team-detail-row">
                                    <span class="team-detail-label">Vehicle:</span>
                                    <span class="team-detail-value" id="selectedTeamVehicle">${getVehicleType(team)}</span>
                                </div>
                                <div class="team-members">
                                    <div class="team-detail-label" style="margin-bottom: 0.25rem;">Members (${memberCount}):</div>
                                    ${membersList.length > 0
                    ? membersList.map(member => {
                        return `<div class="team-member">â€¢ ${member.name || 'Unknown'} (${member.role || 'Operator'})</div>`;
                    }).join('')
                    : '<div class="team-member" style="color: #94a3b8;">ë°°ì¹˜ëœ ëŒ€ì› ì—†ìŒ</div>'
                }
                                </div>
                                ${team.aiRecommended && team.aiReasons && team.aiReasons.length > 0
                    ? `<div style="margin-top: 0.75rem; padding: 0.75rem; background: linear-gradient(135deg, #667eea15 0%, #764ba215 100%); border-left: 3px solid #667eea; border-radius: 0.375rem;">
                                        <div style="font-size: 0.75rem; font-weight: 600; color: #4c51bf; margin-bottom: 0.375rem; display: flex; align-items: center; gap: 0.25rem;">
                                            <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M12 16v-4"/><path d="M12 8h.01"/></svg>
                                            AI Recommendation Reasons
                                        </div>
                                        ${team.aiReasons.map(reason => `<div style="font-size: 0.8rem; color: #5a67d8; margin-bottom: 0.25rem;">â€¢ ${reason}</div>`).join('')}
                                    </div>`
                    : ''}
                            </div>
                        </div>
                    `;
            }).join('');

            // Auto-select AI recommended team
            if (recommendedTeam) {
                // Use setTimeout to ensure DOM is updated before selecting
                setTimeout(() => {
                    selectedTeamId = recommendedTeam.id;
                    const recommendedCard = document.querySelector(`.team-card.recommended`);
                    if (recommendedCard) {
                        recommendedCard.classList.add('selected');
                    }
                    const radio = document.getElementById(`radio-${recommendedTeam.id}`);
                    if (radio) {
                        radio.checked = true;
                    }
                }, 10);
            }

        } catch (error) {
            console.error('Error loading dispatch teams:', error);
            teamListEl.innerHTML = '<div style="text-align: center; padding: 2rem; color: #ef4444;">Failed to load teams. Please try again.</div>';
            showToast('Failed to load dispatch teams', 'error');
        }
    }

    function closeDispatchRequestModal() {
        const modal = document.getElementById('dispatchRequestModal');
        if (modal) {
            modal.style.display = 'none';

            // Restore modal to original state
            const modalTitle = modal.querySelector('.modal-header h2');
            const modalFooter = modal.querySelector('.modal-footer');

            if (modalTitle) {
                modalTitle.textContent = 'Request Dispatch';
            }
            if (modalFooter) {
                // Restore original footer buttons
                modalFooter.innerHTML = `
                        <button class="btn" onclick="closeDispatchRequestModal()">Cancel</button>
                        <button class="btn btn-primary" onclick="confirmDispatchRequest()">Request Dispatch</button>
                    `;
            }
        }
        selectedTeamId = null;
    }

    function selectTeam(teamId) {
        selectedTeamId = teamId;

        // Update all team cards
        const cards = document.querySelectorAll('.team-card');
        cards.forEach(card => card.classList.remove('selected'));

        // Select the clicked card
        const selectedCard = event.currentTarget;
        selectedCard.classList.add('selected');

        // Check the radio button
        const radio = document.getElementById(`radio-${teamId}`);
        if (radio) {
            radio.checked = true;
        }
    }

    async function confirmDispatchRequest() {
        if (!selectedTeamId) {
            showToast('Please select a team first', 'warning');
            return;
        }

        const selectedTeam = availableTeams.find(t => t.id === selectedTeamId);
        if (!selectedTeam) {
            showToast('Team not found', 'error');
            return;
        }

        try {
            // TODO: Call API to insert into dispatch table
            // For now, simulate the dispatch request

            // Get vehicle from popup (hardcoded sample value)
            const vehicleText = document.getElementById('selectedTeamVehicle')?.textContent || 'Emergency Vehicle #101';

            // Update dispatch status fields
            document.getElementById('dispatchTeam').value = selectedTeam.name || 'Unknown Team';
            document.getElementById('dispatchVehicle').value = vehicleText;
            document.getElementById('dispatchTime').value = formatTime(new Date());
            document.getElementById('dispatchStatus').value = 'requested';

            // Update Dispatch Ordered time in timeline
            const dispatchOrderedTime = new Date();
            const dispatchOrderedTimeEl = document.getElementById('dispatchOrderedTime');
            if (dispatchOrderedTimeEl) {
                dispatchOrderedTimeEl.textContent = formatTime(dispatchOrderedTime);
            }

            // Calculate Dispatch Arrived time (Dispatch Ordered + 10 minutes)
            const dispatchArrivedTime = new Date(dispatchOrderedTime);
            dispatchArrivedTime.setMinutes(dispatchArrivedTime.getMinutes() + 10);

            // Update Dispatch Arrived time in timeline
            const dispatchArrivedTimeEl = document.getElementById('dispatchArrivedTime');
            if (dispatchArrivedTimeEl) {
                dispatchArrivedTimeEl.textContent = formatTime(dispatchArrivedTime);
            }

            // Set ETA (same as Dispatch Arrived time)
            document.getElementById('dispatchETA').value = formatTime(dispatchArrivedTime);

            // Set initial location
            document.getElementById('dispatchLocation').value = 'Departing from station';

            // Update team detail modal with selected team info
            const memberCount = selectedTeam.membersList ? selectedTeam.membersList.length : 0;
            document.getElementById('teamNumber').value = selectedTeam.vehicle || '-';
            document.getElementById('teamName').value = selectedTeam.name || 'Unknown Team';
            document.getElementById('teamLeader').value = selectedTeam.leader1_name
                ? `${selectedTeam.leader1_name}${selectedTeam.leader1_phone ? ` (${selectedTeam.leader1_phone})` : ''}`
                : '-';
            document.getElementById('teamDeputy').value = selectedTeam.leader2_name
                ? `${selectedTeam.leader2_name}${selectedTeam.leader2_phone ? ` (${selectedTeam.leader2_phone})` : ''}`
                : '-';

            // Store assigned team data for showing details later
            assignedTeamData = selectedTeam;

            showToast(`Dispatch request sent to ${selectedTeam.name}`, 'success');
            closeDispatchRequestModal();

        } catch (error) {
            console.error('Error dispatching team:', error);
            showToast('Failed to dispatch team', 'error');
        }
    }

    function formatTime(date) {
        const hours = String(date.getHours()).padStart(2, '0');
        const minutes = String(date.getMinutes()).padStart(2, '0');
        const seconds = String(date.getSeconds()).padStart(2, '0');
        return `${hours}:${minutes}:${seconds}`;
    }

    // Get vehicle type based on team role
    function getVehicleType(team) {
        const leader1Role = (team.leader1_role || '').toLowerCase();
        const leader2Role = (team.leader2_role || '').toLowerCase();
        const teamName = (team.name || '').toLowerCase();

        // Check for police
        if (leader1Role.includes('police') || leader2Role.includes('police') ||
            teamName.includes('police') || teamName.includes('ê²½ì°°') || teamName.includes('crime')) {
            return 'Police Vehicle #101';
        }
        // Check for medical/paramedic
        else if (leader1Role.includes('medical') || leader1Role.includes('paramedic') ||
            leader2Role.includes('medical') || leader2Role.includes('paramedic') ||
            teamName.includes('medical') || teamName.includes('êµ¬ê¸‰') || teamName.includes('ì˜ë£Œ')) {
            return 'Ambulance #205';
        }
        // Check for fire
        else if (leader1Role.includes('fire') || leader2Role.includes('fire') ||
            teamName.includes('fire') || teamName.includes('ì†Œë°©')) {
            return 'Fire Truck #303';
        }
        // Check for rescue
        else if (leader1Role.includes('rescue') || leader2Role.includes('rescue') ||
            teamName.includes('rescue') || teamName.includes('êµ¬ì¡°')) {
            return 'Rescue Vehicle #404';
        }
        // Default
        else {
            return 'Emergency Vehicle #101';
        }
    }

    // Create initial emergency record when call starts (for checklist saving during call)
    async function createInitialEmergency() {
        if (currentEmergencyId) {
            console.log('Emergency record already exists:', currentEmergencyId);
            return; // Already created
        }

        try {
            // Get operator ID from session
            const user = JSON.parse(sessionStorage.getItem('user'));
            const operatorId = user ? user.id : null;

            if (!operatorId) {
                console.error('Operator ID not found in session');
                return;
            }

            // Get language from detected language or default to Korean
            const language = detectedLanguage || 'ko';

            // Get caller information (from upload result)
            const callerPhoneNumber = '010-8734-2910';
            const callerName = 'Minsu Kim';

            // Get call started time
            const callStartedAtMs = callStartTime ? callStartTime.getTime() : Date.now();

            console.log('Creating initial emergency record:', {
                callerPhoneNumber,
                operatorId,
                language,
                callStartedAtMs
            });

            // Call complete emergency API with minimal data
            const response = await fetch('/api/auth/complete-emergency', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    callerPhoneNumber: callerPhoneNumber,
                    callerName: callerName,
                    operatorId: operatorId,
                    language: language,
                    transcript: '', // Empty initially
                    totalDurationMs: 0,
                    speakersCount: 0,
                    utterancesCount: 0,
                    incidentType: null,
                    callerLocation: null,
                    mediaAssetId: mediaAssetId,
                    callStartedAtMs: callStartedAtMs,
                    callEndedAtMs: null // Not ended yet
                })
            });

            const result = await response.json();

            if (result.success) {
                // Store emergency ID and caller ID for checklist saving
                currentEmergencyId = result.emergencyId;
                currentCallerId = result.callerId;
                console.log('Initial emergency record created:', result.emergencyId);
            } else {
                console.error('Failed to create initial emergency:', result.message);
            }
        } catch (error) {
            console.error('Error creating initial emergency:', error);
        }
    }

    // Complete emergency call and save to database
    async function completeEmergency() {
        if (!transcriptSegments || transcriptSegments.length === 0) {
            console.warn('No transcript segments available');
            return;
        }

        try {
            // Calculate call statistics
            const lastSegment = transcriptSegments[transcriptSegments.length - 1];
            const totalDurationMs = Math.round(lastSegment.endTime * 1000); // Convert to milliseconds

            // Count unique speakers
            const speakersCount = new Set(transcriptSegments.map(seg => seg.speakerId)).size;

            // Count total utterances
            const utterancesCount = transcriptSegments.length;

            // Get incident type from UI
            const incidentTypeEl = document.getElementById('incidentType');
            const incidentType = incidentTypeEl ? incidentTypeEl.value : null;

            // Get caller location from UI
            const callerLocationEl = document.getElementById('incidentLocation');
            const callerLocation = callerLocationEl ? callerLocationEl.value : null;

            // Get call ended time (from timeline)
            const callEndedAtMs = callEndTime ? callEndTime.getTime() : Date.now();

            console.log('Completing emergency with data:', {
                emergencyId: currentEmergencyId,
                totalDurationMs,
                speakersCount,
                utterancesCount,
                incidentType,
                callerLocation,
                callEndedAtMs,
                transcriptLength: accumulatedTranscript.length
            });

            // Complete the emergency record with final details
            if (currentEmergencyId) {
                const user = JSON.parse(sessionStorage.getItem('user'));
                const operatorId = user ? user.id : null;

                const completeData = {
                    emergencyId: currentEmergencyId,
                    callerPhoneNumber: '010-8734-2910',
                    operatorId: operatorId,
                    language: detectedLanguage || 'ko',
                    transcript: accumulatedTranscript,
                    totalDurationMs: totalDurationMs,
                    speakersCount: speakersCount,
                    utterancesCount: utterancesCount,
                    incidentType: incidentType,
                    callerLocation: callerLocation,
                    callStartedAtMs: callStartTime ? callStartTime.getTime() : null,
                    callEndedAtMs: callEndedAtMs,
                    isUpdate: true  // Flag to indicate this is an update
                };

                const response = await fetch('/api/auth/complete-emergency', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(completeData)
                });

                const result = await response.json();

                if (result.success) {
                    console.log('Emergency completed successfully:', currentEmergencyId);

                    // Update UI with risk level from backend
                    if (result.riskLevel !== undefined && result.riskLevel !== null) {
                        const severityLevelEl = document.getElementById('severityLevel');
                        if (severityLevelEl) {
                            severityLevelEl.value = result.riskLevel;
                            console.log('Updated Severity Level to:', result.riskLevel);
                        }
                    }

                    if (result.riskLevelReason) {
                        console.log('Risk Level Reason:', result.riskLevelReason);
                    }
                } else {
                    console.error('Failed to complete emergency:', result.message);
                    showToast('Failed to complete emergency record: ' + result.message, 'error');
                }
            } else {
                console.warn('No emergency ID found, skipping completion');
            }
        } catch (error) {
            console.error('Error completing emergency:', error);
            showToast('Error updating emergency record. Please check the console for details.', 'error');
        }
    }

    // Close modals on outside click
    window.onclick = function(event) {
        if (event.target.classList.contains('modal')) {
            event.target.style.display = 'none';
        }
    }

    // Logout function
    function logout() {
        sessionStorage.removeItem('user');
        window.location.href = 'ecall-intro.html';
    }

    // Incoming Call Simulation
    let incomingCallTimer = null;
    let incomingCallTimer2 = null;
    let incomingCallTimer3 = null;
    let ringtoneAudio = null;
    let ringtoneInterval = null;
    let ringtoneInterval2 = null;

    // First call (crime)
    const INCOMING_CALL_NUMBER = '010-1234-5678';
    const INCOMING_CALLER_NAME = 'ê¹€ì—°ì„¸';
    const INCOMING_CALLER_AGE = 30;
    const INCOMING_CALLER_GENDER = 'ì—¬ìž';

    // Second call (disaster)
    const INCOMING_CALL_NUMBER_2 = '010-1111-2222';
    const INCOMING_CALLER_NAME_2 = 'John Doe';
    const INCOMING_CALLER_AGE_2 = 35;
    const INCOMING_CALLER_GENDER_2 = 'ë‚¨ìž';

    // Third call (rescue)
    const INCOMING_CALL_NUMBER_3 = '010-2222-3333';
    const INCOMING_CALLER_NAME_3 = 'Jane Smith';
    const INCOMING_CALLER_AGE_3 = 28;
    const INCOMING_CALLER_GENDER_3 = 'ì—¬ìž';

    // Get ringtone audio element
    let audioInitialized = false;
    window.addEventListener('DOMContentLoaded', function() {
        ringtoneAudio = document.getElementById('ringtoneAudio');
        if (ringtoneAudio) {
            ringtoneAudio.volume = 0.3;
            ringtoneAudio.loop = false;
        }

        // Initialize audio on first user interaction
        const initAudio = () => {
            if (!audioInitialized && ringtoneAudio) {
                // Try to play and immediately pause to "unlock" audio
                ringtoneAudio.play().then(() => {
                    ringtoneAudio.pause();
                    ringtoneAudio.currentTime = 0;
                    audioInitialized = true;
                    console.log('Audio initialized successfully');
                }).catch(err => {
                    console.log('Audio initialization failed:', err);
                });
            }
        };

        // Listen for any user interaction
        document.addEventListener('click', initAudio, { once: true });
        document.addEventListener('keydown', initAudio, { once: true });
        document.addEventListener('touchstart', initAudio, { once: true });
    });

    // Audio files for each call
    const AUDIO_FILE_CALL_1 = 'https://oeeffpldhwajfmiidayr.supabase.co/storage/v1/object/public/ecall-audio/ecall_simulation_sample_crime.mp3';
    const AUDIO_FILE_CALL_2 = 'https://oeeffpldhwajfmiidayr.supabase.co/storage/v1/object/public/ecall-audio/ecall_simulation_sample_disaster.mp3';
    const AUDIO_FILE_CALL_3 = 'https://oeeffpldhwajfmiidayr.supabase.co/storage/v1/object/public/ecall-audio/ecall_simulation_sample_rescue.mp3';

    // Get audio URL for specific call
    function getAudioUrlForCall(callNumber) {
        const audioUrl = callNumber === 1 ? AUDIO_FILE_CALL_1 :
            callNumber === 2 ? AUDIO_FILE_CALL_2 :
                AUDIO_FILE_CALL_3;
        console.log(`Selected audio file for call ${callNumber}: ${audioUrl}`);
        return audioUrl;
    }

    // Start incoming call timers on page load
    window.addEventListener('load', function() {
        console.log('Page loaded, starting incoming call timers...');
        incomingCallTimer = setTimeout(() => showIncomingCall(1), 1000); // First call at 1 second
        incomingCallTimer2 = setTimeout(() => showIncomingCall(2), 2000); // Second call at 2 seconds
        incomingCallTimer3 = setTimeout(() => showIncomingCall(3), 3000); // Third call at 3 seconds
    });

    function showIncomingCall(callNumber) {
        console.log(`Showing incoming call notification ${callNumber}`);
        const notificationId = callNumber === 1 ? 'incomingCallNotification' :
            callNumber === 2 ? 'incomingCallNotification2' :
                'incomingCallNotification3';
        const notification = document.getElementById(notificationId);
        if (notification) {
            notification.classList.add('show');
        }

        // Play ringtone repeatedly for first call only (to avoid double ringing)
        if (callNumber === 1 && ringtoneAudio) {
            ringtoneInterval = setInterval(() => {
                ringtoneAudio.currentTime = 0;
                ringtoneAudio.play().catch(err => {
                    console.log('Could not play ringtone:', err);
                });
            }, 1000);
        }
    }

    function declineCall(callNumber) {
        console.log(`Call ${callNumber} declined`);

        // Hide all three notifications when any is declined
        const notification1 = document.getElementById('incomingCallNotification');
        const notification2 = document.getElementById('incomingCallNotification2');
        const notification3 = document.getElementById('incomingCallNotification3');
        if (notification1) notification1.classList.remove('show');
        if (notification2) notification2.classList.remove('show');
        if (notification3) notification3.classList.remove('show');

        // Stop ringtone (only call 1 has ringtone)
        if (ringtoneInterval) {
            clearInterval(ringtoneInterval);
            ringtoneInterval = null;
        }
        if (ringtoneAudio) {
            ringtoneAudio.pause();
            ringtoneAudio.currentTime = 0;
        }

        const phoneNumber = callNumber === 1 ? INCOMING_CALL_NUMBER :
            callNumber === 2 ? INCOMING_CALL_NUMBER_2 :
                INCOMING_CALL_NUMBER_3;
        showToast(`Call from ${phoneNumber} declined`, 'info');

        // Do not schedule next call automatically after decline
    }

    async function acceptCall(callNumber) {
        console.log(`Call ${callNumber} accepted`);

        // Hide all three notifications
        const notification1 = document.getElementById('incomingCallNotification');
        const notification2 = document.getElementById('incomingCallNotification2');
        const notification3 = document.getElementById('incomingCallNotification3');
        if (notification1) notification1.classList.remove('show');
        if (notification2) notification2.classList.remove('show');
        if (notification3) notification3.classList.remove('show');

        // Stop ringtone
        if (ringtoneInterval) {
            clearInterval(ringtoneInterval);
            ringtoneInterval = null;
        }
        if (ringtoneAudio) {
            ringtoneAudio.pause();
            ringtoneAudio.currentTime = 0;
        }

        // Get call-specific data
        const phoneNumber = callNumber === 1 ? INCOMING_CALL_NUMBER :
            callNumber === 2 ? INCOMING_CALL_NUMBER_2 :
                INCOMING_CALL_NUMBER_3;
        const callerName = callNumber === 1 ? INCOMING_CALLER_NAME :
            callNumber === 2 ? INCOMING_CALLER_NAME_2 :
                INCOMING_CALLER_NAME_3;
        const callerAge = callNumber === 1 ? INCOMING_CALLER_AGE :
            callNumber === 2 ? INCOMING_CALLER_AGE_2 :
                INCOMING_CALLER_AGE_3;
        const callerGender = callNumber === 1 ? INCOMING_CALLER_GENDER :
            callNumber === 2 ? INCOMING_CALLER_GENDER_2 :
                INCOMING_CALLER_GENDER_3;

        // Update caller number in UI
        const callerNumberInput = document.getElementById('callerNumber');
        if (callerNumberInput) {
            callerNumberInput.value = phoneNumber;
        }

        showToast(`Call connected from ${callerName} - Loading audio...`, 'success');

        try {
            // Get audio file for specific call
            const audioUrl = getAudioUrlForCall(callNumber);

            // Fetch audio file from Supabase storage
            console.log('Fetching audio from:', audioUrl);
            const response = await fetch(audioUrl);

            if (!response.ok) {
                throw new Error(`Failed to fetch audio: ${response.status} ${response.statusText}`);
            }

            const blob = await response.blob();
            console.log('Audio fetched, size:', blob.size, 'type:', blob.type);

            // Create File object from blob
            const audioFile = new File([blob], 'emergency-call.mp3', { type: 'audio/mpeg' });

            // Get operator ID from session
            const user = JSON.parse(sessionStorage.getItem('user'));
            const operatorId = user ? user.id : null;

            // Create FormData - same as uploadFile()
            const formData = new FormData();
            formData.append('file', audioFile);
            formData.append('minSpeakers', '1');
            formData.append('maxSpeakers', '5');
            formData.append('language', 'en-US'); // English audio sample - skip auto-detection

            // Add caller and operator information
            formData.append('callerPhoneNumber', phoneNumber);
            formData.append('callerName', callerName);
            formData.append('callerAge', callerAge);
            formData.append('callerGender', callerGender);
            if (operatorId) {
                formData.append('operatorId', operatorId);
            }

            // Call Clova API - same endpoint as uploadFile()
            const clovaResponse = await fetch('/api/voice/upload/clova', {
                method: 'POST',
                body: formData
            });

            const result = await clovaResponse.json();
            console.log('Clova API result:', result);
            console.log('Speaker segments:', result.speakerSegments);

            if (result.success && result.speakerSegments) {
                transcriptSegments = result.speakerSegments;
                console.log('Transcript segments loaded:', transcriptSegments.length, 'segments');

                // Store language if returned
                if (result.language) {
                    detectedLanguage = result.language;
                    console.log('Detected language:', detectedLanguage);
                }

                // Store media asset ID if returned
                if (result.mediaAssetId) {
                    mediaAssetId = result.mediaAssetId;
                    console.log('Media asset ID:', mediaAssetId);
                }

                // Create audio element for playback
                try {
                    const audioElementUrl = URL.createObjectURL(audioFile);
                    audioElement = new Audio(audioElementUrl);

                    // Reset displayed segments
                    displayedSegmentIndexes.clear();

                    // Sync transcript with audio playback
                    audioElement.addEventListener('timeupdate', () => {
                        syncTranscriptWithAudio();
                    });

                    // Call start event - change status to on-call
                    audioElement.addEventListener('play', () => {
                        onCallStart();
                    });

                    // Remove active class when audio ends
                    audioElement.addEventListener('ended', () => {
                        const speakerBtn = document.getElementById('speakerBtn');
                        if (speakerBtn) {
                            speakerBtn.classList.remove('active');
                        }
                        // Call end event - change status to available
                        onCallEnd();
                    });

                    // Auto-play audio and activate speaker button
                    audioElement.play();
                    const speakerBtn = document.getElementById('speakerBtn');
                    if (speakerBtn) {
                        speakerBtn.classList.add('active');
                    }
                } catch (audioError) {
                    console.error('Error creating audio element:', audioError);
                }

                // Hide empty state
                const emptyState = document.getElementById('emptyState');
                if (emptyState) {
                    emptyState.classList.add('hidden');
                }

                // Reset timer
                stopTimer();
                seconds = 0;

                // Initialize transcript display
                initializeTranscriptDisplay();

                showToast('Call audio loaded successfully', 'success');
            } else {
                showToast('Failed to process audio file: ' + (result.error || result.message), 'error');
            }
        } catch (error) {
            console.error('Error loading call audio:', error);
            showToast('Failed to load call audio: ' + error.message, 'error');
        }
    }

    // Response Manual íŒì—… ì œì–´ í•¨ìˆ˜ (ìˆ˜ì •: ë°ì´í„° ë¡œë”© ë¡œì§ ì¶”ê°€)
    function showResponseManualModal(manualName) {
        const modal = document.getElementById('responseManualModal');
        const contentDiv = document.getElementById('manualModalContent');
        const titleEl = document.getElementById('manualModalTitle');
        const nameEl = document.getElementById('clickedManualName');

        // 1. í´ë¦­ëœ í•­ëª©ì˜ ì´ë¦„ì„ ì„¤ëª…ì— í‘œì‹œ
        nameEl.textContent = manualName;
        titleEl.textContent = 'Response Manual Detail'; // ê¸°ë³¸ ì œëª© ìœ ì§€

        // 2. ì½˜í…ì¸  í™•ì¸ ë° ì‚½ìž…
        const manualData = manualContents[manualName];

        if (manualData && manualData.content) {
            // ë°ì´í„°ê°€ ìžˆì„ ê²½ìš° (CPR Procedure): ì‹¤ì œ ì½˜í…ì¸  ì‚½ìž…
            contentDiv.innerHTML = manualData.content;
            titleEl.textContent = manualData.title; // ì œëª©ì„ ìƒì„¸ ì œëª©ìœ¼ë¡œ ë³€ê²½
            contentDiv.style.textAlign = 'left';
            contentDiv.style.padding = '10px';
            contentDiv.style.background = 'white'; // ë°°ê²½ìƒ‰ ì œê±°

        } else {
            // ë°ì´í„°ê°€ ì—†ì„ ê²½ìš° (ë‹¤ë¥¸ ë§¤ë‰´ì–¼): ìž„ì‹œ ì•ˆë‚´ í…ìŠ¤íŠ¸ í‘œì‹œ
            contentDiv.innerHTML = `
                    <h4 style="color: #1e293b;">ì„ íƒëœ ë§¤ë‰´ì–¼: ${manualName}</h4>
                    <p style="margin-top: 10px; color: #64748b;">(í˜„ìž¬ **'${manualName}'**ì˜ ìƒì„¸ ë°ì´í„° ì—°ê²°ì€ ìƒëžµë˜ì—ˆìŠµë‹ˆë‹¤. CPR ë§¤ë‰´ì–¼ì„ ì°¸ê³ í•˜ì—¬ ì´ê³³ì— ë‚´ìš©ì„ ì¶”ê°€í•´ ì£¼ì„¸ìš”.)</p>
                `;
            contentDiv.style.textAlign = 'center'; // ì¤‘ì•™ ì •ë ¬
            contentDiv.style.padding = '20px'; // íŒ¨ë”© ìœ ì§€
            contentDiv.style.background = '#f8fafc'; // ë°°ê²½ìƒ‰ ìœ ì§€
        }

        // 3. íŒì—… í‘œì‹œ
        modal.style.display = 'block';
    }

    function closeResponseManualModal() {
        document.getElementById('responseManualModal').style.display = 'none';
    }
    // end of Response Manual íŒì—… ì œì–´ í•¨ìˆ˜

</script>
</body>
</html>
