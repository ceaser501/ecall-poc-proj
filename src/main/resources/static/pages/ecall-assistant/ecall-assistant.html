<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Report Reception - E-Call Assistant</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, rgb(248, 250, 252) 0%, rgb(226, 232, 240) 100%);
            min-height: 100vh;
        }

        /* Header */
        .header {
            background: white;
            border-bottom: 1px solid rgb(226, 232, 240);
        }

        .header-container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 1rem 1.5rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .header-icon {
            background: linear-gradient(135deg, rgb(239, 68, 68) 0%, rgb(220, 38, 38) 100%);
            padding: 0.625rem;
            border-radius: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .header-icon svg {
            width: 1.25rem;
            height: 1.25rem;
            color: white;
        }

        .header-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: rgb(15, 23, 42);
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .status-dot {
            width: 0.5rem;
            height: 0.5rem;
            background: rgb(148, 163, 184);
            border-radius: 50%;
            animation: pulse 2s ease-in-out infinite;
        }

        .status-dot.active {
            background: rgb(34, 197, 94);
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .status-text {
            color: rgb(71, 85, 105);
        }

        .status-time {
            color: rgb(15, 23, 42);
            font-weight: 600;
        }

        .btn {
            padding: 0.5rem 1rem;
            border: 1px solid rgb(226, 232, 240);
            border-radius: 0.375rem;
            background: white;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            transition: all 0.2s;
        }

        .btn:hover {
            background: rgb(248, 250, 252);
            border-color: rgb(203, 213, 225);
        }

        .btn.active {
            background: rgb(59, 130, 246);
            border-color: rgb(59, 130, 246);
            color: white;
        }

        .btn.active:hover {
            background: rgb(37, 99, 235);
            border-color: rgb(37, 99, 235);
        }

        .btn-primary {
            background: rgb(59, 130, 246);
            border-color: rgb(59, 130, 246);
            color: white;
        }

        .btn-primary:hover {
            background: rgb(37, 99, 235);
            border-color: rgb(37, 99, 235);
        }

        .btn-icon {
            width: 2rem;
            height: 2rem;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .btn svg {
            width: 1rem;
            height: 1rem;
        }

        .header-logout-btn {
            background: #1e293b;
            color: white;
            padding: 0.375rem 0.625rem;
            border: 1px solid #1e293b;
            border-radius: 0.375rem;
            font-size: 0.8125rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            height: 2rem;
            display: inline-flex;
            align-items: center;
        }

        .header-logout-btn:hover {
            background: #0f172a;
            border-color: #0f172a;
        }

        .header-user-info {
            position: relative;
            display: inline-block;
            margin-right: 1rem;
            cursor: pointer;
        }

        .header-user-name {
            font-size: 0.875rem;
            color: rgb(15, 23, 42);
            font-weight: 500;
        }

        .header-user-popup {
            display: none;
            position: absolute;
            top: calc(100% + 8px);
            right: 0;
            background: white;
            border: 1px solid rgb(226, 232, 240);
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            min-width: 360px;
            z-index: 1000;
        }

        .header-user-popup.show {
            display: block;
        }

        .header-user-popup .panel-header {
            background: rgb(248, 250, 252);
            padding: 1rem 1.25rem;
            border-bottom: 1px solid rgb(226, 232, 240);
            border-radius: 0.5rem 0.5rem 0 0;
        }

        .header-user-popup .panel-title {
            margin: 0;
            font-size: 1rem;
            font-weight: 600;
            color: rgb(15, 23, 42);
        }

        .header-user-popup .panel-body {
            padding: 1.5rem;
        }

        .header-user-popup .operator-info {
            display: flex;
            flex-direction: row;
            align-items: flex-start;
            gap: 1rem;
        }

        .header-user-popup .operator-name {
            font-weight: 600;
            color: rgb(15, 23, 42);
            margin: 0 0 0.375rem 0;
            font-size: 1rem;
        }

        .header-user-popup .operator-dept {
            color: rgb(100, 116, 139);
            font-size: 0.875rem;
            margin: 0 0 0.25rem 0;
        }

        .header-user-popup .operator-exp {
            color: rgb(148, 163, 184);
            font-size: 0.875rem;
            margin: 0;
        }

        /* Operator Status */
        .operator-status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
            margin-left: 8px;
            vertical-align: middle;
        }

        .operator-status-dot.on-call {
            background-color: #ef4444;
            box-shadow: 0 0 0 2px rgba(239, 68, 68, 0.2);
        }

        .operator-status-dot.available {
            background-color: #22c55e;
            box-shadow: 0 0 0 2px rgba(34, 197, 94, 0.2);
        }

        .operator-status-dot.away {
            background-color: #eab308;
            box-shadow: 0 0 0 2px rgba(234, 179, 8, 0.2);
        }

        .status-selector {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid rgb(226, 232, 240);
        }

        .status-selector-label {
            font-size: 0.875rem;
            font-weight: 600;
            color: rgb(71, 85, 105);
            margin-bottom: 0.5rem;
            display: block;
        }

        .status-options {
            display: flex;
            gap: 0.5rem;
        }

        .status-option {
            flex: 1;
            padding: 0.5rem;
            border: 2px solid rgb(226, 232, 240);
            border-radius: 0.375rem;
            cursor: pointer;
            text-align: center;
            font-size: 0.75rem;
            font-weight: 500;
            transition: all 0.2s;
            background: white;
        }

        .status-option:hover {
            border-color: rgb(148, 163, 184);
        }

        .status-option.active {
            background: rgb(241, 245, 249);
        }

        .status-option.on-call.active {
            border-color: #ef4444;
            background: rgba(239, 68, 68, 0.1);
            color: #dc2626;
        }

        .status-option.available.active {
            border-color: #22c55e;
            background: rgba(34, 197, 94, 0.1);
            color: #16a34a;
        }

        .status-option.away.active {
            border-color: #eab308;
            background: rgba(234, 179, 8, 0.1);
            color: #ca8a04;
        }

        /* Team Selection Card */
        .team-card {
            border: 2px solid rgb(226, 232, 240);
            border-radius: 0.5rem;
            padding: 1rem;
            margin-bottom: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
            background: white;
            position: relative;
        }

        .team-card:last-child {
            margin-bottom: 0;
        }

        .team-card:hover {
            border-color: rgb(59, 130, 246);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .team-card.selected {
            border-color: rgb(59, 130, 246);
            background: rgba(59, 130, 246, 0.05);
        }

        .team-card-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 0.75rem;
        }

        .team-radio {
            width: 18px;
            height: 18px;
            flex-shrink: 0;
            cursor: pointer;
        }

        .team-info {
            flex: 1;
        }

        .team-name {
            display: inline-block;
            font-size: 1rem;
            font-weight: 600;
            color: rgb(15, 23, 42);
            margin-right: 0.5rem;
        }

        .team-status {
            display: inline-block;
            font-size: 0.75rem;
            padding: 0.125rem 0.5rem;
            border-radius: 0.25rem;
            background: rgb(34, 197, 94);
            color: white;
            font-weight: 500;
        }

        .ai-recommended-badge {
            position: absolute;
            top: 0.75rem;
            right: 0.75rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-size: 0.75rem;
            padding: 0.25rem 0.75rem;
            border-radius: 1rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.25rem;
            box-shadow: 0 2px 4px rgba(102, 126, 234, 0.3);
        }

        .ai-icon {
            width: 14px;
            height: 14px;
        }

        .team-details {
            padding-left: 0;
            font-size: 0.875rem;
            color: rgb(71, 85, 105);
        }

        .team-detail-row {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 0.375rem;
        }

        .team-detail-label {
            font-weight: 600;
            min-width: 100px;
        }

        .team-detail-value {
            color: rgb(51, 65, 85);
        }

        .team-members {
            margin-top: 0.5rem;
            padding-top: 0.5rem;
            border-top: 1px solid rgb(226, 232, 240);
        }

        .team-member {
            padding: 0.25rem 0;
        }

        /* Main Content */
        .main-content {
            max-width: 1600px;
            margin: 0 auto;
            padding: 1.5rem;
        }

        .grid-container {
            display: grid;
            grid-template-columns: minmax(280px, 1fr) minmax(600px, 2fr) minmax(280px, 1fr);
            gap: 1.5rem;
        }

        @media (max-width: 1400px) {
            .grid-container {
                grid-template-columns: 1fr;
            }

            .left-sidebar, .right-sidebar {
                display: none;
            }
        }

        .panel {
            background: white;
            border-radius: 0.75rem;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1);
            border: 1px solid rgb(226, 232, 240);
        }

        .panel-header {
            padding: 1.25rem;
            border-bottom: 1px solid rgb(226, 232, 240);
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: relative;
        }

        .panel-title {
            font-size: 1.125rem;
            font-weight: 600;
            color: rgb(15, 23, 42);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .panel-body {
            padding: 1.25rem;
        }

        /* Left Sidebar - Caller Info */
        .form-group {
            margin-bottom: 0.75rem;
        }

        .form-label {
            display: block;
            font-size: 0.875rem;
            font-weight: 500;
            color: rgb(51, 65, 85);
            margin-bottom: 0.375rem;
        }

        /* Tooltip styles */
        .severity-label-wrapper {
            position: relative;
            display: inline-flex;
            align-items: center;
            gap: 0.375rem;
        }

        .severity-info-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: rgb(226, 232, 240);
            color: rgb(71, 85, 105);
            font-size: 11px;
            font-weight: 600;
            cursor: help;
            transition: all 0.2s;
            position: relative;
        }

        .severity-info-icon:hover {
            background: rgb(59, 130, 246);
            color: white;
        }

        .severity-tooltip {
            visibility: hidden;
            opacity: 0;
            position: absolute;
            bottom: calc(100% + 8px);
            left: 50%;
            transform: translateX(-50%);
            width: 320px;
            background: rgb(30, 41, 59);
            color: white;
            padding: 12px 14px;
            border-radius: 8px;
            font-size: 12px;
            line-height: 1.5;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            z-index: 10000;
            transition: all 0.2s;
            pointer-events: none;
        }

        .severity-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: rgb(30, 41, 59);
        }

        .severity-info-icon:hover .severity-tooltip {
            visibility: visible;
            opacity: 1;
        }

        .severity-tooltip-section {
            margin-bottom: 8px;
        }

        .severity-tooltip-section:last-child {
            margin-bottom: 0;
        }

        .severity-tooltip-title {
            font-weight: 600;
            color: rgb(96, 165, 250);
            margin-bottom: 4px;
        }

        .severity-tooltip-list {
            margin: 4px 0 0 0;
            padding-left: 16px;
        }

        .severity-tooltip-list li {
            margin-bottom: 2px;
        }

        .form-input, .form-select {
            width: 100%;
            padding: 0.5rem 0.75rem;
            border: 1px solid rgb(226, 232, 240);
            border-radius: 0.375rem;
            font-size: 0.875rem;
            background: white;
            transition: all 0.2s;
        }

        .form-input:focus, .form-select:focus {
            outline: none;
            border-color: rgb(59, 130, 246);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .form-input:read-only {
            background: rgb(248, 250, 252);
        }

        .form-input::placeholder {
            color: rgb(156, 163, 175);
        }

        .form-input:invalid,
        select.form-input:invalid {
            color: rgb(156, 163, 175);
        }

        select.form-input option[value=""] {
            color: rgb(156, 163, 175);
        }

        select.form-input option:not([value=""]) {
            color: rgb(15, 23, 42);
        }

        .btn-update {
            width: 100%;
            background: rgb(71, 85, 105);
            border-color: rgb(71, 85, 105);
            color: white;
            margin-top: 0.75rem;
        }

        .btn-update:hover {
            background: rgb(51, 65, 85);
            border-color: rgb(51, 65, 85);
        }

        .divider {
            margin: 1.25rem 0;
            padding-top: 1.25rem;
            border-top: 1px solid rgb(226, 232, 240);
        }

        .btn-checklist {
            width: 100%;
            justify-content: center;
        }

        /* Center Panel - Transcript */
        .transcript-panel {
            height: 850px;
            max-height: 850px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .transcript-header-info {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            color: rgb(71, 85, 105);
            font-size: 0.875rem;
        }

        .transcript-messages {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .message {
            padding: 1rem;
            border-radius: 0.5rem;
            border: 2px solid;
        }

        .message-operator {
            background: rgb(236, 253, 245);
            border-color: rgb(167, 243, 208);
        }

        .message-caller {
            background: rgb(239, 246, 255);
            border-color: rgb(191, 219, 254);
        }

        .message-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.5rem;
        }

        .message-sender {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .sender-avatar {
            width: 1.5rem;
            height: 1.5rem;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .operator-avatar {
            background: rgb(5, 150, 105);
        }

        .caller-avatar {
            background: rgb(37, 99, 235);
        }

        .sender-name {
            font-weight: 600;
            color: rgb(15, 23, 42);
        }

        .message-time {
            color: rgb(100, 116, 139);
            font-size: 0.875rem;
        }

        .message-text {
            color: rgb(51, 65, 85);
            line-height: 1.5;
            margin-left: 2rem;
        }

        .transcript-footer {
            border-top: 1px solid rgb(226, 232, 240);
            padding: 0.75rem;
            background: rgb(248, 250, 252);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.5rem;
        }

        .recording-dot {
            width: 0.5rem;
            height: 0.5rem;
            background: rgb(239, 68, 68);
            border-radius: 50%;
            animation: pulse 1.5s ease-in-out infinite;
        }

        .recording-text {
            color: rgb(71, 85, 105);
            font-size: 0.875rem;
        }

        /* Right Sidebar */
        .operator-info {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .operator-avatar-lg {
            width: 4rem;
            height: 4rem;
            border-radius: 50%;
            background: rgb(226, 232, 240);
            overflow: hidden;
            flex-shrink: 0;
        }

        .operator-avatar-lg img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .operator-details {
            display: flex;
            flex-direction: column;
            gap: 0.125rem;
        }

        .operator-name {
            font-weight: 600;
            color: rgb(15, 23, 42);
        }

        .operator-dept {
            color: rgb(71, 85, 105);
            font-size: 0.875rem;
        }

        .operator-exp {
            color: rgb(100, 116, 139);
            font-size: 0.875rem;
        }

        .manual-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            max-height: 175px; /* Exactly 4 items visible (each item ~35px + 8px gap) */
            overflow-y: auto;
        }

        .manual-item {
            background: rgb(241, 245, 249);
            padding: 0.625rem;
            border-radius: 0.5rem;
            color: rgb(51, 65, 85);
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.875rem;
        }

        .manual-item:hover {
            background: rgb(226, 232, 240);
        }

        .timeline-list {
            display: flex;
            flex-direction: column;
            gap: 0.625rem;
        }

        .timeline-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            color: rgb(51, 65, 85);
            font-size: 0.875rem;
        }

        .timeline-time {
            color: rgb(100, 116, 139);
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
        }

        .modal-content {
            background: white;
            margin: 2rem auto;
            padding: 0;
            border-radius: 0.75rem;
            width: 90%;
            max-width: 700px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            max-height: calc(100vh - 15rem);
            display: flex;
            flex-direction: column;
        }

        .modal-header {
            padding: 1.25rem 1.5rem;
            border-bottom: 1px solid rgb(226, 232, 240);
            flex-shrink: 0;
        }

        .modal-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: rgb(15, 23, 42);
        }

        .modal-desc {
            margin-top: 0.5rem;
            color: rgb(71, 85, 105);
            font-size: 0.875rem;
        }

        .modal-body {
            padding: 1rem 1.5rem 1rem 1.5rem;
            overflow-y: auto;
            flex: 1;
            min-height: 0;
        }

        .modal-footer {
            padding: 1rem 1.5rem;
            border-top: 1px solid rgb(226, 232, 240);
            display: flex;
            gap: 0.5rem;
            justify-content: flex-end;
            flex-shrink: 0;
        }

        .close-btn {
            position: absolute;
            top: 1.5rem;
            right: 1.5rem;
            background: none;
            border: none;
            font-size: 1.5rem;
            color: rgb(100, 116, 139);
            cursor: pointer;
            padding: 0;
            width: 2rem;
            height: 2rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .close-btn:hover {
            color: rgb(15, 23, 42);
        }

        /* Checklist */
        .checklist-items {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .checklist-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1rem;
            background: rgb(248, 250, 252);
            border-radius: 0.5rem;
        }

        .checklist-question {
            color: rgb(51, 65, 85);
            flex: 1;
        }

        .checklist-buttons {
            display: flex;
            gap: 0.5rem;
            margin-left: 1rem;
        }

        .btn-yes, .btn-no {
            padding: 0.375rem 0.75rem;
            font-size: 0.875rem;
            border-radius: 0.375rem;
            border: 1px solid;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.25rem;
            transition: all 0.2s;
        }

        .btn-yes {
            background: white;
            border-color: rgb(226, 232, 240);
            color: rgb(71, 85, 105);
        }

        .btn-yes.active {
            background: rgb(34, 197, 94);
            border-color: rgb(34, 197, 94);
            color: white;
        }

        .btn-no {
            background: white;
            border-color: rgb(226, 232, 240);
            color: rgb(71, 85, 105);
        }

        .btn-no.active {
            background: rgb(239, 68, 68);
            border-color: rgb(239, 68, 68);
            color: white;
        }

        /* Upload Modal */
        .upload-area {
            border: 2px dashed rgb(203, 213, 225);
            border-radius: 0.5rem;
            padding: 3rem 2rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .upload-area:hover {
            border-color: rgb(59, 130, 246);
        }

        .upload-icon {
            width: 3rem;
            height: 3rem;
            margin: 0 auto 0.75rem;
            color: rgb(148, 163, 184);
        }

        .upload-text {
            color: rgb(51, 65, 85);
            font-weight: 500;
            margin-bottom: 0.25rem;
        }

        .upload-subtext {
            color: rgb(100, 116, 139);
            font-size: 0.875rem;
        }

        .file-input {
            display: none;
        }

        .uploaded-file {
            background: rgb(239, 246, 255);
            border: 1px solid rgb(191, 219, 254);
            border-radius: 0.5rem;
            padding: 1rem;
            margin-top: 1rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .file-info-wrapper {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .file-icon {
            color: rgb(37, 99, 235);
        }

        .file-details {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .file-name {
            color: rgb(15, 23, 42);
            font-weight: 500;
        }

        .file-size {
            color: rgb(100, 116, 139);
            font-size: 0.875rem;
        }

        .remove-file-btn {
            background: none;
            border: none;
            color: rgb(71, 85, 105);
            cursor: pointer;
            padding: 0.25rem;
        }

        .remove-file-btn:hover {
            color: rgb(15, 23, 42);
        }

        /* Empty State */
        .empty-state {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            min-height: 600px;
        }

        .empty-state.hidden {
            display: none;
        }

        .empty-state-content {
            text-align: center;
            max-width: 400px;
        }

        .empty-state-icon-wrapper {
            position: relative;
            display: inline-block;
            margin-bottom: 1.5rem;
        }

        .empty-state-icon {
            width: 96px;
            height: 96px;
            border-radius: 50%;
            background: rgb(248, 250, 252);
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 1rem;
            color: rgb(148, 163, 184);
        }

        .empty-state-pulse {
            position: absolute;
            top: -4px;
            right: -4px;
            width: 24px;
            height: 24px;
            background: rgb(203, 213, 225);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: pulse 2s ease-in-out infinite;
        }

        .empty-state-pulse::after {
            content: '';
            width: 12px;
            height: 12px;
            background: rgb(148, 163, 184);
            border-radius: 50%;
        }

        .empty-state-title {
            font-size: 1.125rem;
            font-weight: 600;
            color: rgb(15, 23, 42);
            margin-bottom: 0.5rem;
        }

        .empty-state-description {
            color: rgb(100, 116, 139);
            margin-bottom: 1.5rem;
        }

        .empty-state-badge {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: rgb(248, 250, 252);
            border-radius: 9999px;
        }

        .empty-state-badge-dot {
            width: 8px;
            height: 8px;
            background: rgb(148, 163, 184);
            border-radius: 50%;
            animation: pulse 2s ease-in-out infinite;
        }

        .empty-state-badge span {
            color: rgb(100, 116, 139);
            font-size: 0.875rem;
        }

        .checklist-pulse-dot {
            display: inline-block;
            width: 8px;
            height: 8px;
            background: rgb(239, 68, 68);
            border-radius: 50%;
            margin-right: 0.5rem;
            animation: pulse 2s ease-in-out infinite;
        }

        .btn-checklist.has-checklist {
            background: rgb(254, 242, 242);
            border-color: rgb(239, 68, 68);
            color: rgb(220, 38, 38);
            font-weight: 600;
            box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.1);
        }

        .btn-checklist.has-checklist:hover {
            background: rgb(254, 226, 226);
            border-color: rgb(220, 38, 38);
            color: rgb(185, 28, 28);
        }

        .checklist-required-badge {
            display: inline-block;
            margin-left: 0.5rem;
            padding: 0.125rem 0.5rem;
            font-size: 0.625rem;
            font-weight: 700;
            background: rgb(239, 68, 68);
            color: white;
            border-radius: 9999px;
            letter-spacing: 0.05em;
        }

        /* Checklist completed state */
        .btn-checklist.checklist-completed {
            background: rgb(240, 253, 244);
            border-color: rgb(34, 197, 94);
            color: rgb(22, 163, 74);
            font-weight: 600;
            box-shadow: 0 0 0 3px rgba(34, 197, 94, 0.1);
            cursor: not-allowed;
            opacity: 0.9;
        }

        .btn-checklist.checklist-completed:hover {
            background: rgb(240, 253, 244);
            border-color: rgb(34, 197, 94);
            color: rgb(22, 163, 74);
        }

        .btn-checklist.checklist-completed svg {
            margin-right: 0.5rem;
        }

        .btn-manual-update {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            width: 100%;
            padding: 0.5rem 0.75rem;
            background: rgb(59, 130, 246);
            border: 1px solid rgb(59, 130, 246);
            color: white;
            font-size: 0.875rem;
            font-weight: 500;
            border-radius: 0.375rem;
            cursor: pointer;
            transition: all 0.2s;
            margin-bottom: 1rem;
        }

        .btn-manual-update:hover {
            background: rgb(37, 99, 235);
            border-color: rgb(37, 99, 235);
        }

        .btn-manual-update:active {
            background: rgb(29, 78, 216);
            transform: scale(0.98);
        }

        .btn-manual-update svg {
            flex-shrink: 0;
        }

        /* Toast Notification */
        .toast-container {
            position: fixed;
            top: 5rem;
            right: 2rem;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .toast {
            min-width: 320px;
            max-width: 480px;
            padding: 1rem 1.25rem;
            background: white;
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            display: flex;
            align-items: center;
            gap: 0.75rem;
            animation: slideIn 0.3s ease-out;
            border-left: 4px solid;
        }

        .toast.success {
            border-left-color: rgb(34, 197, 94);
        }

        .toast.error {
            border-left-color: rgb(239, 68, 68);
        }

        .toast.warning {
            border-left-color: rgb(251, 146, 60);
        }

        .toast.info {
            border-left-color: rgb(59, 130, 246);
        }

        .toast-icon {
            flex-shrink: 0;
            width: 24px;
            height: 24px;
        }

        .toast.success .toast-icon {
            color: rgb(34, 197, 94);
        }

        .toast.error .toast-icon {
            color: rgb(239, 68, 68);
        }

        .toast.warning .toast-icon {
            color: rgb(251, 146, 60);
        }

        .toast.info .toast-icon {
            color: rgb(59, 130, 246);
        }

        .toast-content {
            flex: 1;
            font-size: 0.875rem;
            line-height: 1.5;
            color: rgb(31, 41, 55);
        }

        .toast-close {
            flex-shrink: 0;
            width: 20px;
            height: 20px;
            cursor: pointer;
            color: rgb(107, 114, 128);
            transition: color 0.2s;
        }

        .toast-close:hover {
            color: rgb(31, 41, 55);
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }

        .toast.slide-out {
            animation: slideOut 0.3s ease-in forwards;
        }

        /* Incoming Call Notification - Modern Design */
        .incoming-call-notification {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            width: 320px;
            z-index: 10001;
            display: none;
        }

        .incoming-call-notification.show {
            display: block;
            animation: slideInUp 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        /* Second incoming call - positioned above first call */
        #incomingCallNotification2 {
            bottom: calc(2rem + 300px); /* Position above the first notification with spacing */
        }

        @keyframes slideInUp {
            from {
                opacity: 0;
                transform: scale(0.9) translateY(20px);
            }
            to {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        .incoming-call-glow {
            position: absolute;
            inset: 0;
            background: linear-gradient(to right, #60a5fa, #818cf8);
            border-radius: 1rem;
            filter: blur(40px);
            opacity: 0.3;
            animation: pulse 2s ease-in-out infinite;
        }

        .incoming-call-card {
            position: relative;
            background: white;
            border-radius: 1rem;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            overflow: hidden;
            border: 1px solid #e5e7eb;
        }

        .incoming-call-header {
            background: linear-gradient(to bottom right, #334155, #1e293b, #0f172a);
            padding: 1.5rem;
            padding-bottom: 2rem;
            position: relative;
        }

        .incoming-call-icon-wrapper {
            width: 56px;
            height: 56px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 1rem;
            border: 1px solid rgba(255, 255, 255, 0.2);
            animation: iconPulse 2s ease-in-out infinite;
        }

        @keyframes iconPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .incoming-call-icon-wrapper svg {
            width: 28px;
            height: 28px;
            color: white;
        }

        .incoming-call-header-content {
            text-align: center;
        }

        .incoming-call-status {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }

        .incoming-call-status-dot {
            width: 8px;
            height: 8px;
            background: #ef4444;
            border-radius: 50%;
            animation: pulse 2s ease-in-out infinite;
        }

        .incoming-call-status-text {
            color: #f87171; /* red-400 */
            text-transform: uppercase;
            letter-spacing: 0.1em;
            font-size: 0.875rem; /* Increased from 0.75rem */
            font-weight: 600; /* Increased from 500 */
        }

        .incoming-call-number {
            color: white;
            font-size: 1.5rem;
            letter-spacing: 0.05em;
            font-weight: 500;
            margin-bottom: 0.25rem;
        }

        .incoming-call-label {
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.875rem;
        }

        .incoming-call-actions {
            padding: 1rem;
            background: #f9fafb;
            display: flex;
            gap: 0.75rem;
        }

        .incoming-call-btn {
            flex: 1;
            height: 48px;
            border: none;
            border-radius: 0.5rem;
            font-weight: 600;
            font-size: 0.9375rem;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .incoming-call-btn svg {
            width: 20px;
            height: 20px;
        }

        .incoming-call-btn.decline {
            background: white;
            color: #374151;
            border: 1px solid #d1d5db;
        }

        .incoming-call-btn.decline:hover {
            background: #f3f4f6;
            border-color: #9ca3af;
        }

        .incoming-call-btn.accept {
            background: #3b82f6;
            color: white;
            box-shadow: 0 10px 15px -3px rgba(59, 130, 246, 0.3);
        }

        .incoming-call-btn.accept:hover {
            background: #2563eb;
            box-shadow: 0 10px 15px -3px rgba(59, 130, 246, 0.4);
        }

        .incoming-call-border-top {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(to right, transparent, white, transparent);
            opacity: 0.5;
        }
    </style>
</head>
<body>
    <!-- Toast Container -->
    <div class="toast-container" id="toastContainer"></div>

    <!-- Incoming Call Notification -->
    <div class="incoming-call-notification" id="incomingCallNotification">
        <div class="incoming-call-glow"></div>
        <div class="incoming-call-card">
            <div class="incoming-call-header">
                <div class="incoming-call-icon-wrapper">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="16 2 16 8 22 8"></polyline>
                        <line x1="22" y1="2" x2="16" y2="8"></line>
                        <path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>
                    </svg>
                </div>
                <div class="incoming-call-header-content">
                    <div class="incoming-call-status">
                        <div class="incoming-call-status-dot"></div>
                        <div class="incoming-call-status-text">Emergency Call</div>
                    </div>
                    <div class="incoming-call-number" id="incomingCallNumber">010-1234-5678</div>
                    <div class="incoming-call-label">Incoming Emergency Report</div>
                </div>
            </div>
            <div class="incoming-call-actions">
                <button class="incoming-call-btn decline" onclick="declineCall(1)">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="18" y1="6" x2="6" y2="18"></line>
                        <line x1="6" y1="6" x2="18" y2="18"></line>
                    </svg>
                    Decline
                </button>
                <button class="incoming-call-btn accept" onclick="acceptCall(1)">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="20 6 9 17 4 12"></polyline>
                    </svg>
                    Accept
                </button>
            </div>
            <div class="incoming-call-border-top"></div>
        </div>
    </div>

    <!-- Second Incoming Call Notification -->
    <div class="incoming-call-notification" id="incomingCallNotification2">
        <div class="incoming-call-glow"></div>
        <div class="incoming-call-card">
            <div class="incoming-call-header">
                <div class="incoming-call-icon-wrapper">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="16 2 16 8 22 8"></polyline>
                        <line x1="22" y1="2" x2="16" y2="8"></line>
                        <path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>
                    </svg>
                </div>
                <div class="incoming-call-header-content">
                    <div class="incoming-call-status">
                        <div class="incoming-call-status-dot"></div>
                        <div class="incoming-call-status-text">Emergency Call</div>
                    </div>
                    <div class="incoming-call-number" id="incomingCallNumber2">010-1111-2222</div>
                    <div class="incoming-call-label">Incoming Emergency Report</div>
                </div>
            </div>
            <div class="incoming-call-actions">
                <button class="incoming-call-btn decline" onclick="declineCall(2)">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="18" y1="6" x2="6" y2="18"></line>
                        <line x1="6" y1="6" x2="18" y2="18"></line>
                    </svg>
                    Decline
                </button>
                <button class="incoming-call-btn accept" onclick="acceptCall(2)">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="20 6 9 17 4 12"></polyline>
                    </svg>
                    Accept
                </button>
            </div>
            <div class="incoming-call-border-top"></div>
        </div>
    </div>

    <!-- Hidden ringtone audio -->
    <audio id="ringtoneAudio" style="display:none;">
        <source src="https://assets.mixkit.co/active_storage/sfx/2869/2869-preview.mp3" type="audio/mpeg">
    </audio>

    <!-- Header -->
    <div class="header">
        <div class="header-container">
            <div class="header-left">
                <div class="header-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"/></svg>
                </div>
                <h1 class="header-title">Report Reception â€” ECA103</h1>
            </div>

            <div class="header-right">
                <div class="header-user-info">
                    <span class="header-user-name" id="headerUserName">Loading...</span>
                    <span class="operator-status-dot available" id="operatorStatusDot"></span>
                    <div class="header-user-popup">
                        <div class="panel-header">
                            <h3 class="panel-title">Operator Information</h3>
                        </div>
                        <div class="panel-body">
                            <div class="operator-info">
                                <div style="position: relative; width: 64px; height: 64px;">
                                    <div class="operator-avatar-lg">
                                        <img id="headerOperatorAvatar" src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='64' height='64' viewBox='0 0 64 64'%3E%3Crect fill='%23e2e8f0' width='64' height='64'/%3E%3Ctext x='50%25' y='50%25' dominant-baseline='middle' text-anchor='middle' font-family='Arial' font-size='24' fill='%2364748b'%3E%3F%3C/text%3E%3C/svg%3E" alt="Operator">
                                    </div>
                                    <label for="headerPhotoUpload" style="position: absolute; bottom: -4px; right: -4px; background: #2563eb; color: white; border-radius: 50%; width: 28px; height: 28px; display: flex; align-items: center; justify-content: center; cursor: pointer; font-size: 16px; font-weight: bold; border: 3px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.2);">+</label>
                                    <input type="file" id="headerPhotoUpload" accept="image/*" style="display: none;" onchange="handleHeaderPhotoUpload(event)">
                                </div>
                                <div class="operator-details">
                                    <p id="headerOperatorName" class="operator-name">Unknown</p>
                                    <p id="headerOperatorDept" class="operator-dept">N/A</p>
                                    <p id="headerOperatorExp" class="operator-exp">N/A</p>
                                </div>
                            </div>
                            <div class="status-selector">
                                <span class="status-selector-label">Status</span>
                                <div class="status-options">
                                    <div class="status-option on-call" onclick="changeOperatorStatus('on-call', true)">
                                        On Call
                                    </div>
                                    <div class="status-option available active" onclick="changeOperatorStatus('available', true)">
                                        Available
                                    </div>
                                    <div class="status-option away" onclick="changeOperatorStatus('away', true)">
                                        Away
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <button class="btn btn-icon" onclick="window.location.href='ecall-intro.html'">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/><polyline points="9 22 9 12 15 12 15 22"/></svg>
                </button>
                <button class="btn btn-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"/><path d="M13.73 21a2 2 0 0 1-3.46 0"/></svg>
                </button>
                <button class="header-logout-btn" onclick="logout()">
                    Log Out
                </button>
            </div>
        </div>
    </div>

    <!-- Main Content -->
    <div class="main-content">
        <div class="grid-container">
            <!-- Left Sidebar -->
            <div class="left-sidebar">
                <!-- Caller Information Panel -->
                <div class="panel" style="margin-bottom: 1.25rem;">
                    <div class="panel-header">
                        <h2 class="panel-title">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M12 16v-4"/><path d="M12 8h.01"/></svg>
                            Caller Information
                        </h2>
                    </div>
                    <div class="panel-body">
                        <div class="form-group">
                            <label class="form-label">Caller Number</label>
                            <input type="text" class="form-input" id="callerNumber" value="" placeholder="Waiting for call..." readonly>
                        </div>

                        <!-- Hidden: Caller Name -->
                        <!-- <div class="form-group">
                            <label class="form-label">Caller Name</label>
                            <input type="text" class="form-input" value="Minsu Kim">
                        </div> -->

                        <div class="form-group">
                            <label class="form-label">Incident Location</label>
                            <input type="text" class="form-input" id="incidentLocation" value="" placeholder="AI analyzing..." style="background: rgb(248, 250, 252);">
                        </div>

                        <div class="form-group">
                            <label class="form-label">Incident Type</label>
                            <select class="form-input" id="incidentType" onchange="updateChecklist(false)">
                                <option value="">AI analyzing...</option>
                                <option value="disaster">Disaster</option>
                                <option value="medical">Medical</option>
                                <option value="crime">Crime</option>
                                <option value="traffic">Traffic</option>
                                <option value="rescue">Rescue</option>
                                <option value="other">Other</option>
                            </select>
                        </div>

                        <div class="form-group">
                            <label class="form-label">
                                <span class="severity-label-wrapper">
                                    Severity Level
                                    <span class="severity-info-icon">
                                        ?
                                        <div class="severity-tooltip">
                                            <div class="severity-tooltip-section">
                                                <div class="severity-tooltip-title">AI Risk Assessment System</div>
                                                Severity levels are automatically assessed using GPT-4o mini through real-time transcript analysis.
                                            </div>
                                            <div class="severity-tooltip-section">
                                                <div class="severity-tooltip-title">Detection Methods</div>
                                                <ul class="severity-tooltip-list">
                                                    <li><strong>Keyword Patterns:</strong> Instant detection of critical terms (weapons, violence, injuries)</li>
                                                    <li><strong>AI Analysis:</strong> Contextual understanding every 60-80 characters of conversation</li>
                                                </ul>
                                            </div>
                                            <div class="severity-tooltip-section">
                                                <div class="severity-tooltip-title">Critical Triggers (Level 4-5)</div>
                                                Weapons, active threats, pursuit/chase scenarios, severe injuries, fire/explosions
                                            </div>
                                        </div>
                                    </span>
                                </span>
                            </label>
                            <select class="form-input" id="severityLevel">
                                <option value="">AI analyzing...</option>
                                <option value="1">Level 1 - Minimal</option>
                                <option value="2">Level 2 - Low</option>
                                <option value="3">Level 3 - Moderate</option>
                                <option value="4">Level 4 - High</option>
                                <option value="5">Level 5 - Critical</option>
                            </select>
                        </div>

                        <button class="btn btn-manual-update" onclick="updateIncidentInfo()">
                            <!--<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>-->
                            Manual Update
                        </button>

                        <div class="divider">
                            <button class="btn btn-checklist" id="viewChecklistBtn" onclick="showChecklistModal()">
                                <span class="checklist-pulse-dot" id="checklistPulseDot" style="display: none;"></span>
                                View Checklist
                                <span class="checklist-required-badge" id="checklistRequiredBadge" style="display: none;">REQUIRED</span>
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Timeline -->
                <div class="panel">
                    <div class="panel-header">
                        <h2 class="panel-title">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
                            Timeline
                        </h2>
                    </div>
                    <div class="panel-body">
                        <div class="timeline-list">
                            <div class="timeline-item">
                                <span>Call Started</span>
                                <span class="timeline-time">--:--:--</span>
                            </div>
                            <div class="timeline-item">
                                <span>Location Confirmed</span>
                                <span class="timeline-time">--:--:--</span>
                            </div>
                            <div class="timeline-item">
                                <span>Dispatch Ordered</span>
                                <span class="timeline-time" id="dispatchOrderedTime">--:--:--</span>
                            </div>
                            <div class="timeline-item">
                                <span>Dispatch Arrived</span>
                                <span class="timeline-time" id="dispatchArrivedTime">--:--:--</span>
                            </div>
                            <div class="timeline-item">
                                <span>Call Ended</span>
                                <span class="timeline-time">--:--:--</span>
                            </div>
                            <div class="timeline-item">
                                <span>Elapsed Time</span>
                                <span class="timeline-time">00:00</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Center Panel -->
            <div class="center-panel">
                <div class="panel transcript-panel">
                    <div class="panel-header" style="display: flex; justify-content: space-between; align-items: center;">
                        <h2 class="panel-title">Live Transcript</h2>
                        <span id="aiConfidence" style="position: absolute; left: 50%; transform: translateX(-50%); color: rgb(100, 116, 139); font-size: 0.875rem;">AI Confidence: 0%</span>
                        <div class="status-indicator">
                            <div class="status-dot"></div>
                            <span class="status-text">Standby</span>
                            <span class="status-time" id="callTimer">00:00</span>
                        </div>
                    </div>

                    <div class="transcript-messages" id="transcriptMessages">
                        <!-- Empty State - Waiting for Call -->
                        <div class="empty-state" id="emptyState">
                            <div class="empty-state-content">
                                <div class="empty-state-icon-wrapper">
                                    <div class="empty-state-icon">
                                        <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"/></svg>
                                    </div>
                                    <div class="empty-state-pulse"></div>
                                </div>
                                <h3 class="empty-state-title">Waiting for Incoming Call</h3>
                                <p class="empty-state-description">The system is ready to receive emergency calls.</p>
                                <div class="empty-state-badge">
                                    <div class="empty-state-badge-dot"></div>
                                    <span>Standby Mode</span>
                                </div>
                            </div>
                        </div>
                        <!-- Messages will be added here dynamically -->
                    </div>

                    <div class="transcript-footer" style="display: flex; justify-content: space-between; align-items: center;">
                        <div style="display: flex; align-items: center; gap: 0.5rem;">
                            <div class="recording-dot"></div>
                            <span class="recording-text" id="recordingText">Voice Recognition active...</span>
                        </div>
                        <div style="display: flex; gap: 0.5rem;">
                            <button class="btn" id="playBtn" onclick="playAudio()" style="display: none;">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"/></svg>
                                Play
                            </button>
                            <button class="btn active" id="speakerBtn" onclick="toggleSpeaker()" style="display: none;">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M15.54 8.46a5 5 0 0 1 0 7.07"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14"/></svg>
                                Speaker
                            </button>
                            <button class="btn" onclick="showDispatchRequestModal()" style="flex: 1; background: #dc2626; color: white;">
                                <!--<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 0.5rem;"><path d="M9 11a3 3 0 1 0 6 0a3 3 0 0 0 -6 0"/><path d="M17.657 16.657l-4.243 4.243a2 2 0 0 1 -2.827 0l-4.244 -4.243a8 8 0 1 1 11.314 0z"/></svg>-->
                                Request Dispatch
                            </button>
                        </div>
                        <!-- Upload Audio File Button - Hidden for simulation mode
                        <button class="btn btn-primary" onclick="showUploadModal()" style="padding: 0.375rem 0.75rem; font-size: 0.8125rem; height: auto;">
                            <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/><path d="M12 18v-6"/><path d="m9 15 3-3 3 3"/></svg>
                            Upload Audio File
                        </button>
                        -->
                    </div>
                </div>
            </div>

            <!-- Right Sidebar -->
            <div class="right-sidebar">
                <!-- Dispatch Status -->
                <div class="panel" style="margin-bottom: 1.25rem;">
                    <div class="panel-header">
                        <h2 class="panel-title">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 11a3 3 0 1 0 6 0a3 3 0 0 0 -6 0"/><path d="M17.657 16.657l-4.243 4.243a2 2 0 0 1 -2.827 0l-4.244 -4.243a8 8 0 1 1 11.314 0z"/></svg>
                            Dispatch Status
                        </h2>
                    </div>
                    <div class="panel-body">
                        <div class="form-group">
                            <label class="form-label">Dispatch Status</label>
                            <select class="form-input" id="dispatchStatus">
                                <option value="">Not Dispatched</option>
                                <option value="requested">Dispatch Requested</option>
                                <option value="assigned">Team Assigned</option>
                                <option value="enroute">En Route</option>
                                <option value="arrived">On Scene</option>
                                <option value="completed">Completed</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label class="form-label">Assigned Team</label>
                            <div style="display: flex; gap: 0.5rem;">
                                <input type="text" class="form-input" id="dispatchTeam" placeholder="No team assigned" readonly style="flex: 1;">
                                <button class="btn btn-icon" onclick="showTeamDetails()" title="View team details">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M12 16v-4"/><path d="M12 8h.01"/></svg>
                                </button>
                            </div>
                        </div>
                        <div class="form-group">
                            <label class="form-label">Vehicle Info</label>
                            <input type="text" class="form-input" id="dispatchVehicle" placeholder="No vehicle assigned" readonly>
                        </div>
                        <div class="form-group">
                            <label class="form-label">Dispatched At</label>
                            <input type="text" class="form-input" id="dispatchTime" placeholder="--:--:--" readonly>
                        </div>
                        <div class="form-group">
                            <label class="form-label">Expected Arrival</label>
                            <input type="text" class="form-input" id="dispatchETA" placeholder="--:--" readonly>
                        </div>
                        <div class="form-group" style="margin-bottom: 0;">
                            <label class="form-label">Current Location</label>
                            <div style="display: flex; gap: 0.5rem;">
                                <input type="text" class="form-input" id="dispatchLocation" placeholder="--" readonly style="flex: 1;">
                                <button class="btn btn-icon" onclick="refreshLocation()" title="Refresh location">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.2"/></svg>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Response Manual -->
                <div class="panel">
                    <div class="panel-header">
                        <h2 class="panel-title">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 19.5v-15A2.5 2.5 0 0 1 6.5 2H20v20H6.5a2.5 2.5 0 0 1 0-5H20"/></svg>
                            Response Manual
                        </h2>
                    </div>
                    <div class="panel-body">
                        <div class="form-group" style="margin-bottom: 1rem;">
                            <input type="text" class="form-input" id="manualSearch" placeholder="Search manuals..." oninput="searchManuals()">
                        </div>
                        <div class="manual-list" id="manualList">
                            <div class="manual-item">CPR Procedure</div>
                            <div class="manual-item">Bleeding Control</div>
                            <div class="manual-item">Shock Management</div>
                            <div class="manual-item">Airway Support</div>
                            <div class="manual-item">Burn Treatment</div>
                            <div class="manual-item">Choking Response</div>
                            <div class="manual-item">Stroke Recognition</div>
                            <div class="manual-item">Heart Attack Protocol</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Checklist Modal -->
    <div id="checklistModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <button class="close-btn" onclick="closeChecklistModal()">&times;</button>
                <h2 class="modal-title">Incident Type Checklist</h2>
                <p class="modal-desc" id="checklistDesc">Questions to assess the emergency situation.</p>
            </div>
            <div class="modal-body">
                <div class="checklist-items" id="checklistItems">
                    <!-- Dynamically generated -->
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" onclick="closeChecklistModal()">Close</button>
                <button class="btn btn-primary" onclick="saveChecklist()">Save Checklist</button>
            </div>
        </div>
    </div>

    <!-- Team Details Modal -->
    <div id="teamDetailsModal" class="modal">
        <div class="modal-content" style="max-width: 400px;">
            <div class="modal-header">
                <button class="close-btn" onclick="closeTeamDetails()">&times;</button>
                <h2 class="modal-title">Team Details</h2>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">Team Number</label>
                    <input type="text" class="form-input" id="teamNumber" value="Fire Unit 23" readonly>
                </div>
                <div class="form-group">
                    <label class="form-label">Team Name</label>
                    <input type="text" class="form-input" id="teamName" value="Alpha Squad" readonly>
                </div>
                <div class="form-group">
                    <label class="form-label">Team Leader</label>
                    <input type="text" class="form-input" id="teamLeader" value="John Smith (555-1234)" readonly>
                </div>
                <div class="form-group" style="margin-bottom: 0;">
                    <label class="form-label">Deputy Leader</label>
                    <input type="text" class="form-input" id="teamDeputy" value="Jane Doe (555-5678)" readonly>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" onclick="closeTeamDetails()">Close</button>
            </div>
        </div>
    </div>

    <!-- Dispatch Request Modal -->
    <div id="dispatchRequestModal" class="modal">
        <div class="modal-content" style="max-width: 700px; max-height: 90vh;">
            <div class="modal-header">
                <button class="close-btn" onclick="closeDispatchRequestModal()">&times;</button>
                <h2 class="modal-title">Select Dispatch Team</h2>
                <p class="modal-desc">Choose a rescue team to dispatch to the emergency scene</p>
            </div>
            <div class="modal-body" style="max-height: none; overflow-y: auto;">
                <div id="teamSelectionList">
                    <!-- Teams will be dynamically loaded here -->
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" onclick="closeDispatchRequestModal()">Cancel</button>
                <button class="btn btn-primary" onclick="confirmDispatchRequest()">Request Dispatch</button>
            </div>
        </div>
    </div>

    <!-- Upload Modal -->
    <div id="uploadModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <button class="close-btn" onclick="closeUploadModal()">&times;</button>
                <h2 class="modal-title">Upload Audio File</h2>
                <p class="modal-desc">Upload an MP3 audio file for transcription and analysis.</p>
            </div>
            <div class="modal-body">
                <div class="upload-area" onclick="document.getElementById('audioFile').click()">
                    <svg class="upload-icon" xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/><path d="M12 18v-6"/><path d="m9 15 3-3 3 3"/></svg>
                    <div class="upload-text">Click to upload or drag and drop</div>
                    <div class="upload-subtext">MP3 files only</div>
                </div>
                <input type="file" id="audioFile" class="file-input" accept=".mp3,audio/mp3,audio/mpeg" onchange="handleFileSelect(event)">
                <div id="uploadedFileInfo"></div>
            </div>
            <div class="modal-footer">
                <button class="btn" onclick="closeUploadModal()">Cancel</button>
                <button class="btn btn-primary" id="uploadBtn" disabled onclick="uploadFile()">Upload</button>
            </div>
        </div>
    </div>

    <script>
        // Load Kakao Maps SDK dynamically
        let kakaoMapsLoaded = false;
        let kakaoMapsLoadPromise = null;

        kakaoMapsLoadPromise = (async function loadKakaoMapsSDK() {
            try {
                const response = await fetch('/api/intake-desks/kakao-api-key');
                const data = await response.json();

                if (data.success && data.apiKey) {
                    return new Promise((resolve, reject) => {
                        const script = document.createElement('script');
                        script.type = 'text/javascript';
                        script.src = `//dapi.kakao.com/v2/maps/sdk.js?appkey=${data.apiKey}`;
                        script.onload = () => {
                            kakaoMapsLoaded = true;
                            console.log('Kakao Maps SDK loaded successfully');
                            resolve(true);
                        };
                        script.onerror = () => {
                            console.error('Failed to load Kakao Maps SDK');
                            reject(new Error('Failed to load Kakao Maps SDK'));
                        };
                        document.head.appendChild(script);
                    });
                } else {
                    console.error('No Kakao API key found');
                    return Promise.reject(new Error('No Kakao API key found'));
                }
            } catch (error) {
                console.error('Error loading Kakao API key:', error);
                return Promise.reject(error);
            }
        })();

        // Toast notification system
        function showToast(message, type = 'info', duration = 4000) {
            const container = document.getElementById('toastContainer');
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;

            // Icon based on type
            let icon = '';
            switch(type) {
                case 'success':
                    icon = '<svg class="toast-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg>';
                    break;
                case 'error':
                    icon = '<svg class="toast-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><line x1="15" y1="9" x2="9" y2="15"/><line x1="9" y1="9" x2="15" y2="15"/></svg>';
                    break;
                case 'warning':
                    icon = '<svg class="toast-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m21.73 18-8-14a2 2 0 0 0-3.46 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"/><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg>';
                    break;
                case 'info':
                default:
                    icon = '<svg class="toast-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M12 16v-4"/><path d="M12 8h.01"/></svg>';
            }

            toast.innerHTML = `
                ${icon}
                <div class="toast-content">${message}</div>
                <svg class="toast-close" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
            `;

            // Add close button functionality
            const closeBtn = toast.querySelector('.toast-close');
            closeBtn.addEventListener('click', () => {
                removeToast(toast);
            });

            container.appendChild(toast);

            // Auto remove after duration
            if (duration > 0) {
                setTimeout(() => {
                    removeToast(toast);
                }, duration);
            }
        }

        function removeToast(toast) {
            toast.classList.add('slide-out');
            setTimeout(() => {
                toast.remove();
            }, 300);
        }

        // Load operator information from session
        document.addEventListener('DOMContentLoaded', function() {
            const user = JSON.parse(sessionStorage.getItem('user'));

            // Load operator status
            loadOperatorStatus();

            if (user) {
                // Update operator name
                const operatorNameEl = document.getElementById('operatorName');
                if (operatorNameEl) {
                    operatorNameEl.textContent = user.name || 'Unknown';
                }

                // Update operator department
                const operatorDeptEl = document.getElementById('operatorDept');
                if (operatorDeptEl) {
                    operatorDeptEl.textContent = user.organizationName || 'N/A';
                }

                // Calculate years of experience from join_date
                const operatorExpEl = document.getElementById('operatorExp');
                if (operatorExpEl && user.joinDate) {
                    // Parse date string (yyyy-MM-dd) without timezone issues
                    const joinDateStr = user.joinDate.split('T')[0]; // Remove time part if exists
                    const [year, month, day] = joinDateStr.split('-').map(Number);
                    const joinDate = new Date(year, month - 1, day); // month is 0-indexed

                    const today = new Date();
                    const yearsDiff = today.getFullYear() - joinDate.getFullYear();
                    const monthsDiff = today.getMonth() - joinDate.getMonth();
                    const daysDiff = today.getDate() - joinDate.getDate();

                    // Adjust if birthday hasn't occurred this year
                    let diffYears = yearsDiff;
                    if (monthsDiff < 0 || (monthsDiff === 0 && daysDiff < 0)) {
                        diffYears--;
                    }

                    operatorExpEl.textContent = `${diffYears} year${diffYears !== 1 ? 's' : ''} exp.`;
                }

                // Update avatar - show photo if available, otherwise show initials
                const operatorAvatarEl = document.getElementById('operatorAvatar');
                if (operatorAvatarEl) {
                    if (user.photoUrl) {
                        operatorAvatarEl.src = user.photoUrl;
                    } else if (user.name) {
                        const initials = user.name.split(' ').map(n => n[0]).join('').toUpperCase().substring(0, 2);
                        const avatarSvg = `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='64' height='64' viewBox='0 0 64 64'%3E%3Crect fill='%23e2e8f0' width='64' height='64'/%3E%3Ctext x='50%25' y='50%25' dominant-baseline='middle' text-anchor='middle' font-family='Arial' font-size='24' fill='%2364748b'%3E${initials}%3C/text%3E%3C/svg%3E`;
                        operatorAvatarEl.src = avatarSvg;
                    }
                }

                // Update header user info
                const headerUserNameEl = document.getElementById('headerUserName');
                if (headerUserNameEl && user.name) {
                    if (user.organizationName) {
                        headerUserNameEl.textContent = `${user.name} (${user.organizationName})`;
                    } else {
                        headerUserNameEl.textContent = user.name;
                    }
                }

                // Update header operator info in popup
                const headerOperatorNameEl = document.getElementById('headerOperatorName');
                if (headerOperatorNameEl) {
                    headerOperatorNameEl.textContent = user.name || 'Unknown';
                }

                const headerOperatorDeptEl = document.getElementById('headerOperatorDept');
                if (headerOperatorDeptEl) {
                    headerOperatorDeptEl.textContent = user.organizationName || 'N/A';
                }

                const headerOperatorExpEl = document.getElementById('headerOperatorExp');
                if (headerOperatorExpEl && user.joinDate) {
                    const joinDateStr = user.joinDate.split('T')[0];
                    const [year, month, day] = joinDateStr.split('-').map(Number);
                    const joinDate = new Date(year, month - 1, day);

                    const today = new Date();
                    const yearsDiff = today.getFullYear() - joinDate.getFullYear();
                    const monthsDiff = today.getMonth() - joinDate.getMonth();
                    const daysDiff = today.getDate() - joinDate.getDate();

                    let diffYears = yearsDiff;
                    if (monthsDiff < 0 || (monthsDiff === 0 && daysDiff < 0)) {
                        diffYears--;
                    }

                    headerOperatorExpEl.textContent = `${diffYears} year${diffYears !== 1 ? 's' : ''} exp.`;
                }

                // Update header avatar
                const headerOperatorAvatarEl = document.getElementById('headerOperatorAvatar');
                if (headerOperatorAvatarEl) {
                    if (user.photoUrl) {
                        headerOperatorAvatarEl.src = user.photoUrl;
                    } else if (user.name) {
                        const initials = user.name.split(' ').map(n => n[0]).join('').toUpperCase().substring(0, 2);
                        const avatarSvg = `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='48' height='48' viewBox='0 0 48 48'%3E%3Crect fill='%23e2e8f0' width='48' height='48'/%3E%3Ctext x='50%25' y='50%25' dominant-baseline='middle' text-anchor='middle' font-family='Arial' font-size='18' fill='%2364748b'%3E${initials}%3C/text%3E%3C/svg%3E`;
                        headerOperatorAvatarEl.src = avatarSvg;
                    }
                }
            }

            // Setup popup hover control with JavaScript
            const headerUserInfo = document.querySelector('.header-user-info');
            const headerUserPopup = document.querySelector('.header-user-popup');

            let popupTimeout;

            if (headerUserInfo && headerUserPopup) {
                // Show popup on mouseenter
                headerUserInfo.addEventListener('mouseenter', () => {
                    clearTimeout(popupTimeout);
                    headerUserPopup.classList.add('show');
                });

                // Keep popup visible when mouse is over it
                headerUserPopup.addEventListener('mouseenter', () => {
                    clearTimeout(popupTimeout);
                    headerUserPopup.classList.add('show');
                });

                // Hide popup with delay when mouse leaves
                headerUserInfo.addEventListener('mouseleave', () => {
                    popupTimeout = setTimeout(() => {
                        headerUserPopup.classList.remove('show');
                    }, 200);
                });

                headerUserPopup.addEventListener('mouseleave', () => {
                    popupTimeout = setTimeout(() => {
                        headerUserPopup.classList.remove('show');
                    }, 200);
                });
            }
        });

        // Handle header photo upload
        function changeOperatorStatus(status, isManual = false) {
            // Update status dot
            const statusDot = document.getElementById('operatorStatusDot');
            if (statusDot) {
                statusDot.className = `operator-status-dot ${status}`;
            }

            // Update active status option
            const statusOptions = document.querySelectorAll('.status-option');
            statusOptions.forEach(option => {
                option.classList.remove('active');
                if (option.classList.contains(status)) {
                    option.classList.add('active');
                }
            });

            // Save status to localStorage
            localStorage.setItem('operatorStatus', status);

            // Track if status was manually set to 'away'
            if (isManual && status === 'away') {
                localStorage.setItem('operatorStatusManualAway', 'true');
            } else if (isManual && status !== 'away') {
                localStorage.removeItem('operatorStatusManualAway');
            }

            console.log('Operator status changed to:', status, isManual ? '(manual)' : '(auto)');
        }

        // Load operator status on page load
        function loadOperatorStatus() {
            const savedStatus = localStorage.getItem('operatorStatus') || 'available';
            changeOperatorStatus(savedStatus);
        }

        // Auto-change status when call starts
        function onCallStart() {
            // Only change if not manually set to away
            const isManualAway = localStorage.getItem('operatorStatusManualAway') === 'true';
            if (!isManualAway) {
                changeOperatorStatus('on-call', false);
            }
        }

        // Auto-change status when call ends
        function onCallEnd() {
            // Only change if not manually set to away
            const isManualAway = localStorage.getItem('operatorStatusManualAway') === 'true';
            if (!isManualAway) {
                changeOperatorStatus('available', false);
            }
        }

        async function handleHeaderPhotoUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const user = JSON.parse(sessionStorage.getItem('user'));
            if (!user || !user.id) {
                showToast('User not logged in', 'warning');
                return;
            }

            const formData = new FormData();
            formData.append('photo', file);
            formData.append('operatorId', user.id);

            try {
                const response = await fetch('/api/auth/upload-photo', {
                    method: 'POST',
                    body: formData
                });

                const result = await response.json();

                if (result.success) {
                    // Update both header and sidebar avatars
                    const headerOperatorAvatarEl = document.getElementById('headerOperatorAvatar');
                    if (headerOperatorAvatarEl) {
                        headerOperatorAvatarEl.src = result.fileUrl;
                    }

                    const operatorAvatarEl = document.getElementById('operatorAvatar');
                    if (operatorAvatarEl) {
                        operatorAvatarEl.src = result.fileUrl;
                    }

                    // Update session storage
                    user.photoUrl = result.fileUrl;
                    sessionStorage.setItem('user', JSON.stringify(user));

                    showToast('Photo uploaded successfully!', 'success');
                } else {
                    showToast('Upload failed: ' + result.message, 'error');
                }
            } catch (error) {
                console.error('Error uploading photo:', error);
                showToast('Upload failed. Please try again.', 'error');
            }
        }

        // Handle photo upload
        async function handlePhotoUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const user = JSON.parse(sessionStorage.getItem('user'));
            if (!user || !user.id) {
                showToast('User not logged in', 'warning');
                return;
            }

            const formData = new FormData();
            formData.append('file', file);
            formData.append('operatorId', user.id);

            try {
                const response = await fetch('/api/auth/upload-photo', {
                    method: 'POST',
                    body: formData
                });

                const result = await response.json();

                if (result.success) {
                    // Update avatar immediately
                    const operatorAvatarEl = document.getElementById('operatorAvatar');
                    if (operatorAvatarEl) {
                        operatorAvatarEl.src = result.fileUrl;
                    }

                    // Update session storage
                    user.photoUrl = result.fileUrl;
                    sessionStorage.setItem('user', JSON.stringify(user));

                    showToast('Photo uploaded successfully!', 'success');
                } else {
                    showToast('Upload failed: ' + result.message, 'error');
                }
            } catch (error) {
                console.error('Error uploading photo:', error);
                showToast('Upload failed. Please try again.', 'error');
            }
        }

        // Checklist data
        const checklistData = {
            disaster: [
                "Are you at the location now?",
                "Are you in a safe place?",
                "Is there a fire or building collapse?",
                "Is the fire or damage spreading?",
                "Are you injured?",
                "Is anyone trapped or in immediate danger?",
                "Do you smell gas or see hazardous materials?"
            ],
            medical: [
                "Are you with the patient now?",
                "Is the patient awake?",
                "Is the patient breathing normally?",
                "Is the patient bleeding badly?",
                "Is the patient having chest pain?",
                "Did the patient collapse suddenly?",
                "Does the patient have any known medical conditions?",
                "What is the patient's age and sex?"
            ],
            crime: [
                "Are you safe right now?",
                "Is the crime happening now?",
                "Does the suspect have a weapon?",
                "Is the suspect still at the location?",
                "Is anyone injured?",
                "Where is the suspect now? Did they flee?",
                "How many suspects are there?",
                "Are there other victims? Are they conscious or bleeding?"
            ],
            traffic: [
                "Are you at the accident scene?",
                "Is anyone injured?",
                "(If injured) Is the patient awake and breathing?",
                "Is anyone trapped in a vehicle?",
                "Is any vehicle on fire?",
                "Is any vehicle leaking fuel?",
                "Does this involve more than one vehicle?",
                "Is the accident blocking traffic?"
            ],
            rescue: [
                "Is someone trapped, isolated, or in the water?",
                "Is the person conscious?",
                "Is the person injured?",
                "Are you able to talk to them?",
                "Is the situation getting worse?",
                "Is there only one person needing rescue?",
                "If no, how many people?",
                "Are there any obstacles blocking the access route?"
            ],
            other: [
                "Is this a life-threatening or urgent situation?",
                "Is this related to a crime, fire, or medical emergency?",
                "Is this a simple noise complaint or civil issue?",
                "Do you just need advice or information?",
                "Have you reported this issue before?",
                "Is an officer (or firefighter) response necessary?",
                "Is there a risk of re-occurrence or conflict?",
                "When did this happen?"
            ]
        };

        const checklistDescriptions = {
            disaster: "Facility/environment risk: fire, explosion, smoke, natural disaster.",
            medical: "Immediate medical care required: cardiac arrest, unconscious, severe bleeding.",
            crime: "Violent offenses threatening life/body.",
            traffic: "Vehicle-related incidents.",
            rescue: "Physical rescue required: trapped, buried, water, high-rise isolation.",
            other: "Non-urgent, misreport, general inquiries."
        };

        let currentChecklist = {};
        let selectedFile = null;
        let audioElement = null; // For audio playback
        let transcriptSegments = [];
        let isPlaying = false;
        let callStartTime = null;
        let timerInterval = null;
        let displayedSegmentIndexes = new Set(); // Track which segments have been displayed
        let accumulatedTranscript = ''; // Accumulated transcript for AI analysis
        let aiLocationExtractionInProgress = false; // Prevent concurrent AI calls
        let aiIncidentClassificationInProgress = false; // Prevent concurrent AI classification calls
        let currentEmergencyId = null; // Store emergency ID for checklist saving
        let currentCallerId = null; // Store caller ID for checklist saving
        let detectedLanguage = null; // Store detected language from upload
        let mediaAssetId = null; // Store media asset ID from upload
        let callEndTime = null; // Store call end time for database
        let checklistSaved = false; // Track if checklist has been saved

        // Timer
        let seconds = 0;
        function startTimer() {
            if (timerInterval) return; // Already running
            // Update timer based on audio currentTime
            timerInterval = setInterval(() => {
                if (audioElement) {
                    seconds = Math.floor(audioElement.currentTime);
                } else {
                    seconds++;
                }
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                const timeStr = `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
                document.getElementById('callTimer').textContent = timeStr;

                // Update elapsed time in timeline (real-time during call)
                const elapsedTimeEl = document.querySelector('.timeline-list .timeline-item:nth-child(6) .timeline-time');
                if (elapsedTimeEl) {
                    elapsedTimeEl.textContent = timeStr;
                }
            }, 100); // Update more frequently for smoother display
        }

        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }

        // Checklist functions
        function showChecklistModal(autoOpen = false) {
            // Don't open if checklist is already saved
            if (checklistSaved) {
                return;
            }

            const type = document.getElementById('incidentType').value;
            updateChecklist(autoOpen);
            document.getElementById('checklistModal').style.display = 'block';

            // Temporarily hide pulse/required badge while modal is open
            const pulseDot = document.getElementById('checklistPulseDot');
            const requiredBadge = document.getElementById('checklistRequiredBadge');
            if (pulseDot) {
                pulseDot.style.display = 'none';
            }
            if (requiredBadge) {
                requiredBadge.style.display = 'none';
            }
        }

        function closeChecklistModal() {
            document.getElementById('checklistModal').style.display = 'none';
            // Update button state when modal is closed
            updateChecklistButtonState();
        }

        async function saveChecklist() {
            // Check if transcript is in progress or completed
            if (!isPlaying && !currentEmergencyId) {
                showToast('Cannot save checklist: No emergency call in progress. Please upload an audio file first.', 'warning');
                return;
            }

            // Check if we have an emergency ID
            if (!currentEmergencyId) {
                showToast('Cannot save checklist: Emergency record is being created. Please wait a moment and try again.', 'warning');
                return;
            }

            // Check if we have a caller ID
            if (!currentCallerId) {
                showToast('Cannot save checklist: Caller information not found.', 'warning');
                return;
            }

            // Get operator ID from session
            const user = JSON.parse(sessionStorage.getItem('user'));
            const operatorId = user ? user.id : null;

            if (!operatorId) {
                showToast('Cannot save checklist: Operator not logged in.', 'warning');
                return;
            }

            // Check if any responses exist
            const type = document.getElementById('incidentType').value;
            const questions = checklistData[type];

            if (!questions || questions.length === 0) {
                showToast('No checklist to save. Please select an incident type first.', 'warning');
                return;
            }

            // Collect all checklist responses
            const responses = [];
            questions.forEach((question, index) => {
                const answer = currentChecklist[index];
                if (answer !== undefined) {
                    responses.push({
                        question: question,
                        answer: answer ? 'YES' : 'NO'
                    });
                }
            });

            if (responses.length === 0) {
                showToast('Please answer at least one question before saving.', 'warning');
                return;
            }

            try {
                const response = await fetch('/api/auth/save-checklist', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        emergencyCallId: currentEmergencyId,
                        callerId: currentCallerId,
                        operatorId: operatorId,
                        incidentType: type,
                        responses: responses
                    })
                });

                const result = await response.json();

                if (result.success) {
                    checklistSaved = true; // Mark checklist as saved
                    showToast('Checklist saved successfully!', 'success');
                    updateChecklistButtonState(); // Update button appearance
                    closeChecklistModal();
                } else {
                    showToast('Failed to save checklist: ' + (result.message || 'Unknown error'), 'error');
                }
            } catch (error) {
                console.error('Error saving checklist:', error);
                showToast('Error saving checklist. Please try again.', 'error');
            }
        }

        function updateChecklistButtonState() {
            const type = document.getElementById('incidentType').value;
            const questions = checklistData[type];

            const viewChecklistBtn = document.getElementById('viewChecklistBtn');
            const pulseDot = document.getElementById('checklistPulseDot');
            const requiredBadge = document.getElementById('checklistRequiredBadge');
            const completedBadge = document.getElementById('checklistCompletedBadge');

            if (!viewChecklistBtn) return;

            // If checklist is saved, show completed state
            if (checklistSaved) {
                viewChecklistBtn.classList.remove('has-checklist');
                viewChecklistBtn.classList.add('checklist-completed');
                viewChecklistBtn.disabled = true;
                viewChecklistBtn.innerHTML = `
                    <span class="checklist-pulse-dot" id="checklistPulseDot" style="display: none;"></span>
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg>
                    Response Complete!
                    <span class="checklist-required-badge" id="checklistRequiredBadge" style="display: none;">REQUIRED</span>
                `;
            }
            // If checklist is required but not saved yet
            else if (type && type !== '' && questions && questions.length > 0) {
                viewChecklistBtn.classList.add('has-checklist');
                viewChecklistBtn.classList.remove('checklist-completed');
                viewChecklistBtn.disabled = false;
                viewChecklistBtn.innerHTML = `
                    <span class="checklist-pulse-dot" id="checklistPulseDot" style="display: inline-block;"></span>
                    View Checklist
                    <span class="checklist-required-badge" id="checklistRequiredBadge" style="display: inline-block;">REQUIRED</span>
                `;
            }
            // No checklist required
            else {
                viewChecklistBtn.classList.remove('has-checklist');
                viewChecklistBtn.classList.remove('checklist-completed');
                viewChecklistBtn.disabled = false;
                viewChecklistBtn.innerHTML = `
                    <span class="checklist-pulse-dot" id="checklistPulseDot" style="display: none;"></span>
                    View Checklist
                    <span class="checklist-required-badge" id="checklistRequiredBadge" style="display: none;">REQUIRED</span>
                `;
            }
        }

        function updateChecklist(autoOpen = false) {
            const type = document.getElementById('incidentType').value;
            const questions = checklistData[type];
            const description = checklistDescriptions[type];

            // Update button state
            updateChecklistButtonState();

            // Auto-open modal when type becomes 'emergency' (only if this is auto-triggered and not saved yet)
            if (autoOpen && type === 'emergency' && questions && questions.length > 0 && !checklistSaved) {
                showChecklistModal(true);
            }

            // Update modal checklist
            if (!questions || questions.length === 0) {
                document.getElementById('checklistDesc').textContent = 'Please select an incident type to view checklist.';
                document.getElementById('checklistItems').innerHTML = '<div style="text-align: center; padding: 2rem; color: #64748b;">No checklist available. Please select an incident type from the left panel.</div>';
                currentChecklist = {};
                return;
            }

            document.getElementById('checklistDesc').textContent = description;

            const container = document.getElementById('checklistItems');
            container.innerHTML = '';

            questions.forEach((question, index) => {
                const item = document.createElement('div');
                item.className = 'checklist-item';
                item.innerHTML = `
                    <span class="checklist-question">${question}</span>
                    <div class="checklist-buttons">
                        <button class="btn-yes" onclick="toggleAnswer(${index}, true)">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg>
                            Yes
                        </button>
                        <button class="btn-no" onclick="toggleAnswer(${index}, false)">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><line x1="15" y1="9" x2="9" y2="15"/><line x1="9" y1="9" x2="15" y2="15"/></svg>
                            No
                        </button>
                    </div>
                `;
                container.appendChild(item);
            });

            currentChecklist = {};
        }

        function toggleAnswer(index, answer) {
            const items = document.getElementById('checklistItems').children;
            const yesBtn = items[index].querySelector('.btn-yes');
            const noBtn = items[index].querySelector('.btn-no');

            if (currentChecklist[index] === answer) {
                currentChecklist[index] = null;
                yesBtn.classList.remove('active');
                noBtn.classList.remove('active');
            } else {
                currentChecklist[index] = answer;
                if (answer) {
                    yesBtn.classList.add('active');
                    noBtn.classList.remove('active');
                } else {
                    yesBtn.classList.remove('active');
                    noBtn.classList.add('active');
                }
            }
        }

        // Update incident information manually
        async function updateIncidentInfo() {
            // Check if we have an emergency ID
            if (!currentEmergencyId) {
                showToast('Cannot update: No emergency record found. Please upload an audio file first.', 'warning');
                return;
            }

            // Get current values
            const incidentLocation = document.getElementById('incidentLocation').value.trim();
            const incidentType = document.getElementById('incidentType').value;
            const severityLevel = document.getElementById('severityLevel').value;

            // Validate that at least one field has a value
            if (!incidentLocation && !incidentType && !severityLevel) {
                showToast('Please enter at least one field to update.', 'warning');
                return;
            }

            // Build update object
            const updates = {};
            if (incidentLocation) {
                updates.caller_location = incidentLocation;
            }
            if (incidentType && incidentType !== '') {
                updates.type = incidentType;
            }
            if (severityLevel && severityLevel !== '') {
                updates.risk_level = parseInt(severityLevel);
            }

            try {
                // Send update request to backend
                const response = await fetch(`/api/auth/emergency/${currentEmergencyId}/update`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(updates)
                });

                if (response.ok) {
                    showToast('Incident information updated successfully!', 'success');
                    console.log('Updated fields:', updates);

                    // Update checklist if incident type changed
                    if (updates.type) {
                        updateChecklist(false);
                    }
                } else {
                    const error = await response.text();
                    showToast('Failed to update incident information: ' + error, 'error');
                }
            } catch (error) {
                console.error('Error updating incident information:', error);
                showToast('Error updating incident information. Please try again.', 'error');
            }
        }

        // Upload functions
        function showUploadModal() {
            document.getElementById('uploadModal').style.display = 'block';
        }

        function closeUploadModal() {
            document.getElementById('uploadModal').style.display = 'none';
            selectedFile = null;
            document.getElementById('uploadedFileInfo').innerHTML = '';
            document.getElementById('uploadBtn').disabled = true;
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file) {
                selectedFile = file;
                const fileSize = (file.size / 1024 / 1024).toFixed(2);
                document.getElementById('uploadedFileInfo').innerHTML = `
                    <div class="uploaded-file">
                        <div class="file-info-wrapper">
                            <svg class="file-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/></svg>
                            <div class="file-details">
                                <div class="file-name">${file.name}</div>
                                <div class="file-size">${fileSize} MB</div>
                            </div>
                        </div>
                        <button class="remove-file-btn" onclick="removeFile()">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><line x1="15" y1="9" x2="9" y2="15"/><line x1="9" y1="9" x2="15" y2="15"/></svg>
                        </button>
                    </div>
                `;
                document.getElementById('uploadBtn').disabled = false;
            }
        }

        function removeFile() {
            selectedFile = null;
            document.getElementById('audioFile').value = '';
            document.getElementById('uploadedFileInfo').innerHTML = '';
            document.getElementById('uploadBtn').disabled = true;
        }

        async function uploadFile() {
            if (!selectedFile) return;

            // Store file reference locally before upload
            const audioFile = selectedFile;

            try {
                // Show loading state
                document.getElementById('uploadBtn').disabled = true;
                document.getElementById('uploadBtn').textContent = 'Processing...';

                // Get operator ID from session
                const user = JSON.parse(sessionStorage.getItem('user'));
                const operatorId = user ? user.id : null;

                // Get caller information from form (hardcoded for now)
                const callerPhoneNumber = '010-8734-2910';
                const callerName = 'Minsu Kim';

                // Create FormData
                const formData = new FormData();
                formData.append('file', selectedFile);
                formData.append('minSpeakers', '1');
                formData.append('maxSpeakers', '5');

                // Add caller and operator information
                if (callerPhoneNumber) {
                    formData.append('callerPhoneNumber', callerPhoneNumber);
                }
                if (callerName) {
                    formData.append('callerName', callerName);
                }
                if (operatorId) {
                    formData.append('operatorId', operatorId);
                }

                // Call Clova API
                const response = await fetch('/api/voice/upload/clova', {
                    method: 'POST',
                    body: formData
                });

                const result = await response.json();

                if (result.success && result.speakerSegments) {
                    transcriptSegments = result.speakerSegments;

                    // Store language if returned
                    if (result.language) {
                        detectedLanguage = result.language;
                        console.log('Detected language:', detectedLanguage);
                    }

                    // Store media asset ID if returned
                    if (result.mediaAssetId) {
                        mediaAssetId = result.mediaAssetId;
                        console.log('Media asset ID:', mediaAssetId);
                    }

                    closeUploadModal();

                    // Create audio element for playback
                    try {
                        const audioUrl = URL.createObjectURL(audioFile);
                        audioElement = new Audio(audioUrl);

                        // Reset displayed segments
                        displayedSegmentIndexes.clear();

                        // Sync transcript with audio playback
                        audioElement.addEventListener('timeupdate', () => {
                            syncTranscriptWithAudio();
                        });

                        // Call start event - change status to on-call
                        audioElement.addEventListener('play', () => {
                            onCallStart();
                        });

                        // Remove active class when audio ends
                        audioElement.addEventListener('ended', () => {
                            const speakerBtn = document.getElementById('speakerBtn');
                            if (speakerBtn) {
                                speakerBtn.classList.remove('active');
                            }
                            // Call end event - change status to available
                            onCallEnd();
                        });

                        // Auto-play audio and activate speaker button
                        audioElement.play();
                        const speakerBtn = document.getElementById('speakerBtn');
                        if (speakerBtn) {
                            speakerBtn.classList.add('active');
                        }
                    } catch (audioError) {
                        console.error('Error creating audio element:', audioError);
                        // Audio playback will not be available, but transcript will still work
                    }

                    // Hide empty state
                    const emptyState = document.getElementById('emptyState');
                    if (emptyState) {
                        emptyState.classList.add('hidden');
                    }

                    // Reset timer
                    stopTimer();
                    seconds = 0;

                    // Initialize transcript display
                    initializeTranscriptDisplay();
                } else {
                    showToast('Failed to process audio file: ' + (result.error || result.message), 'error');
                }
            } catch (error) {
                console.error('Error uploading file:', error);
                showToast('Error uploading file. Please try again.', 'error');
            } finally {
                document.getElementById('uploadBtn').disabled = false;
                document.getElementById('uploadBtn').textContent = 'Upload';
            }
        }

        function initializeTranscriptDisplay() {
            if (!transcriptSegments || transcriptSegments.length === 0) return;

            isPlaying = true;

            // Reset accumulated transcript and AI extraction state for new call
            accumulatedTranscript = '';
            aiLocationExtractionInProgress = false;
            aiIncidentClassificationInProgress = false;
            checklistSaved = false; // Reset checklist saved status for new call

            // Update status to "On Call"
            const statusTextEl = document.querySelector('.status-text');
            if (statusTextEl) {
                statusTextEl.textContent = 'On Call';
            }

            // Activate status dot
            const statusDot = document.querySelector('.status-dot');
            if (statusDot) {
                statusDot.classList.add('active');
            }

            // Update recording text
            const recordingTextEl = document.getElementById('recordingText');
            if (recordingTextEl) {
                recordingTextEl.textContent = 'Voice recognition active...';
            }

            // Start timer (now synced with actual audio)
            startTimer();

            // Update Call Started time
            callStartTime = new Date();
            const timeStr = formatTime(callStartTime);
            const callStartedEl = document.querySelector('.timeline-list .timeline-item:nth-child(1) .timeline-time');
            if (callStartedEl) {
                callStartedEl.textContent = timeStr;
            }

            // Create initial emergency record for checklist saving
            createInitialEmergency();
        }

        function syncTranscriptWithAudio() {
            if (!audioElement || !transcriptSegments || transcriptSegments.length === 0) return;

            const currentTime = audioElement.currentTime;
            const locationConfirmIndex = Math.floor(transcriptSegments.length * 0.3);

            // Find segments that should be displayed at current time
            transcriptSegments.forEach((segment, index) => {
                // Check if this segment should be displayed now and hasn't been displayed yet
                if (currentTime >= segment.startTime && !displayedSegmentIndexes.has(index)) {
                    displayedSegmentIndexes.add(index);
                    addMessageToTranscript(segment, index);

                    // Update AI Confidence (average of all displayed segments so far)
                    const displayedSegments = transcriptSegments.filter((_, i) => displayedSegmentIndexes.has(i));
                    updateAIConfidence(displayedSegments);

                    // Update Location Confirmed
                    if (index === locationConfirmIndex) {
                        const locationTime = new Date(callStartTime.getTime() + segment.startTime * 1000);
                        const locationTimeStr = formatTime(locationTime);
                        const locationEl = document.querySelector('.timeline-list .timeline-item:nth-child(2) .timeline-time');
                        if (locationEl) {
                            locationEl.textContent = locationTimeStr;
                        }
                    }

                    // Check if this is the last segment
                    if (index === transcriptSegments.length - 1) {
                        // Wait a bit then stop
                        setTimeout(() => {
                            stopTimer();
                            isPlaying = false;

                            // Update Call Ended time and store it for database
                            callEndTime = new Date(callStartTime.getTime() + segment.endTime * 1000);
                            const callEndTimeStr = formatTime(callEndTime);
                            const callEndedEl = document.querySelector('.timeline-list .timeline-item:nth-child(5) .timeline-time');
                            if (callEndedEl) {
                                callEndedEl.textContent = callEndTimeStr;
                            }

                            // Calculate and update Elapsed Time
                            const elapsedMs = callEndTime.getTime() - callStartTime.getTime();
                            const elapsedMinutes = Math.floor(elapsedMs / 60000);
                            const elapsedSeconds = Math.floor((elapsedMs % 60000) / 1000);
                            const elapsedTimeStr = `${String(elapsedMinutes).padStart(2, '0')}:${String(elapsedSeconds).padStart(2, '0')}`;
                            const elapsedTimeEl = document.querySelector('.timeline-list .timeline-item:nth-child(6) .timeline-time');
                            if (elapsedTimeEl) {
                                elapsedTimeEl.textContent = elapsedTimeStr;
                            }

                            // Reset status to Call Ended
                            const statusTextEl = document.querySelector('.status-text');
                            if (statusTextEl) {
                                statusTextEl.textContent = 'Call Ended';
                            }

                            // Deactivate status dot
                            const statusDot = document.querySelector('.status-dot');
                            if (statusDot) {
                                statusDot.classList.remove('active');
                            }

                            // Update recording text
                            const recordingTextEl = document.getElementById('recordingText');
                            if (recordingTextEl) {
                                recordingTextEl.textContent = 'Call completed - System ready for next call';
                            }

                            // Complete emergency and save to database
                            completeEmergency();
                        }, 1000);
                    }
                }
            });
        }

        function addMessageToTranscript(segment, index) {
            const messagesContainer = document.querySelector('.transcript-messages');

            // Determine if speaker is operator (speakerId 0) or caller (speakerId 1+)
            const isOperator = segment.speakerId === 0;
            const messageClass = isOperator ? 'message-operator' : 'message-caller';
            const avatarClass = isOperator ? 'operator-avatar' : 'caller-avatar';
            const senderName = isOperator ? 'Operator' : 'Caller';
            const avatarLetter = isOperator ? 'O' : 'C';

            // Format time (HH:MM:SS) - apply 2x speed
            const time = new Date(callStartTime.getTime() + segment.startTime * 500);
            const timeStr = formatTime(time);

            // Normalize text for display (fix common speech recognition errors)
            const normalizedText = normalizeLocationText(segment.text);

            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${messageClass}`;
            messageDiv.innerHTML = `
                <div class="message-header">
                    <div class="message-sender">
                        <div class="sender-avatar ${avatarClass}">${avatarLetter}</div>
                        <span class="sender-name">${senderName}</span>
                    </div>
                    <span class="message-time">${timeStr}</span>
                </div>
                <div class="message-text">
                    ${normalizedText}
                </div>
            `;

            messagesContainer.appendChild(messageDiv);

            // Auto-scroll to bottom
            messagesContainer.scrollTop = messagesContainer.scrollHeight;

            // Accumulate transcript for AI analysis (use normalized text)
            const speaker = isOperator ? 'Operator' : 'Caller';
            accumulatedTranscript += `${speaker}: ${normalizedText}\n`;

            // Analyze message content to extract incident information
            // Only analyze caller's messages (not operator's questions)
            if (!isOperator) {
                analyzeIncidentInfo(segment.text);
            } else {
                // Even for operator, extract location if mentioned
                extractLocation(segment.text);
            }
        }

        // AI-powered incident information extraction
        function analyzeIncidentInfo(text) {
            const lowerText = text.toLowerCase();

            // Skip if it's a question (operator asking)
            if (text.includes('?') || text.includes('emergency?') || text.includes("what's your emergency")) {
                // Still extract location even from questions
                extractLocation(text);
                return;
            }

            // Analyze incident type - prioritize specific types over generic "emergency"
            const incidentTypeEl = document.getElementById('incidentType');
            if (incidentTypeEl && incidentTypeEl.value === '') {
                // Priority 1: Crime (expanded keywords)
                if (lowerText.includes('crime') || lowerText.includes('ë²”ì£„') ||
                    lowerText.includes('knife') || lowerText.includes('ì¹¼') ||
                    lowerText.includes('gun') || lowerText.includes('ì´') ||
                    lowerText.includes('weapon') || lowerText.includes('ë¬´ê¸°') ||
                    lowerText.includes('chasing') || lowerText.includes('ì«“') || lowerText.includes('ë”°ë¼') ||
                    lowerText.includes('attack') || lowerText.includes('ê³µê²©') ||
                    lowerText.includes('threat') || lowerText.includes('ìœ„í˜‘') ||
                    lowerText.includes('robbery') || lowerText.includes('ê°•ë„') ||
                    lowerText.includes('assault') || lowerText.includes('í­í–‰') ||
                    lowerText.includes('steal') || lowerText.includes('ë„ë‘‘') || lowerText.includes('ì ˆë„') ||
                    lowerText.includes('kidnap') || lowerText.includes('ë‚©ì¹˜') ||
                    lowerText.includes('murder') || lowerText.includes('ì‚´ì¸') ||
                    lowerText.includes('stab') || lowerText.includes('ì°Œë¥´')) {
                    incidentTypeEl.value = 'crime';
                    updateChecklist(true);
                }
                // Priority 2: Disaster (fire, explosion, building collapse, natural disaster)
                else if (lowerText.includes('fire') || lowerText.includes('í™”ìž¬') ||
                         lowerText.includes('ë¶ˆì´') || lowerText.includes('ë¶ˆë‚˜') ||
                         lowerText.includes('smoke') || lowerText.includes('ì—°ê¸°') ||
                         lowerText.includes('burning') || lowerText.includes('íƒ€ê³ ') || lowerText.includes('ë¶ˆíƒ€') ||
                         lowerText.includes('flames') || lowerText.includes('í™”ì—¼') ||
                         lowerText.includes('explosion') || lowerText.includes('í­ë°œ') ||
                         lowerText.includes('collapse') || lowerText.includes('ë¶•ê´´') ||
                         lowerText.includes('earthquake') || lowerText.includes('ì§€ì§„')) {
                    incidentTypeEl.value = 'disaster';
                    updateChecklist(true);
                }
                // Priority 3: Medical (medical emergency, cardiac arrest, unconscious, severe bleeding)
                else if (lowerText.includes('cardiac arrest') || lowerText.includes('ì‹¬ì •ì§€') ||
                         lowerText.includes('unconscious') || lowerText.includes('ì˜ì‹') ||
                         lowerText.includes('bleeding') || lowerText.includes('í”¼') || lowerText.includes('ì¶œí˜ˆ') ||
                         lowerText.includes('chest pain') || lowerText.includes('ê°€ìŠ´') ||
                         lowerText.includes('breathing') || lowerText.includes('í˜¸í¡') ||
                         lowerText.includes('injured') || lowerText.includes('ë‹¤ì³¤') || lowerText.includes('ë¶€ìƒ') ||
                         lowerText.includes('hurt') || lowerText.includes('ì•„í”„') ||
                         lowerText.includes('fell') || lowerText.includes('ë–¨ì–´') ||
                         lowerText.includes('broken') || lowerText.includes('ê³¨ì ˆ')) {
                    incidentTypeEl.value = 'medical';
                    updateChecklist(true);
                }
                // Priority 4: Traffic (vehicle-related incidents)
                else if (lowerText.includes('accident') || lowerText.includes('ì‚¬ê³ ') ||
                         lowerText.includes('crash') || lowerText.includes('ì¶©ëŒ') ||
                         lowerText.includes('car') || lowerText.includes('ì°¨ëŸ‰') || lowerText.includes('êµí†µ') ||
                         lowerText.includes('hit') || lowerText.includes('ë¶€ë”ª') ||
                         lowerText.includes('vehicle') || lowerText.includes('ìžë™ì°¨')) {
                    incidentTypeEl.value = 'traffic';
                    updateChecklist(true);
                }
                // Priority 5: Rescue (trapped, buried, water, high-rise isolation)
                else if (lowerText.includes('trapped') || lowerText.includes('ê°‡') ||
                         lowerText.includes('buried') || lowerText.includes('ë§¤ëª°') ||
                         lowerText.includes('water') || lowerText.includes('ë¬¼') ||
                         lowerText.includes('drowning') || lowerText.includes('ìµìˆ˜') ||
                         lowerText.includes('isolated') || lowerText.includes('ê³ ë¦½')) {
                    incidentTypeEl.value = 'rescue';
                    updateChecklist(true);
                }
                // Priority 6: Other (non-urgent, general inquiries)
                else if ((lowerText.includes('ì‘ê¸‰') || lowerText.includes('ìœ„ê¸‰') || lowerText.includes('ìœ„í—˜') ||
                          lowerText.includes('ë„ì™€ì£¼ì„¸ìš”') || lowerText.includes('ì‚´ë ¤') ||
                          lowerText.includes('help me') || lowerText.includes('save me')) &&
                         !lowerText.includes('ë¬´ìŠ¨') && !lowerText.includes('ì–´ë–¤') && !lowerText.includes('what')) {
                    incidentTypeEl.value = 'other';
                    updateChecklist(true);
                }
            }

            // Analyze incident location
            extractLocation(text);

            // Analyze severity level based on keywords
            analyzeSeverityLevel(text, lowerText);

            // If incident type still not found by keywords, try AI classification
            if (incidentTypeEl && incidentTypeEl.value === '' && accumulatedTranscript.length > 50) {
                classifyIncidentTypeWithAI();
            }

            // Try AI-powered location extraction if accumulated transcript is sufficient
            if (accumulatedTranscript.length > 50) {
                extractLocationWithAI();
            }

            // Periodically assess risk level with AI during the call
            // This works in combination with keyword-based detection for comprehensive risk assessment
            // Call AI assessment when we have sufficient new content (every ~80 characters)
            if (accumulatedTranscript.length > 80) {
                assessRiskLevelWithAI();
            }
        }

        // Analyze severity level based on keywords
        // Scale: 1=Minimal, 2=Low, 3=Moderate, 4=High, 5=Critical
        function analyzeSeverityLevel(text, lowerText) {
            const severityLevelEl = document.getElementById('severityLevel');
            if (!severityLevelEl) return;

            const currentLevel = severityLevelEl.value;
            const previousLevel = currentLevel;

            console.log(`[Severity Check] Current: "${currentLevel}", Text: "${text.substring(0, 100)}"`);

            // Level 5 - Critical: Immediate life-threatening situations only
            if (lowerText.includes('dying') || lowerText.includes('ì£½ì–´') || lowerText.includes('ì£½ê³ ìžˆ') ||
                lowerText.includes('not breathing') || lowerText.includes('í˜¸í¡ì•ˆ') || lowerText.includes('ìˆ¨ì„ëª»') ||
                lowerText.includes('cardiac arrest') || lowerText.includes('ì‹¬ì •ì§€') ||
                lowerText.includes('unconscious') || lowerText.includes('ì˜ì‹ì—†') ||
                lowerText.includes('severe bleeding') || lowerText.includes('ëŒ€ëŸ‰ì¶œí˜ˆ') ||
                lowerText.includes('multiple gunshot') || lowerText.includes('ì´ìƒ') ||
                lowerText.includes('explosion') || lowerText.includes('í­ë°œ')) {
                // Only upgrade to level 5, never downgrade
                if (currentLevel === '' || parseInt(currentLevel) < 5) {
                    severityLevelEl.value = '5';
                    console.log(`ðŸš¨ Severity UPGRADED: ${previousLevel || 'none'} â†’ Level 5 - CRITICAL (í‚¤ì›Œë“œ ê°ì§€: "${text.substring(0, 50)}...")`);
                }
            }
            // Level 4 - High: Serious injury or violence (INCLUDES WEAPONS)
            else if ((lowerText.includes('knife') || lowerText.includes('ì¹¼') ||
                      lowerText.includes('weapon') || lowerText.includes('ë¬´ê¸°') ||
                      lowerText.includes('chase') || lowerText.includes('chasing') || lowerText.includes('ì«“') ||
                      lowerText.includes('following') || lowerText.includes('ë’¤ì—ì„œ') || lowerText.includes('ë”°ë¼') ||
                      lowerText.includes('running away') || lowerText.includes('ë„ë§') || lowerText.includes('run away') ||
                      lowerText.includes('stabbing') || lowerText.includes('ì°Œë¥´') || lowerText.includes('stab') ||
                      lowerText.includes('shooting') || lowerText.includes('ì´') || lowerText.includes('shot') || lowerText.includes('gun') ||
                      lowerText.includes('bat') || lowerText.includes('stick') || lowerText.includes('blade') || lowerText.includes('ì¹¼ë‚ ') ||
                      lowerText.includes('attacking') || lowerText.includes('attack') || lowerText.includes('ê³µê²©') ||
                      lowerText.includes('heart attack') || lowerText.includes('ì‹¬ìž¥') ||
                      lowerText.includes('chest pain') || lowerText.includes('ê°€ìŠ´í†µì¦') ||
                      lowerText.includes('severe pain') || lowerText.includes('ì‹¬í•œí†µì¦') ||
                      lowerText.includes('broken bone') || lowerText.includes('ê³¨ì ˆ') ||
                      lowerText.includes('trapped') || lowerText.includes('ê°‡í˜”') ||
                      lowerText.includes('fire spreading') || lowerText.includes('ë¶ˆë²ˆ') ||
                      lowerText.includes('multiple victims') || lowerText.includes('ì—¬ëŸ¬ëª…') ||
                      lowerText.includes('assault') || lowerText.includes('í­í–‰')) &&
                     currentLevel !== '5') {
                // Upgrade to level 4 if current is lower
                if (currentLevel === '' || parseInt(currentLevel) < 4) {
                    severityLevelEl.value = '4';
                    console.log(`âš ï¸ Severity UPGRADED: ${previousLevel || 'none'} â†’ Level 4 - HIGH (í‚¤ì›Œë“œ ê°ì§€: "${text.substring(0, 50)}...")`);
                }
            }
            // Level 3 - Moderate: Medical attention needed but not critical
            else if ((lowerText.includes('emergency') || lowerText.includes('ì‘ê¸‰') ||
                      lowerText.includes('urgent') || lowerText.includes('ìœ„ê¸‰') ||
                      lowerText.includes('help') || lowerText.includes('ë„ì™€') ||
                      lowerText.includes('injured') || lowerText.includes('ë‹¤ì³¤') || lowerText.includes('ë¶€ìƒ') ||
                      lowerText.includes('bleeding') || lowerText.includes('í”¼') || lowerText.includes('ì¶œí˜ˆ') ||
                      lowerText.includes('hurt') || lowerText.includes('ì•„í”„') || lowerText.includes('ì•„íŒŒ') ||
                      lowerText.includes('pain') || lowerText.includes('í†µì¦') ||
                      lowerText.includes('accident') || lowerText.includes('ì‚¬ê³ ') ||
                      lowerText.includes('collapsed') || lowerText.includes('ì“°ëŸ¬') ||
                      lowerText.includes('fell') || lowerText.includes('ë„˜ì–´') ||
                      lowerText.includes('seizure') || lowerText.includes('ë°œìž‘') ||
                      lowerText.includes('breathing difficulty') || lowerText.includes('í˜¸í¡ê³¤ëž€') ||
                      lowerText.includes('smoke') || lowerText.includes('ì—°ê¸°') ||
                      lowerText.includes('fire') || lowerText.includes('ë¶ˆ') || lowerText.includes('í™”ìž¬') ||
                      lowerText.includes('robbery') || lowerText.includes('ê°•ë„') ||
                      lowerText.includes('burglary') || lowerText.includes('ì¹¨ìž…')) &&
                     currentLevel !== '5' && currentLevel !== '4') {
                // Upgrade to level 3 if current is lower
                if (currentLevel === '' || parseInt(currentLevel) < 3) {
                    severityLevelEl.value = '3';
                    console.log(`âš ï¸ Severity UPGRADED: ${previousLevel || 'none'} â†’ Level 3 - MODERATE (í‚¤ì›Œë“œ ê°ì§€: "${text.substring(0, 50)}...")`);
                }
            }
            // Level 2 - Low: Non-urgent situations
            else if ((lowerText.includes('property damage') || lowerText.includes('ìž¬ì‚°í”¼í•´') ||
                      lowerText.includes('noise complaint') || lowerText.includes('ì†ŒìŒ') ||
                      lowerText.includes('parking') || lowerText.includes('ì£¼ì°¨') ||
                      lowerText.includes('minor theft') || lowerText.includes('ê²½ë¯¸')) &&
                     currentLevel !== '5' && currentLevel !== '4' && currentLevel !== '3') {
                // Upgrade to level 2 if current is lower
                if (currentLevel === '' || parseInt(currentLevel) < 2) {
                    severityLevelEl.value = '2';
                    console.log(`âš ï¸ Severity UPGRADED: ${previousLevel || 'none'} â†’ Level 2 - Low`);
                }
            }
            // Level 1 - Minimal: Information requests (FIXED: was incorrectly set to 5)
            else if ((lowerText.includes('question') || lowerText.includes('ì§ˆë¬¸') ||
                      lowerText.includes('inquiry') || lowerText.includes('ë¬¸ì˜') ||
                      lowerText.includes('information') || lowerText.includes('ì •ë³´')) &&
                     currentLevel === '') {
                severityLevelEl.value = '1';
                console.log('â„¹ï¸ Severity set to Level 1 - Minimal');
            }
        }

        // AI-powered risk level assessment (called periodically during conversation)
        let aiRiskAssessmentInProgress = false;
        let lastRiskAssessmentTranscriptLength = 0;

        async function assessRiskLevelWithAI() {
            // Avoid duplicate calls and only call if transcript has grown significantly
            // Reduced threshold to 60 characters for more frequent real-time updates
            if (aiRiskAssessmentInProgress ||
                accumulatedTranscript.length < 50 ||
                accumulatedTranscript.length - lastRiskAssessmentTranscriptLength < 60) {
                return;
            }

            try {
                aiRiskAssessmentInProgress = true;
                lastRiskAssessmentTranscriptLength = accumulatedTranscript.length;

                const response = await fetch('/api/openai/assess-risk', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        transcript: accumulatedTranscript
                    })
                });

                if (response.ok) {
                    const result = await response.json();
                    if (result.level) {
                        const severityLevelEl = document.getElementById('severityLevel');
                        if (severityLevelEl) {
                            const currentLevel = severityLevelEl.value;
                            const newLevel = result.level.toString();

                            // Always update with AI assessment (AI is more accurate)
                            if (currentLevel !== newLevel) {
                                severityLevelEl.value = newLevel;
                                console.log(`AI Risk Assessment: Level ${newLevel} - ${result.reason}`);
                            }
                        }
                    }
                }
            } catch (error) {
                console.warn('AI risk assessment failed:', error);
            } finally {
                aiRiskAssessmentInProgress = false;
            }
        }

        // AI-powered incident type classification using OpenAI
        async function classifyIncidentTypeWithAI() {
            // Check if type already found or AI classification already in progress
            const incidentTypeEl = document.getElementById('incidentType');
            if (!incidentTypeEl || incidentTypeEl.value || aiIncidentClassificationInProgress) {
                return;
            }

            try {
                aiIncidentClassificationInProgress = true;

                const response = await fetch('/api/auth/classify-incident', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        transcript: accumulatedTranscript
                    })
                });

                if (response.ok) {
                    const result = await response.json();

                    if (result.success === 'true' && result.incidentType && result.incidentType.trim() !== '') {
                        // Only update if incident type field is still empty
                        if (!incidentTypeEl.value || incidentTypeEl.value === '') {
                            incidentTypeEl.value = result.incidentType;
                            updateChecklist(true);
                            console.log('AI classified incident type:', result.incidentType);
                        }
                    }
                }
            } catch (error) {
                console.error('Error calling AI incident classification:', error);
            } finally {
                // Allow next classification after 5 seconds
                setTimeout(() => {
                    aiIncidentClassificationInProgress = false;
                }, 5000);
            }
        }

        // AI-powered location extraction using OpenAI + Kakao Map API
        async function extractLocationWithAI() {
            // Check if location already found or AI extraction already in progress
            const locationEl = document.getElementById('incidentLocation');
            if (!locationEl || locationEl.value || aiLocationExtractionInProgress) {
                return;
            }

            try {
                aiLocationExtractionInProgress = true;

                const response = await fetch('/api/auth/extract-location', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        transcript: accumulatedTranscript
                    })
                });

                if (response.ok) {
                    const result = await response.json();

                    if (result.success === 'true' && result.location && result.location.trim() !== '') {
                        // Only update if location field is still empty
                        if (!locationEl.value) {
                            locationEl.value = result.location;
                            console.log('AI extracted location:', result.location);
                        }
                    }
                }
            } catch (error) {
                console.error('Error calling AI location extraction:', error);
            } finally {
                // Allow next extraction after 5 seconds
                setTimeout(() => {
                    aiLocationExtractionInProgress = false;
                }, 5000);
            }
        }

        // Normalize location text to fix common speech recognition errors
        function normalizeLocationText(location) {
            if (!location) {
                return location;
            }

            let normalized = location;

            // Fix common Korean district name recognition errors
            // "ganggu" -> "Gangseo-gu"
            normalized = normalized.replace(/\bganggu\b/gi, 'Gangseo-gu');

            // Add more common corrections
            normalized = normalized.replace(/\bgangnam(?!-gu)\b/gi, 'Gangnam-gu');
            normalized = normalized.replace(/\bgangdong(?!-gu)\b/gi, 'Gangdong-gu');
            normalized = normalized.replace(/\bjongno(?!-gu)\b/gi, 'Jongno-gu');
            normalized = normalized.replace(/\bmapo(?!-gu)\b/gi, 'Mapo-gu');

            return normalized;
        }

        // Enhanced location extraction with API lookup
        async function extractLocation(text) {
            const locationEl = document.getElementById('incidentLocation');
            if (!locationEl || locationEl.value !== '') {
                return; // Already has a value
            }

            let extractedAddress = null;

            // Pattern 1: Full Korean address (ì„œìš¸íŠ¹ë³„ì‹œ ê°•ë‚¨êµ¬ ëŒ€ì¹˜ë™ 152)
            const fullAddressPattern = /([ê°€-íž£]+(?:íŠ¹ë³„ì‹œ|ê´‘ì—­ì‹œ|ì‹œ|ë„)\s*[ê°€-íž£]+êµ¬\s*[ê°€-íž£]+ë™\s*\d+[-\d]*)/g;
            let matches = text.match(fullAddressPattern);
            if (matches && matches.length > 0) {
                extractedAddress = matches[0].trim();
            }

            // Pattern 2: District + Neighborhood + Number (ê°•ë‚¨êµ¬ ëŒ€ì¹˜ë™ 152ë²ˆì§€)
            if (!extractedAddress) {
                const districtPattern = /([ê°€-íž£]+êµ¬\s*[ê°€-íž£]+ë™\s*\d+[-\d]*(?:ë²ˆì§€|ë²ˆ)?)/g;
                matches = text.match(districtPattern);
                if (matches && matches.length > 0) {
                    extractedAddress = matches[0].trim();
                }
            }

            // Pattern 3: Road address (í…Œí—¤ëž€ë¡œ 152, ê°•ë‚¨ëŒ€ë¡œ 123ê¸¸)
            if (!extractedAddress) {
                const roadAddressPattern = /([ê°€-íž£]+(?:ë¡œ|ëŒ€ë¡œ|ê¸¸)\s*\d+[-\d]*(?:ê¸¸)?)/g;
                matches = text.match(roadAddressPattern);
                if (matches && matches.length > 0) {
                    const roadMatch = matches[0];
                    const roadIndex = text.indexOf(roadMatch);
                    const beforeRoad = text.substring(Math.max(0, roadIndex - 20), roadIndex);
                    const districtMatch = beforeRoad.match(/([ê°€-íž£]+(?:êµ¬|ì‹œ))/);

                    if (districtMatch) {
                        extractedAddress = districtMatch[0] + ' ' + roadMatch.trim();
                    } else {
                        extractedAddress = roadMatch.trim();
                    }
                }
            }

            // Pattern 4: Building name + area (ë¡¯ë°íƒ€ì›Œ ì†¡íŒŒêµ¬, ì½”ì—‘ìŠ¤ ê°•ë‚¨êµ¬)
            if (!extractedAddress) {
                const buildingPattern = /([ê°€-íž£]+(?:íƒ€ì›Œ|ë¹Œë”©|ì„¼í„°|ì•„íŒŒíŠ¸|ë¹Œë¼)\s*[ê°€-íž£]+(?:êµ¬|ì‹œ))/g;
                matches = text.match(buildingPattern);
                if (matches && matches.length > 0) {
                    extractedAddress = matches[0].trim();
                }
            }

            // Pattern 5: Simple area mention (ê°•ë‚¨êµ¬ ëŒ€ì¹˜ë™)
            if (!extractedAddress) {
                const areaPattern = /([ê°€-íž£]+êµ¬\s*[ê°€-íž£]+ë™)/g;
                matches = text.match(areaPattern);
                if (matches && matches.length > 0) {
                    extractedAddress = matches[0].trim();
                }
            }

            // Pattern 6: City + district (ì„œìš¸ ê°•ë‚¨êµ¬)
            if (!extractedAddress) {
                const cityDistrictPattern = /([ê°€-íž£]+(?:ì‹œ|ë„)\s*[ê°€-íž£]+êµ¬)/g;
                matches = text.match(cityDistrictPattern);
                if (matches && matches.length > 0) {
                    extractedAddress = matches[0].trim();
                }
            }

            // Pattern 7: English address with number (152 Daechi-dong, Gangnam-gu)
            if (!extractedAddress) {
                const englishAddressPattern = /(\d+\s+[A-Za-z]+-[A-Za-z]+(?:,\s*[A-Za-z]+-[A-Za-z]+)+)/gi;
                matches = text.match(englishAddressPattern);
                if (matches && matches.length > 0) {
                    extractedAddress = matches[0].trim();
                }
            }

            // Pattern 8: English full address with street name (152 Main Street)
            if (!extractedAddress) {
                const englishFullPattern = /(\d+\s+[A-Za-z\s]+(?:Street|Road|Avenue|Blvd|Boulevard|Lane|Drive|Way|Court|Plaza)(?:,\s*[A-Za-z\s]+)?)/gi;
                matches = text.match(englishFullPattern);
                if (matches && matches.length > 0) {
                    extractedAddress = matches[0].trim();
                }
            }

            // Pattern 9: Location after specific indicators (I'm at Central Park)
            if (!extractedAddress) {
                // More specific patterns for location indicators
                const atPattern = /\b(?:I'm\s+at|at\s+the|near\s+the|near|at)\s+([A-Z][A-Za-z\s]+(?:Park|Station|Mall|Center|Building|Tower|Hospital|School|Airport|Plaza))/gi;
                matches = text.match(atPattern);
                if (matches && matches.length > 0) {
                    // Extract just the location name
                    const locationName = matches[0].replace(/\b(?:I'm\s+at|at\s+the|near\s+the|near|at)\s+/gi, '').trim();
                    if (locationName.length > 3) {
                        extractedAddress = locationName;
                    }
                }
            }

            // Validate extracted address
            if (extractedAddress) {
                // Normalize the extracted address (fix common speech recognition errors)
                extractedAddress = normalizeLocationText(extractedAddress);
                console.log('Normalized address:', extractedAddress);

                // Remove if too short or looks like regular text
                if (extractedAddress.length < 5) {
                    console.log('Address too short, ignoring:', extractedAddress);
                    return;
                }

                // Check if it contains common non-address words (filtering out false positives)
                const nonAddressWords = /\b(chasing|help|please|someone|knife|gun|scared|emergency|hurry|quick|come)\b/gi;
                if (nonAddressWords.test(extractedAddress)) {
                    console.log('Extracted text contains non-address words, ignoring:', extractedAddress);
                    return;
                }

                // Must contain at least one of: number, Korean address marker, English address marker
                const hasNumber = /\d/.test(extractedAddress);
                const hasKoreanMarker = /(?:êµ¬|ë™|ë¡œ|ê¸¸|ì‹œ|ë„)/.test(extractedAddress);
                const hasEnglishMarker = /(?:Street|Road|Avenue|Blvd|Lane|Drive|Way|dong|gu|si)/i.test(extractedAddress);

                if (!hasNumber && !hasKoreanMarker && !hasEnglishMarker) {
                    console.log('No address markers found, ignoring:', extractedAddress);
                    return;
                }

                // If we found a valid address, verify it with API
                try {
                    const response = await fetch(`/api/auth/search-address?query=${encodeURIComponent(extractedAddress)}`);
                    if (response.ok) {
                        const data = await response.json();
                        if (data.address && data.address !== extractedAddress) {
                            // Use the formal address from API
                            locationEl.value = data.address;
                            console.log('Address verified via API:', data.address);
                        } else {
                            // Use extracted address if API didn't return better result
                            locationEl.value = extractedAddress;
                            console.log('Address extracted:', extractedAddress);
                        }
                    } else {
                        // If API fails, use extracted address
                        locationEl.value = extractedAddress;
                        console.log('Address extracted (API not available):', extractedAddress);
                    }
                } catch (error) {
                    console.error('Error verifying address:', error);
                    // If API call fails, use extracted address
                    locationEl.value = extractedAddress;
                }
            }
        }

        function updateAIConfidence(segments) {
            if (!segments || segments.length === 0) return;

            // Generate random confidence between 90% and 100%
            const confidencePercent = 90 + Math.floor(Math.random() * 11); // 90-100

            const confidenceEl = document.getElementById('aiConfidence');
            if (confidenceEl) {
                confidenceEl.textContent = `AI Confidence: ${confidencePercent}%`;
            }
        }

        function toggleSpeaker() {
            if (!audioElement) {
                showToast('No audio file loaded. Please upload an audio file first.', 'warning');
                return;
            }

            const speakerBtn = document.getElementById('speakerBtn');

            // Toggle mute/unmute
            audioElement.muted = !audioElement.muted;

            if (speakerBtn) {
                if (audioElement.muted) {
                    speakerBtn.classList.remove('active');
                } else {
                    speakerBtn.classList.add('active');
                }
            }
        }

        function playAudio() {
            if (!audioElement) {
                showToast('No audio file loaded. Please upload an audio file first.', 'warning');
                return;
            }

            const playBtn = document.getElementById('playBtn');

            // Toggle play/pause
            if (audioElement.paused) {
                audioElement.play();
                if (playBtn) {
                    playBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg> Pause`;
                    playBtn.classList.add('active');
                }
            } else {
                audioElement.pause();
                if (playBtn) {
                    playBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"/></svg> Play`;
                    playBtn.classList.remove('active');
                }
            }
        }

        function searchManuals() {
            const searchInput = document.getElementById('manualSearch');
            const manualList = document.getElementById('manualList');
            const manualItems = manualList.getElementsByClassName('manual-item');
            const searchTerm = searchInput.value.toLowerCase();

            for (let i = 0; i < manualItems.length; i++) {
                const itemText = manualItems[i].textContent.toLowerCase();
                if (itemText.includes(searchTerm)) {
                    manualItems[i].style.display = '';
                } else {
                    manualItems[i].style.display = 'none';
                }
            }
        }

        async function showTeamDetails() {
            if (!assignedTeamData) {
                showToast('No team assigned yet', 'warning');
                return;
            }

            const modal = document.getElementById('dispatchRequestModal');
            const teamListEl = document.getElementById('teamSelectionList');
            const modalTitle = modal.querySelector('.modal-header h2');
            const modalFooter = modal.querySelector('.modal-footer');

            if (!modal || !teamListEl) return;

            // Change modal title
            if (modalTitle) {
                modalTitle.textContent = 'Assigned Team Details';
            }

            // Show loading state
            teamListEl.innerHTML = '<div style="text-align: center; padding: 2rem; color: #64748b;">Loading team details...</div>';
            modal.style.display = 'flex';

            try {
                // Fetch latest team data
                const response = await fetch(`/api/units/${assignedTeamData.id}/members`);
                const result = await response.json();

                if (result.success) {
                    assignedTeamData.membersList = result.data || [];
                }

                const allMembers = assignedTeamData.membersList || [];
                // Exclude leader and deputy from members list
                const membersList = allMembers.filter(member =>
                    member.name !== assignedTeamData.leader1_name &&
                    member.name !== assignedTeamData.leader2_name
                );
                const memberCount = membersList.length;

                // Build team card with map
                teamListEl.innerHTML = `
                    <div class="team-card" style="cursor: default;">
                        <div class="team-card-header">
                            <div class="team-info">
                                <div class="team-name">${assignedTeamData.name || 'Unnamed Team'}</div>
                                <span class="team-status">Assigned</span>
                            </div>
                        </div>
                        <div class="team-details">
                            <div class="team-detail-row">
                                <span class="team-detail-label">Leader:</span>
                                <span class="team-detail-value">${assignedTeamData.leader1_name || '-'}${assignedTeamData.leader1_phone ? ` (${assignedTeamData.leader1_phone})` : ''}</span>
                            </div>
                            <div class="team-detail-row">
                                <span class="team-detail-label">Deputy:</span>
                                <span class="team-detail-value">${assignedTeamData.leader2_name || '-'}${assignedTeamData.leader2_phone ? ` (${assignedTeamData.leader2_phone})` : ''}</span>
                            </div>
                            <div class="team-detail-row">
                                <span class="team-detail-label">Vehicle:</span>
                                <span class="team-detail-value">${getVehicleType(assignedTeamData)}</span>
                            </div>
                            <div class="team-members">
                                <div class="team-detail-label" style="margin-bottom: 0.25rem;">Members (${memberCount}):</div>
                                ${membersList.length > 0
                                    ? membersList.map(member => {
                                        return `<div class="team-member">â€¢ ${member.name || 'Unknown'} (${member.role || 'Operator'})</div>`;
                                    }).join('')
                                    : '<div class="team-member" style="color: #94a3b8;">ë°°ì¹˜ëœ ëŒ€ì› ì—†ìŒ</div>'
                                }
                            </div>

                            <!-- Team Location Map -->
                            <div style="margin-top: 1.5rem;">
                                <div class="team-detail-label" style="margin-bottom: 0.5rem;">Current Location:</div>
                                <div id="teamLocationMap" style="width: 100%; height: 300px; border-radius: 0.5rem; border: 1px solid #e2e8f0;"></div>
                            </div>
                        </div>
                    </div>
                `;

                // Show footer with close button
                if (modalFooter) {
                    modalFooter.style.display = 'flex';
                    modalFooter.innerHTML = `
                        <button class="btn" onclick="closeTeamDetailsModal()">Close</button>
                    `;
                }

                // Initialize Kakao Map with current location - wait for SDK to load
                (async () => {
                    const mapContainer = document.getElementById('teamLocationMap');
                    if (!mapContainer) return;

                    try {
                        // Wait for Kakao Maps SDK to load
                        await kakaoMapsLoadPromise;

                        if (typeof kakao !== 'undefined' && kakao.maps) {
                            // Try to get current location
                            if (navigator.geolocation) {
                                navigator.geolocation.getCurrentPosition(
                                    (position) => {
                                        const lat = position.coords.latitude;
                                        const lng = position.coords.longitude;

                                        const mapOption = {
                                            center: new kakao.maps.LatLng(lat, lng),
                                            level: 3
                                        };
                                        const map = new kakao.maps.Map(mapContainer, mapOption);

                                        // Add marker at current location
                                        const markerPosition = new kakao.maps.LatLng(lat, lng);
                                        const marker = new kakao.maps.Marker({
                                            position: markerPosition
                                        });
                                        marker.setMap(map);
                                    },
                                    (error) => {
                                        console.log('Geolocation error, using default location:', error);
                                        // Fallback to Seoul City Hall
                                        const mapOption = {
                                            center: new kakao.maps.LatLng(37.5665, 126.9780),
                                            level: 3
                                        };
                                        const map = new kakao.maps.Map(mapContainer, mapOption);
                                    }
                                );
                            } else {
                                // Geolocation not supported, use default location
                                const mapOption = {
                                    center: new kakao.maps.LatLng(37.5665, 126.9780),
                                    level: 3
                                };
                                const map = new kakao.maps.Map(mapContainer, mapOption);
                            }
                        } else {
                            console.log('Kakao Maps SDK not available');
                            mapContainer.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; background: #f1f5f9; color: #64748b;">Map unavailable<br/>Kakao Maps SDK not loaded</div>';
                        }
                    } catch (error) {
                        console.error('Error loading Kakao Map:', error);
                        mapContainer.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; background: #f1f5f9; color: #64748b;">Map unavailable<br/>Please check API key</div>';
                    }
                })();

                // Add close button functionality
                const closeBtn = modal.querySelector('.modal-close');
                if (closeBtn) {
                    closeBtn.onclick = function() {
                        modal.style.display = 'none';
                        // Restore original modal state
                        if (modalTitle) {
                            modalTitle.textContent = 'Request Dispatch';
                        }
                        if (modalFooter) {
                            modalFooter.style.display = 'flex';
                        }
                    };
                }

            } catch (error) {
                console.error('Error loading team details:', error);
                teamListEl.innerHTML = '<div style="text-align: center; padding: 2rem; color: #ef4444;">Failed to load team details. Please try again.</div>';
                showToast('Failed to load team details', 'error');
            }
        }

        function closeTeamDetails() {
            const teamDetailsModal = document.getElementById('teamDetailsModal');
            if (teamDetailsModal) {
                teamDetailsModal.style.display = 'none';
            }
        }

        function closeTeamDetailsModal() {
            const modal = document.getElementById('dispatchRequestModal');
            if (modal) {
                modal.style.display = 'none';

                // Restore modal to original state
                const modalTitle = modal.querySelector('.modal-header h2');
                const modalFooter = modal.querySelector('.modal-footer');

                if (modalTitle) {
                    modalTitle.textContent = 'Request Dispatch';
                }
                if (modalFooter) {
                    // Restore original footer buttons
                    modalFooter.innerHTML = `
                        <button class="btn" onclick="closeDispatchRequestModal()">Cancel</button>
                        <button class="btn btn-primary" onclick="confirmDispatchRequest()">Request Dispatch</button>
                    `;
                }
            }
        }

        function refreshLocation() {
            const dispatchLocationEl = document.getElementById('dispatchLocation');
            if (!dispatchLocationEl) return;

            // Show loading state
            const originalValue = dispatchLocationEl.value;
            dispatchLocationEl.value = 'Refreshing...';

            // Simulate location refresh (in real app, this would fetch from GPS/API)
            setTimeout(() => {
                // Generate random location update
                const locations = [
                    'Moving towards incident site',
                    'En route - 2 blocks away',
                    'Approaching destination',
                    'Near incident location',
                    'On main road to site'
                ];
                const randomLocation = locations[Math.floor(Math.random() * locations.length)];
                dispatchLocationEl.value = randomLocation;

                showToast('Location updated', 'success');
            }, 1000);
        }

        // Dispatch request modal functions
        let selectedTeamId = null;
        let availableTeams = [];
        let assignedTeamData = null; // Store assigned team data for details popup

        /**
         * Calculate years of experience from join date
         */
        function calculateExperience(joinDate) {
            if (!joinDate) return 0;
            const join = new Date(joinDate);
            const now = new Date();
            const years = (now - join) / (1000 * 60 * 60 * 24 * 365.25);
            return Math.max(0, years);
        }

        /**
         * Analyze transcript content for emergency keywords and context
         */
        function analyzeTranscriptContent() {
            // Get all transcript text
            const transcriptText = transcriptSegments.map(seg => seg.text).join(' ').toLowerCase();
            const callerAge = parseInt(document.getElementById('callerAge')?.value) || 0;

            const analysis = {
                medicalEmergency: false,
                fireEmergency: false,
                traumaEmergency: false,
                rescueNeeded: false,
                crimeInProgress: false,
                naturalDisaster: false,
                multipleVictims: false,
                criticalCondition: false,
                actualInjury: false,
                elderlyOrChild: callerAge > 65 || callerAge < 18,
                estimatedVictimCount: 1,
                keywords: []
            };

            // Crime keywords
            const crimeKeywords = ['ì¹¼', 'ì´', 'ê´´í•œ', 'ê°•ë„', 'í­í–‰', 'ë‚©ì¹˜', 'ë²”ì£„', 'ë„ë‘‘',
                                  'knife', 'gun', 'weapon', 'robbery', 'assault', 'crime', 'criminal', 'ì«“', 'ìœ„í˜‘'];

            // Medical emergency keywords (actual injury)
            const actualInjuryKeywords = ['í”¼', 'ì¶œí˜ˆ', 'ë‹¤ì³¤', 'ë¶€ìƒ', 'ê³¨ì ˆ', 'í™”ìƒ', 'ì°”ë ¸', 'ë§žì•˜',
                                         'blood', 'bleeding', 'injured', 'wound', 'fracture', 'burn', 'stabbed', 'hit'];

            // Medical emergency keywords (potential/critical)
            const medicalCriticalKeywords = ['í˜¸í¡', 'ì˜ì‹', 'ì‹¬ìž¥', 'ê°€ìŠ´', 'í†µì¦', 'ì“°ëŸ¬', 'ì•„í”„',
                                            'breathing', 'unconscious', 'heart', 'chest', 'pain', 'collapsed'];

            // Fire emergency keywords
            const fireKeywords = ['ë¶ˆ', 'í™”ìž¬', 'ì—°ê¸°', 'íƒ€', 'í­ë°œ', 'fire', 'smoke', 'burning', 'explosion', 'ê°€ìŠ¤'];

            // Trauma/accident keywords
            const traumaKeywords = ['ì‚¬ê³ ', 'ì¶”ë½', 'êµí†µ', 'ì¶©ëŒ', 'ë¼', 'ë¶€ë”ª', 'accident', 'fall', 'crash', 'trapped', 'collision'];

            // Rescue keywords
            const rescueKeywords = ['ê°‡í˜”', 'ë¹ ì¡Œ', 'ë§¤ë‹¬', 'êµ¬ì¡°', 'trapped', 'stuck', 'rescue', 'ë¬¼ì—', 'water', 'ì‚°', 'mountain'];

            // Natural disaster keywords
            const disasterKeywords = ['ì§€ì§„', 'í™ìˆ˜', 'ì‚°ì‚¬íƒœ', 'ë¶•ê´´', 'ë¬´ë„ˆ', 'earthquake', 'flood', 'landslide', 'collapse'];

            // Multiple victims indicators
            const multipleIndicators = [
                { pattern: /(\d+)\s*ëª…/g, multiplier: 1 },
                { pattern: /(\d+)\s*people/gi, multiplier: 1 },
                { pattern: /(ì—¬ëŸ¬|ë§Žì€)\s*(ëª…|ì‚¬ëžŒ)/g, multiplier: 3 },
                { pattern: /(multiple|several)\s*people/gi, multiplier: 3 },
                { pattern: /ì „ì²´|ëª¨ë‘|all/gi, multiplier: 5 }
            ];

            // Check crime
            for (const keyword of crimeKeywords) {
                if (transcriptText.includes(keyword)) {
                    analysis.crimeInProgress = true;
                    analysis.keywords.push(keyword);
                }
            }

            // Check actual injury
            for (const keyword of actualInjuryKeywords) {
                if (transcriptText.includes(keyword)) {
                    analysis.actualInjury = true;
                    analysis.medicalEmergency = true;
                    analysis.keywords.push(keyword);
                }
            }

            // Check medical critical (only if no actual injury)
            if (!analysis.actualInjury) {
                for (const keyword of medicalCriticalKeywords) {
                    if (transcriptText.includes(keyword)) {
                        analysis.criticalCondition = true;
                        analysis.medicalEmergency = true;
                        break;
                    }
                }
            }

            // Check fire emergency
            for (const keyword of fireKeywords) {
                if (transcriptText.includes(keyword)) {
                    analysis.fireEmergency = true;
                    analysis.keywords.push(keyword);
                }
            }

            // Check trauma/accident
            for (const keyword of traumaKeywords) {
                if (transcriptText.includes(keyword)) {
                    analysis.traumaEmergency = true;
                    analysis.keywords.push(keyword);
                }
            }

            // Check rescue needed
            for (const keyword of rescueKeywords) {
                if (transcriptText.includes(keyword)) {
                    analysis.rescueNeeded = true;
                    analysis.keywords.push(keyword);
                }
            }

            // Check natural disaster
            for (const keyword of disasterKeywords) {
                if (transcriptText.includes(keyword)) {
                    analysis.naturalDisaster = true;
                    analysis.multipleVictims = true;
                    analysis.keywords.push(keyword);
                }
            }

            // Estimate victim count
            let maxVictimCount = 1;
            for (const indicator of multipleIndicators) {
                const matches = transcriptText.match(indicator.pattern);
                if (matches) {
                    if (indicator.pattern.source.includes('\\d+')) {
                        // Extract number
                        matches.forEach(match => {
                            const num = parseInt(match.match(/\d+/)[0]);
                            if (num > maxVictimCount) maxVictimCount = num;
                        });
                    } else {
                        maxVictimCount = Math.max(maxVictimCount, indicator.multiplier);
                    }
                    analysis.multipleVictims = maxVictimCount > 1;
                }
            }
            analysis.estimatedVictimCount = maxVictimCount;

            return analysis;
        }

        /**
         * AI recommendation algorithm for dispatch teams
         * Considers: incident type, transcript analysis, team specialization, experience, team size
         */
        function calculateTeamScore(team, incidentType, severityLevel, transcriptAnalysis) {
            let score = 0;
            let reasons = [];
            const memberCount = team.member_count || 0;

            console.log(`\n=== Scoring ${team.name} ===`);
            console.log(`Member count: ${memberCount}`);

            // Calculate average leader experience
            let totalExperience = 0;
            let leaderCount = 0;
            if (team.leader1_join_date) {
                totalExperience += calculateExperience(team.leader1_join_date);
                leaderCount++;
            }
            if (team.leader2_join_date) {
                totalExperience += calculateExperience(team.leader2_join_date);
                leaderCount++;
            }
            const avgExperience = leaderCount > 0 ? totalExperience / leaderCount : 0;

            // Check team specialization
            const hasMedical = (team.leader1_role && (team.leader1_role.toLowerCase().includes('medical') ||
                                                      team.leader1_role.toLowerCase().includes('paramedic'))) ||
                             (team.leader2_role && (team.leader2_role.toLowerCase().includes('medical') ||
                                                    team.leader2_role.toLowerCase().includes('paramedic')));

            const hasPolice = (team.leader1_role && team.leader1_role.toLowerCase().includes('police')) ||
                            (team.leader2_role && team.leader2_role.toLowerCase().includes('police'));

            const hasFirefighter = (team.leader1_role && team.leader1_role.toLowerCase().includes('fire')) ||
                                  (team.leader2_role && team.leader2_role.toLowerCase().includes('fire'));

            const hasRescue = (team.leader1_role && team.leader1_role.toLowerCase().includes('rescue')) ||
                            (team.leader2_role && team.leader2_role.toLowerCase().includes('rescue'));

            // === INCIDENT TYPE MATCHING (HIGHEST PRIORITY) ===
            // Crime situations
            if (incidentType === 'crime' || transcriptAnalysis.crimeInProgress) {
                if (hasPolice) {
                    score += 80;
                    reasons.push('Specialized crime response team');
                    // Medical only if actual injury
                    if (transcriptAnalysis.actualInjury && hasMedical) {
                        score += 30;
                        reasons.push('Capable of treating injured (medical staff present)');
                    } else if (!transcriptAnalysis.actualInjury && !hasMedical) {
                        // Bonus for NOT having medical staff when no injury
                        score += 15;
                    }
                } else {
                    score -= 40; // Heavy penalty for non-police team in crime situation
                }
            }

            // Fire emergencies
            else if (incidentType === 'fire' || transcriptAnalysis.fireEmergency) {
                if (hasFirefighter) {
                    score += 80;
                    reasons.push('Specialized fire suppression team');
                    if (memberCount >= 4) {
                        score += 20;
                        reasons.push(`${memberCount}-member large team - Suitable for fire response`);
                    }
                } else {
                    score -= 40;
                }
            }

            // Rescue operations
            else if (incidentType === 'rescue' || transcriptAnalysis.rescueNeeded) {
                if (hasRescue) {
                    score += 80;
                    reasons.push('Specialized rescue operations team');
                    if (avgExperience >= 5) {
                        score += 25;
                        reasons.push(`${avgExperience.toFixed(1)} years experience - Capable of complex rescue`);
                    }
                } else if (avgExperience >= 5) {
                    score += 30; // Experienced team can handle rescue
                    reasons.push(`${avgExperience.toFixed(1)} years experience - Rescue experience`);
                } else {
                    score -= 20;
                }
            }

            // Medical emergencies
            else if (incidentType === 'emergency' || transcriptAnalysis.medicalEmergency) {
                if (hasMedical) {
                    score += 70;
                    if (transcriptAnalysis.actualInjury) {
                        reasons.push('Actual injury - Medical staff required');
                    } else if (transcriptAnalysis.criticalCondition) {
                        reasons.push('Critical condition - Medical staff on standby');
                    } else if (transcriptAnalysis.elderlyOrChild) {
                        reasons.push('Vulnerable population report - Medical staff present');
                    } else {
                        reasons.push('Capable of emergency response');
                    }
                } else if (transcriptAnalysis.actualInjury) {
                    score -= 50; // Heavy penalty for no medical staff when injured
                } else {
                    score += 10; // Slight preference for medical, but not critical
                }
            }

            // Traffic accidents
            else if (incidentType === 'traffic' || transcriptAnalysis.traumaEmergency) {
                if (hasMedical) {
                    score += 50;
                    reasons.push('Traffic accident - Medical response');
                }
                if (memberCount >= 3) {
                    score += 20;
                    reasons.push('Personnel capable of accident scene control');
                }
            }

            // === TEAM SIZE MATCHING ===
            const requiredTeamSize = transcriptAnalysis.estimatedVictimCount;
            console.log(`Required team size: ${requiredTeamSize}, Incident type: ${incidentType}, Crime in progress: ${transcriptAnalysis.crimeInProgress}`);

            // PRIORITY 1: Crime situations - ALWAYS prefer smaller teams for quick response
            if (incidentType === 'crime' || transcriptAnalysis.crimeInProgress) {
                console.log(`ðŸš¨ CRIME SITUATION DETECTED - Member count: ${memberCount}`);
                // Crime situations need quick, efficient response - prefer small teams
                if (memberCount >= 2 && memberCount <= 4) {
                    score += 100; // VERY strong preference for small teams
                    console.log(`  âœ… Small team bonus: +100, Total so far: ${score}`);
                    if (!reasons.some(r => r.includes('member'))) {
                        reasons.push(`${memberCount}-member rapid response team`);
                    }
                    // Extra bonus for exactly 3 members
                    if (memberCount === 3) {
                        score += 40; // Strong bonus for ideal team size
                        console.log(`  âœ… Perfect 3-member team bonus: +40, Total so far: ${score}`);
                    }
                } else if (memberCount === 5 || memberCount === 6) {
                    score -= 80; // Heavy penalty for medium teams
                    console.log(`  âŒ Medium team penalty: -80, Total so far: ${score}`);
                } else if (memberCount > 6) {
                    score -= 200; // MASSIVE penalty for oversized teams in crimes - makes it impossible to win
                    console.log(`  âŒâŒâŒ OVERSIZED team penalty: -200, Total so far: ${score}`);
                }
            }
            // PRIORITY 2: Natural disasters or very severe situations
            else if (transcriptAnalysis.naturalDisaster || severityLevel >= 4) {
                // Large-scale emergency - need big teams
                if (memberCount >= 5) {
                    score += 30;
                    if (!reasons.some(r => r.includes('ëŒ€ê·œëª¨'))) {
                        reasons.push(`${memberCount}ëª… ëŒ€ê·œëª¨ íŒ€ - ëŒ€í˜• ìž¬ë‚œ ëŒ€ì‘`);
                    }
                } else {
                    score -= 25;
                }
            }
            // PRIORITY 3: Multiple victims
            else if (requiredTeamSize > 3) {
                // Multiple victims - need adequate team
                if (memberCount >= requiredTeamSize) {
                    score += 20;
                    if (!reasons.some(r => r.includes('ëª…'))) {
                        reasons.push(`${memberCount}ëª… íŒ€ - ${requiredTeamSize}ëª… í”¼í•´ìž ëŒ€ì‘`);
                    }
                } else if (memberCount >= 3) {
                    score += 10;
                } else {
                    score -= 15; // Penalty for undersized team
                }
            }
            // PRIORITY 4: General small emergencies
            else {
                // General small emergency - prefer smaller teams
                if (memberCount >= 2 && memberCount <= 4) {
                    score += 15;
                    if (!reasons.some(r => r.includes('ëª…'))) {
                        reasons.push(`${memberCount}ëª… ì ì • ê·œëª¨ íŒ€`);
                    }
                } else if (memberCount > 4) {
                    score -= 10; // Penalty for oversized team
                }
            }

            // === EXPERIENCE BONUS ===
            if (severityLevel >= 3 && avgExperience >= 5 && !reasons.some(r => r.includes('experience'))) {
                score += 20;
                reasons.push(`Team leader with ${avgExperience.toFixed(1)} years experience`);
            } else if (avgExperience >= 3 && !reasons.some(r => r.includes('experience'))) {
                score += 10;
            }

            // === SEVERITY LEVEL ADJUSTMENT ===
            if (severityLevel >= 4) {
                score += 15;
            } else if (severityLevel >= 2) {
                score += 5;
            }

            console.log(`ðŸŽ¯ FINAL SCORE for ${team.name}: ${score}\n`);
            return { score, reasons: reasons.slice(0, 3) }; // Return top 3 reasons
        }

        async function showDispatchRequestModal() {
            const modal = document.getElementById('dispatchRequestModal');
            const teamListEl = document.getElementById('teamSelectionList');
            const modalTitle = modal ? modal.querySelector('.modal-header h2') : null;
            const modalFooter = modal ? modal.querySelector('.modal-footer') : null;

            if (!modal || !teamListEl) return;

            // Restore modal to Request Dispatch state
            if (modalTitle) {
                modalTitle.textContent = 'Request Dispatch';
            }
            if (modalFooter) {
                // Restore original footer buttons
                modalFooter.innerHTML = `
                    <button class="btn" onclick="closeDispatchRequestModal()">Cancel</button>
                    <button class="btn btn-primary" onclick="confirmDispatchRequest()">Request Dispatch</button>
                `;
            }

            // Clear previous selection
            selectedTeamId = null;

            // Show loading state
            teamListEl.innerHTML = '<div style="text-align: center; padding: 2rem; color: #64748b;">Loading teams...</div>';
            modal.style.display = 'flex';

            try {
                // Get current incident type and severity level
                const incidentType = document.getElementById('incidentType')?.value || '';
                const severityLevel = parseInt(document.getElementById('severityLevel')?.value || '1');

                // Analyze transcript content for context-aware recommendations
                const transcriptAnalysis = analyzeTranscriptContent();
                console.log('Transcript analysis:', transcriptAnalysis);

                // Fetch dispatch teams from API (type='dispatch' only)
                const response = await fetch('/api/units');
                const result = await response.json();

                if (!result.success) {
                    throw new Error(result.error || 'Failed to fetch teams');
                }

                // Filter only dispatch teams (exclude intake desks)
                const dispatchTeams = result.data.filter(team => team.type === 'dispatch');

                // Fetch members for each team to get accurate member count and details
                const teamsWithMembers = await Promise.all(dispatchTeams.map(async (team) => {
                    try {
                        const membersResponse = await fetch(`/api/units/${team.id}/members`);
                        const membersResult = await membersResponse.json();

                        if (membersResult.success) {
                            team.membersList = membersResult.data || [];
                        } else {
                            team.membersList = [];
                        }
                    } catch (err) {
                        console.error('Error fetching members for team:', team.id, err);
                        team.membersList = [];
                    }
                    return team;
                }));

                // Calculate AI scores for each team using transcript analysis
                const teamsWithScores = teamsWithMembers.map(team => {
                    const scoreData = calculateTeamScore(team, incidentType, severityLevel, transcriptAnalysis);
                    return {
                        ...team,
                        aiScore: scoreData.score,
                        aiReasons: scoreData.reasons
                    };
                });

                // Sort by AI score (highest first)
                teamsWithScores.sort((a, b) => b.aiScore - a.aiScore);

                // Mark top team as AI recommended (if score is reasonable)
                let recommendedTeam = null;
                if (teamsWithScores.length > 0 && teamsWithScores[0].aiScore >= 30) {
                    teamsWithScores[0].aiRecommended = true;
                    recommendedTeam = teamsWithScores[0];
                }

                availableTeams = teamsWithScores;
                console.log('Teams with scores:', teamsWithScores.map(t => ({
                    name: t.name,
                    score: t.aiScore,
                    reasons: t.aiReasons
                })));

                // Build team cards
                if (availableTeams.length === 0) {
                    teamListEl.innerHTML = '<div style="text-align: center; padding: 2rem; color: #64748b;">No dispatch teams available</div>';
                    return;
                }

                teamListEl.innerHTML = availableTeams.map(team => {
                    const allMembers = team.membersList || [];
                    // Exclude leader and deputy from members list
                    const membersList = allMembers.filter(member =>
                        member.name !== team.leader1_name &&
                        member.name !== team.leader2_name
                    );
                    const memberCount = membersList.length;

                    return `
                        <div class="team-card ${team.aiRecommended ? 'recommended' : ''}" onclick="selectTeam('${team.id}')">
                            ${team.aiRecommended ? `
                                <div class="ai-recommended-badge">
                                    <svg class="ai-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2L2 7l10 5 10-5-10-5z"/><path d="M2 17l10 5 10-5M2 12l10 5 10-5"/></svg>
                                    AI Recommended (Score: ${team.aiScore})
                                </div>
                            ` : ''}
                            <div class="team-card-header">
                                <input type="radio" name="teamSelection" class="team-radio" id="radio-${team.id}" value="${team.id}">
                                <div class="team-info">
                                    <div class="team-name">${team.name || 'Unnamed Team'}</div>
                                    <span class="team-status">Available</span>
                                </div>
                            </div>
                            <div class="team-details">
                                <div class="team-detail-row">
                                    <span class="team-detail-label">Leader:</span>
                                    <span class="team-detail-value">${team.leader1_name || '-'}${team.leader1_phone ? ` (${team.leader1_phone})` : ''}</span>
                                </div>
                                <div class="team-detail-row">
                                    <span class="team-detail-label">Deputy:</span>
                                    <span class="team-detail-value">${team.leader2_name || '-'}${team.leader2_phone ? ` (${team.leader2_phone})` : ''}</span>
                                </div>
                                <div class="team-detail-row">
                                    <span class="team-detail-label">Vehicle:</span>
                                    <span class="team-detail-value" id="selectedTeamVehicle">${getVehicleType(team)}</span>
                                </div>
                                <div class="team-members">
                                    <div class="team-detail-label" style="margin-bottom: 0.25rem;">Members (${memberCount}):</div>
                                    ${membersList.length > 0
                                        ? membersList.map(member => {
                                            return `<div class="team-member">â€¢ ${member.name || 'Unknown'} (${member.role || 'Operator'})</div>`;
                                        }).join('')
                                        : '<div class="team-member" style="color: #94a3b8;">ë°°ì¹˜ëœ ëŒ€ì› ì—†ìŒ</div>'
                                    }
                                </div>
                                ${team.aiRecommended && team.aiReasons && team.aiReasons.length > 0
                                    ? `<div style="margin-top: 0.75rem; padding: 0.75rem; background: linear-gradient(135deg, #667eea15 0%, #764ba215 100%); border-left: 3px solid #667eea; border-radius: 0.375rem;">
                                        <div style="font-size: 0.75rem; font-weight: 600; color: #4c51bf; margin-bottom: 0.375rem; display: flex; align-items: center; gap: 0.25rem;">
                                            <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M12 16v-4"/><path d="M12 8h.01"/></svg>
                                            AI Recommendation Reasons
                                        </div>
                                        ${team.aiReasons.map(reason => `<div style="font-size: 0.8rem; color: #5a67d8; margin-bottom: 0.25rem;">â€¢ ${reason}</div>`).join('')}
                                    </div>`
                                    : ''}
                            </div>
                        </div>
                    `;
                }).join('');

                // Auto-select AI recommended team
                if (recommendedTeam) {
                    // Use setTimeout to ensure DOM is updated before selecting
                    setTimeout(() => {
                        selectedTeamId = recommendedTeam.id;
                        const recommendedCard = document.querySelector(`.team-card.recommended`);
                        if (recommendedCard) {
                            recommendedCard.classList.add('selected');
                        }
                        const radio = document.getElementById(`radio-${recommendedTeam.id}`);
                        if (radio) {
                            radio.checked = true;
                        }
                    }, 10);
                }

            } catch (error) {
                console.error('Error loading dispatch teams:', error);
                teamListEl.innerHTML = '<div style="text-align: center; padding: 2rem; color: #ef4444;">Failed to load teams. Please try again.</div>';
                showToast('Failed to load dispatch teams', 'error');
            }
        }

        function closeDispatchRequestModal() {
            const modal = document.getElementById('dispatchRequestModal');
            if (modal) {
                modal.style.display = 'none';

                // Restore modal to original state
                const modalTitle = modal.querySelector('.modal-header h2');
                const modalFooter = modal.querySelector('.modal-footer');

                if (modalTitle) {
                    modalTitle.textContent = 'Request Dispatch';
                }
                if (modalFooter) {
                    // Restore original footer buttons
                    modalFooter.innerHTML = `
                        <button class="btn" onclick="closeDispatchRequestModal()">Cancel</button>
                        <button class="btn btn-primary" onclick="confirmDispatchRequest()">Request Dispatch</button>
                    `;
                }
            }
            selectedTeamId = null;
        }

        function selectTeam(teamId) {
            selectedTeamId = teamId;

            // Update all team cards
            const cards = document.querySelectorAll('.team-card');
            cards.forEach(card => card.classList.remove('selected'));

            // Select the clicked card
            const selectedCard = event.currentTarget;
            selectedCard.classList.add('selected');

            // Check the radio button
            const radio = document.getElementById(`radio-${teamId}`);
            if (radio) {
                radio.checked = true;
            }
        }

        async function confirmDispatchRequest() {
            if (!selectedTeamId) {
                showToast('Please select a team first', 'warning');
                return;
            }

            const selectedTeam = availableTeams.find(t => t.id === selectedTeamId);
            if (!selectedTeam) {
                showToast('Team not found', 'error');
                return;
            }

            try {
                // TODO: Call API to insert into dispatch table
                // For now, simulate the dispatch request

                // Get vehicle from popup (hardcoded sample value)
                const vehicleText = document.getElementById('selectedTeamVehicle')?.textContent || 'Emergency Vehicle #101';

                // Update dispatch status fields
                document.getElementById('dispatchTeam').value = selectedTeam.name || 'Unknown Team';
                document.getElementById('dispatchVehicle').value = vehicleText;
                document.getElementById('dispatchTime').value = formatTime(new Date());
                document.getElementById('dispatchStatus').value = 'requested';

                // Update Dispatch Ordered time in timeline
                const dispatchOrderedTime = new Date();
                const dispatchOrderedTimeEl = document.getElementById('dispatchOrderedTime');
                if (dispatchOrderedTimeEl) {
                    dispatchOrderedTimeEl.textContent = formatTime(dispatchOrderedTime);
                }

                // Calculate Dispatch Arrived time (Dispatch Ordered + 10 minutes)
                const dispatchArrivedTime = new Date(dispatchOrderedTime);
                dispatchArrivedTime.setMinutes(dispatchArrivedTime.getMinutes() + 10);

                // Update Dispatch Arrived time in timeline
                const dispatchArrivedTimeEl = document.getElementById('dispatchArrivedTime');
                if (dispatchArrivedTimeEl) {
                    dispatchArrivedTimeEl.textContent = formatTime(dispatchArrivedTime);
                }

                // Set ETA (same as Dispatch Arrived time)
                document.getElementById('dispatchETA').value = formatTime(dispatchArrivedTime);

                // Set initial location
                document.getElementById('dispatchLocation').value = 'Departing from station';

                // Update team detail modal with selected team info
                const memberCount = selectedTeam.membersList ? selectedTeam.membersList.length : 0;
                document.getElementById('teamNumber').value = selectedTeam.vehicle || '-';
                document.getElementById('teamName').value = selectedTeam.name || 'Unknown Team';
                document.getElementById('teamLeader').value = selectedTeam.leader1_name
                    ? `${selectedTeam.leader1_name}${selectedTeam.leader1_phone ? ` (${selectedTeam.leader1_phone})` : ''}`
                    : '-';
                document.getElementById('teamDeputy').value = selectedTeam.leader2_name
                    ? `${selectedTeam.leader2_name}${selectedTeam.leader2_phone ? ` (${selectedTeam.leader2_phone})` : ''}`
                    : '-';

                // Store assigned team data for showing details later
                assignedTeamData = selectedTeam;

                showToast(`Dispatch request sent to ${selectedTeam.name}`, 'success');
                closeDispatchRequestModal();

            } catch (error) {
                console.error('Error dispatching team:', error);
                showToast('Failed to dispatch team', 'error');
            }
        }

        function formatTime(date) {
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            const seconds = String(date.getSeconds()).padStart(2, '0');
            return `${hours}:${minutes}:${seconds}`;
        }

        // Get vehicle type based on team role
        function getVehicleType(team) {
            const leader1Role = (team.leader1_role || '').toLowerCase();
            const leader2Role = (team.leader2_role || '').toLowerCase();
            const teamName = (team.name || '').toLowerCase();

            // Check for police
            if (leader1Role.includes('police') || leader2Role.includes('police') ||
                teamName.includes('police') || teamName.includes('ê²½ì°°') || teamName.includes('crime')) {
                return 'Police Vehicle #101';
            }
            // Check for medical/paramedic
            else if (leader1Role.includes('medical') || leader1Role.includes('paramedic') ||
                     leader2Role.includes('medical') || leader2Role.includes('paramedic') ||
                     teamName.includes('medical') || teamName.includes('êµ¬ê¸‰') || teamName.includes('ì˜ë£Œ')) {
                return 'Ambulance #205';
            }
            // Check for fire
            else if (leader1Role.includes('fire') || leader2Role.includes('fire') ||
                     teamName.includes('fire') || teamName.includes('ì†Œë°©')) {
                return 'Fire Truck #303';
            }
            // Check for rescue
            else if (leader1Role.includes('rescue') || leader2Role.includes('rescue') ||
                     teamName.includes('rescue') || teamName.includes('êµ¬ì¡°')) {
                return 'Rescue Vehicle #404';
            }
            // Default
            else {
                return 'Emergency Vehicle #101';
            }
        }

        // Create initial emergency record when call starts (for checklist saving during call)
        async function createInitialEmergency() {
            if (currentEmergencyId) {
                console.log('Emergency record already exists:', currentEmergencyId);
                return; // Already created
            }

            try {
                // Get operator ID from session
                const user = JSON.parse(sessionStorage.getItem('user'));
                const operatorId = user ? user.id : null;

                if (!operatorId) {
                    console.error('Operator ID not found in session');
                    return;
                }

                // Get language from detected language or default to Korean
                const language = detectedLanguage || 'ko';

                // Get caller information (from upload result)
                const callerPhoneNumber = '010-8734-2910';
                const callerName = 'Minsu Kim';

                // Get call started time
                const callStartedAtMs = callStartTime ? callStartTime.getTime() : Date.now();

                console.log('Creating initial emergency record:', {
                    callerPhoneNumber,
                    operatorId,
                    language,
                    callStartedAtMs
                });

                // Call complete emergency API with minimal data
                const response = await fetch('/api/auth/complete-emergency', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        callerPhoneNumber: callerPhoneNumber,
                        callerName: callerName,
                        operatorId: operatorId,
                        language: language,
                        transcript: '', // Empty initially
                        totalDurationMs: 0,
                        speakersCount: 0,
                        utterancesCount: 0,
                        incidentType: null,
                        callerLocation: null,
                        mediaAssetId: mediaAssetId,
                        callStartedAtMs: callStartedAtMs,
                        callEndedAtMs: null // Not ended yet
                    })
                });

                const result = await response.json();

                if (result.success) {
                    // Store emergency ID and caller ID for checklist saving
                    currentEmergencyId = result.emergencyId;
                    currentCallerId = result.callerId;
                    console.log('Initial emergency record created:', result.emergencyId);
                } else {
                    console.error('Failed to create initial emergency:', result.message);
                }
            } catch (error) {
                console.error('Error creating initial emergency:', error);
            }
        }

        // Complete emergency call and save to database
        async function completeEmergency() {
            if (!transcriptSegments || transcriptSegments.length === 0) {
                console.warn('No transcript segments available');
                return;
            }

            try {
                // Calculate call statistics
                const lastSegment = transcriptSegments[transcriptSegments.length - 1];
                const totalDurationMs = Math.round(lastSegment.endTime * 1000); // Convert to milliseconds

                // Count unique speakers
                const speakersCount = new Set(transcriptSegments.map(seg => seg.speakerId)).size;

                // Count total utterances
                const utterancesCount = transcriptSegments.length;

                // Get incident type from UI
                const incidentTypeEl = document.getElementById('incidentType');
                const incidentType = incidentTypeEl ? incidentTypeEl.value : null;

                // Get caller location from UI
                const callerLocationEl = document.getElementById('incidentLocation');
                const callerLocation = callerLocationEl ? callerLocationEl.value : null;

                // Get call ended time (from timeline)
                const callEndedAtMs = callEndTime ? callEndTime.getTime() : Date.now();

                console.log('Completing emergency with data:', {
                    emergencyId: currentEmergencyId,
                    totalDurationMs,
                    speakersCount,
                    utterancesCount,
                    incidentType,
                    callerLocation,
                    callEndedAtMs,
                    transcriptLength: accumulatedTranscript.length
                });

                // Complete the emergency record with final details
                if (currentEmergencyId) {
                    const user = JSON.parse(sessionStorage.getItem('user'));
                    const operatorId = user ? user.id : null;

                    const completeData = {
                        emergencyId: currentEmergencyId,
                        callerPhoneNumber: '010-8734-2910',
                        operatorId: operatorId,
                        language: detectedLanguage || 'ko',
                        transcript: accumulatedTranscript,
                        totalDurationMs: totalDurationMs,
                        speakersCount: speakersCount,
                        utterancesCount: utterancesCount,
                        incidentType: incidentType,
                        callerLocation: callerLocation,
                        callStartedAtMs: callStartTime ? callStartTime.getTime() : null,
                        callEndedAtMs: callEndedAtMs,
                        isUpdate: true  // Flag to indicate this is an update
                    };

                    const response = await fetch('/api/auth/complete-emergency', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(completeData)
                    });

                    const result = await response.json();

                    if (result.success) {
                        console.log('Emergency completed successfully:', currentEmergencyId);

                        // Update UI with risk level from backend
                        if (result.riskLevel !== undefined && result.riskLevel !== null) {
                            const severityLevelEl = document.getElementById('severityLevel');
                            if (severityLevelEl) {
                                severityLevelEl.value = result.riskLevel;
                                console.log('Updated Severity Level to:', result.riskLevel);
                            }
                        }

                        if (result.riskLevelReason) {
                            console.log('Risk Level Reason:', result.riskLevelReason);
                        }
                    } else {
                        console.error('Failed to complete emergency:', result.message);
                        showToast('Failed to complete emergency record: ' + result.message, 'error');
                    }
                } else {
                    console.warn('No emergency ID found, skipping completion');
                }
            } catch (error) {
                console.error('Error completing emergency:', error);
                showToast('Error updating emergency record. Please check the console for details.', 'error');
            }
        }

        // Close modals on outside click
        window.onclick = function(event) {
            if (event.target.classList.contains('modal')) {
                event.target.style.display = 'none';
            }
        }

        // Logout function
        function logout() {
            sessionStorage.removeItem('user');
            window.location.href = 'ecall-intro.html';
        }

        // Incoming Call Simulation
        let incomingCallTimer = null;
        let incomingCallTimer2 = null;
        let ringtoneAudio = null;
        let ringtoneInterval = null;
        let ringtoneInterval2 = null;

        // First call (crime)
        const INCOMING_CALL_NUMBER = '010-1234-5678';
        const INCOMING_CALLER_NAME = 'ê¹€ì—°ì„¸';
        const INCOMING_CALLER_AGE = 30;
        const INCOMING_CALLER_GENDER = 'ì—¬ìž';

        // Second call (disaster)
        const INCOMING_CALL_NUMBER_2 = '010-1111-2222';
        const INCOMING_CALLER_NAME_2 = 'John Doe';
        const INCOMING_CALLER_AGE_2 = 35;
        const INCOMING_CALLER_GENDER_2 = 'ë‚¨ìž';

        // Get ringtone audio element
        let audioInitialized = false;
        window.addEventListener('DOMContentLoaded', function() {
            ringtoneAudio = document.getElementById('ringtoneAudio');
            if (ringtoneAudio) {
                ringtoneAudio.volume = 0.3;
                ringtoneAudio.loop = false;
            }

            // Initialize audio on first user interaction
            const initAudio = () => {
                if (!audioInitialized && ringtoneAudio) {
                    // Try to play and immediately pause to "unlock" audio
                    ringtoneAudio.play().then(() => {
                        ringtoneAudio.pause();
                        ringtoneAudio.currentTime = 0;
                        audioInitialized = true;
                        console.log('Audio initialized successfully');
                    }).catch(err => {
                        console.log('Audio initialization failed:', err);
                    });
                }
            };

            // Listen for any user interaction
            document.addEventListener('click', initAudio, { once: true });
            document.addEventListener('keydown', initAudio, { once: true });
            document.addEventListener('touchstart', initAudio, { once: true });
        });

        // Audio files for each call
        const AUDIO_FILE_CALL_1 = 'https://oeeffpldhwajfmiidayr.supabase.co/storage/v1/object/public/ecall-audio/ecall_simulation_sample_crime.mp3';
        const AUDIO_FILE_CALL_2 = 'https://oeeffpldhwajfmiidayr.supabase.co/storage/v1/object/public/ecall-audio/ecall_simulation_sample_disaster.mp3';

        // Get audio URL for specific call
        function getAudioUrlForCall(callNumber) {
            const audioUrl = callNumber === 1 ? AUDIO_FILE_CALL_1 : AUDIO_FILE_CALL_2;
            console.log(`Selected audio file for call ${callNumber}: ${audioUrl}`);
            return audioUrl;
        }

        // Start incoming call timers on page load
        window.addEventListener('load', function() {
            console.log('Page loaded, starting incoming call timers...');
            incomingCallTimer = setTimeout(() => showIncomingCall(1), 1000); // First call at 1 second
            incomingCallTimer2 = setTimeout(() => showIncomingCall(2), 2000); // Second call at 2 seconds (1 second delay after first)
        });

        function showIncomingCall(callNumber) {
            console.log(`Showing incoming call notification ${callNumber}`);
            const notification = document.getElementById(callNumber === 1 ? 'incomingCallNotification' : 'incomingCallNotification2');
            if (notification) {
                notification.classList.add('show');
            }

            // Play ringtone repeatedly for first call only (to avoid double ringing)
            if (callNumber === 1 && ringtoneAudio) {
                ringtoneInterval = setInterval(() => {
                    ringtoneAudio.currentTime = 0;
                    ringtoneAudio.play().catch(err => {
                        console.log('Could not play ringtone:', err);
                    });
                }, 1000);
            }
        }

        function declineCall(callNumber) {
            console.log(`Call ${callNumber} declined`);
            const notification = document.getElementById(callNumber === 1 ? 'incomingCallNotification' : 'incomingCallNotification2');
            if (notification) {
                notification.classList.remove('show');
            }

            // Stop ringtone (only call 1 has ringtone)
            if (callNumber === 1) {
                if (ringtoneInterval) {
                    clearInterval(ringtoneInterval);
                    ringtoneInterval = null;
                }
                if (ringtoneAudio) {
                    ringtoneAudio.pause();
                    ringtoneAudio.currentTime = 0;
                }
            }

            const phoneNumber = callNumber === 1 ? INCOMING_CALL_NUMBER : INCOMING_CALL_NUMBER_2;
            showToast(`Call from ${phoneNumber} declined`, 'info');

            // Do not schedule next call automatically after decline
        }

        async function acceptCall(callNumber) {
            console.log(`Call ${callNumber} accepted`);

            // Hide both notifications
            const notification1 = document.getElementById('incomingCallNotification');
            const notification2 = document.getElementById('incomingCallNotification2');
            if (notification1) notification1.classList.remove('show');
            if (notification2) notification2.classList.remove('show');

            // Stop ringtone
            if (ringtoneInterval) {
                clearInterval(ringtoneInterval);
                ringtoneInterval = null;
            }
            if (ringtoneAudio) {
                ringtoneAudio.pause();
                ringtoneAudio.currentTime = 0;
            }

            // Get call-specific data
            const phoneNumber = callNumber === 1 ? INCOMING_CALL_NUMBER : INCOMING_CALL_NUMBER_2;
            const callerName = callNumber === 1 ? INCOMING_CALLER_NAME : INCOMING_CALLER_NAME_2;
            const callerAge = callNumber === 1 ? INCOMING_CALLER_AGE : INCOMING_CALLER_AGE_2;
            const callerGender = callNumber === 1 ? INCOMING_CALLER_GENDER : INCOMING_CALLER_GENDER_2;

            // Update caller number in UI
            const callerNumberInput = document.getElementById('callerNumber');
            if (callerNumberInput) {
                callerNumberInput.value = phoneNumber;
            }

            showToast(`Call connected from ${callerName} - Loading audio...`, 'success');

            try {
                // Get audio file for specific call
                const audioUrl = getAudioUrlForCall(callNumber);

                // Fetch audio file from Supabase storage
                console.log('Fetching audio from:', audioUrl);
                const response = await fetch(audioUrl);

                if (!response.ok) {
                    throw new Error(`Failed to fetch audio: ${response.status} ${response.statusText}`);
                }

                const blob = await response.blob();
                console.log('Audio fetched, size:', blob.size, 'type:', blob.type);

                // Create File object from blob
                const audioFile = new File([blob], 'emergency-call.mp3', { type: 'audio/mpeg' });

                // Get operator ID from session
                const user = JSON.parse(sessionStorage.getItem('user'));
                const operatorId = user ? user.id : null;

                // Create FormData - same as uploadFile()
                const formData = new FormData();
                formData.append('file', audioFile);
                formData.append('minSpeakers', '1');
                formData.append('maxSpeakers', '5');
                formData.append('language', 'en-US'); // English audio sample - skip auto-detection

                // Add caller and operator information
                formData.append('callerPhoneNumber', phoneNumber);
                formData.append('callerName', callerName);
                formData.append('callerAge', callerAge);
                formData.append('callerGender', callerGender);
                if (operatorId) {
                    formData.append('operatorId', operatorId);
                }

                // Call Clova API - same endpoint as uploadFile()
                const clovaResponse = await fetch('/api/voice/upload/clova', {
                    method: 'POST',
                    body: formData
                });

                const result = await clovaResponse.json();
                console.log('Clova API result:', result);
                console.log('Speaker segments:', result.speakerSegments);

                if (result.success && result.speakerSegments) {
                    transcriptSegments = result.speakerSegments;
                    console.log('Transcript segments loaded:', transcriptSegments.length, 'segments');

                    // Store language if returned
                    if (result.language) {
                        detectedLanguage = result.language;
                        console.log('Detected language:', detectedLanguage);
                    }

                    // Store media asset ID if returned
                    if (result.mediaAssetId) {
                        mediaAssetId = result.mediaAssetId;
                        console.log('Media asset ID:', mediaAssetId);
                    }

                    // Create audio element for playback
                    try {
                        const audioElementUrl = URL.createObjectURL(audioFile);
                        audioElement = new Audio(audioElementUrl);

                        // Reset displayed segments
                        displayedSegmentIndexes.clear();

                        // Sync transcript with audio playback
                        audioElement.addEventListener('timeupdate', () => {
                            syncTranscriptWithAudio();
                        });

                        // Call start event - change status to on-call
                        audioElement.addEventListener('play', () => {
                            onCallStart();
                        });

                        // Remove active class when audio ends
                        audioElement.addEventListener('ended', () => {
                            const speakerBtn = document.getElementById('speakerBtn');
                            if (speakerBtn) {
                                speakerBtn.classList.remove('active');
                            }
                            // Call end event - change status to available
                            onCallEnd();
                        });

                        // Auto-play audio and activate speaker button
                        audioElement.play();
                        const speakerBtn = document.getElementById('speakerBtn');
                        if (speakerBtn) {
                            speakerBtn.classList.add('active');
                        }
                    } catch (audioError) {
                        console.error('Error creating audio element:', audioError);
                    }

                    // Hide empty state
                    const emptyState = document.getElementById('emptyState');
                    if (emptyState) {
                        emptyState.classList.add('hidden');
                    }

                    // Reset timer
                    stopTimer();
                    seconds = 0;

                    // Initialize transcript display
                    initializeTranscriptDisplay();

                    showToast('Call audio loaded successfully', 'success');
                } else {
                    showToast('Failed to process audio file: ' + (result.error || result.message), 'error');
                }
            } catch (error) {
                console.error('Error loading call audio:', error);
                showToast('Failed to load call audio: ' + error.message, 'error');
            }
        }

    </script>
</body>
</html>
